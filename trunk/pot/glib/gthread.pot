# SOME DESCRIPTIVE TITLE.
# Copyright (C) YEAR THE PACKAGE'S COPYRIGHT HOLDER
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2011-04-17 15:16-0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=INTEGER; plural=EXPRESSION;\n"

#. used by: g_once:
#: gthread.c:1000:3
msgid ""
"@func: the #GThreadFunc function associated to @once. This function is "
"called only once, regardless of the number of times it and its associated "
"#GOnce struct are passed to g_once()."
msgstr ""

#. used by: g_once:
#: gthread.c:1003:1
msgid "@arg: data to be passed to @func"
msgstr ""

#. used by: g_once:
#: gthread.c:1005:5
msgid ""
"The first call to this routine by a process with a given #GOnce struct calls "
"@func with the given argument. Thereafter, subsequent calls to g_once()  "
"with the same #GOnce struct do not call @func again, but return the stored "
"result of the first call. On return from g_once(), the status of @once will "
"be %G_ONCE_STATUS_READY."
msgstr ""

#. used by: g_once:
#: gthread.c:1011:3
msgid ""
"For example, a mutex or a thread-specific data key must be created exactly "
"once. In a threaded environment, calling g_once() ensures that the "
"initialization is serialized across multiple threads."
msgstr ""

#. used by: g_once:
#: gthread.c:1015:2
msgid ""
"<note><para>Calling g_once() recursively on the same #GOnce struct in @func "
"will lead to a deadlock.</para></note>"
msgstr ""

#. #-#-#-#-#  gthread.pot (PACKAGE VERSION)  #-#-#-#-#
#. used by: G_ONCE_INIT:
#. #-#-#-#-#  gthread.pot (PACKAGE VERSION)  #-#-#-#-#
#. used by: g_once:
#. #-#-#-#-#  gthread.pot (PACKAGE VERSION)  #-#-#-#-#
#. used by: g_once_init_enter:
#. #-#-#-#-#  gthread.pot (PACKAGE VERSION)  #-#-#-#-#
#. used by: G_STATIC_MUTEX_INIT:
#. #-#-#-#-#  gthread.pot (PACKAGE VERSION)  #-#-#-#-#
#. used by: G_STATIC_REC_MUTEX_INIT:
#. #-#-#-#-#  gthread.pot (PACKAGE VERSION)  #-#-#-#-#
#. used by: G_STATIC_PRIVATE_INIT:
#. #-#-#-#-#  gthread.pot (PACKAGE VERSION)  #-#-#-#-#
#. used by: g_thread_exit:
#. #-#-#-#-#  gthread.pot (PACKAGE VERSION)  #-#-#-#-#
#. used by: G_STATIC_RW_LOCK_INIT:
#: gthread.c:1018:1 gthread.c:1078:1 gthread.c:1210:1 gthread.c:1373:1
#: gthread.c:1620:1 gthread.c:1997:1 gthread.c:2235:1 gthread.c:976:1
msgid "<informalexample>"
msgstr ""

#. #-#-#-#-#  gthread.pot (PACKAGE VERSION)  #-#-#-#-#
#. used by: G_ONCE_INIT:
#. #-#-#-#-#  gthread.pot (PACKAGE VERSION)  #-#-#-#-#
#. used by: g_once:
#. #-#-#-#-#  gthread.pot (PACKAGE VERSION)  #-#-#-#-#
#. used by: g_once_init_enter:
#. #-#-#-#-#  gthread.pot (PACKAGE VERSION)  #-#-#-#-#
#. used by: G_STATIC_MUTEX_INIT:
#. #-#-#-#-#  gthread.pot (PACKAGE VERSION)  #-#-#-#-#
#. used by: G_STATIC_REC_MUTEX_INIT:
#. #-#-#-#-#  gthread.pot (PACKAGE VERSION)  #-#-#-#-#
#. used by: G_STATIC_PRIVATE_INIT:
#. #-#-#-#-#  gthread.pot (PACKAGE VERSION)  #-#-#-#-#
#. used by: g_thread_exit:
#. #-#-#-#-#  gthread.pot (PACKAGE VERSION)  #-#-#-#-#
#. used by: G_STATIC_RW_LOCK_INIT:
#: gthread.c:1030:1 gthread.c:1091:1 gthread.c:1214:1 gthread.c:1377:1
#: gthread.c:1624:1 gthread.c:2001:1 gthread.c:2239:1 gthread.c:980:1
msgid "</informalexample>"
msgstr ""

#. #-#-#-#-#  gthread.pot (PACKAGE VERSION)  #-#-#-#-#
#. used by: GOnce:
#. #-#-#-#-#  gthread.pot (PACKAGE VERSION)  #-#-#-#-#
#. used by: G_ONCE_INIT:
#. #-#-#-#-#  gthread.pot (PACKAGE VERSION)  #-#-#-#-#
#. used by: GOnceStatus:
#. #-#-#-#-#  gthread.pot (PACKAGE VERSION)  #-#-#-#-#
#. used by: g_once:
#: gthread.c:1032:1 gthread.c:968:1 gthread.c:982:1 gthread.c:994:1
msgid "Since: 2.4"
msgstr ""

#. used by: SECTION: threads
#: gthread.c:106:5
msgid ""
"Please note that since version 2.24 the GObject initialization function "
"g_type_init() initializes threads (with a %NULL argument), so most "
"applications, including those using Gtk+ will run with threads enabled. If "
"you want a special thread implementation, make sure you call g_thread_init() "
"before g_type_init() is called."
msgstr ""

#. #-#-#-#-#  gthread.pot (PACKAGE VERSION)  #-#-#-#-#
#. used by: g_once_init_enter:
#. #-#-#-#-#  gthread.pot (PACKAGE VERSION)  #-#-#-#-#
#. used by: g_once_init_leave:
#: gthread.c:1063:2 gthread.c:1118:2
msgid ""
"@value_location: location of a static initializable variable containing 0."
msgstr ""

#. used by: g_once_init_enter:
#: gthread.c:1065:2
msgid ""
"@Returns: %TRUE if the initialization section should be entered, %FALSE and "
"blocks otherwise"
msgstr ""

#. used by: g_once_init_enter:
#: gthread.c:1068:9
msgid ""
"Function to be called when starting a critical initialization section. The "
"argument @value_location must point to a static 0-initialized variable that "
"will be set to a value other than 0 at the end of the initialization "
"section. In combination with g_once_init_leave() and the unique address "
"@value_location, it can be ensured that an initialization section will be "
"executed only once during a program's life time, and that concurrent threads "
"are blocked until initialization completed. To be used in constructs like "
"this:"
msgstr ""

#. #-#-#-#-#  gthread.pot (PACKAGE VERSION)  #-#-#-#-#
#. used by: g_once_init_enter:
#. #-#-#-#-#  gthread.pot (PACKAGE VERSION)  #-#-#-#-#
#. used by: g_once_init_leave:
#: gthread.c:1093:1 gthread.c:1128:1
msgid "Since: 2.14"
msgstr ""

#. used by: SECTION: threads
#: gthread.c:112:8
msgid ""
"After calling g_thread_init(), GLib is completely thread safe (all global "
"data is automatically locked), but individual data structure instances are "
"not automatically locked for performance reasons. So, for example you must "
"coordinate accesses to the same #GHashTable from multiple threads.  The two "
"notable exceptions from this rule are #GMainLoop and #GAsyncQueue, which "
"<emphasis>are</emphasis> threadsafe and need no further application-level "
"locking to be accessed from multiple threads."
msgstr ""

#. used by: g_once_init_leave:
#: gthread.c:1120:1
msgid "@initialization_value: new non-0 value for *@value_location."
msgstr ""

#. used by: g_once_init_leave:
#: gthread.c:1122:5
msgid ""
"Counterpart to g_once_init_enter(). Expects a location of a static 0-"
"initialized initialization variable, and an initialization value other than "
"0. Sets the variable to the initialization value, and releases concurrent "
"threads blocking in g_once_init_enter() on this initialization variable."
msgstr ""

#. used by: GStaticMutex:
#: gthread.c:1150:5
msgid ""
"A #GStaticMutex works like a #GMutex, but it has one significant advantage. "
"It doesn't need to be created at run-time like a #GMutex, but can be defined "
"at compile-time. Here is a shorter, easier and safer version of our "
"<function>give_me_next_number()</function> example:"
msgstr ""

#. used by: GStaticMutex:
#: gthread.c:1156:5
msgid ""
"<example> <title> Using <structname>GStaticMutex</structname> to simplify "
"thread-safe programming </title>"
msgstr ""

#. #-#-#-#-#  gthread.pot (PACKAGE VERSION)  #-#-#-#-#
#. used by: G_LOCK_DEFINE:
#. #-#-#-#-#  gthread.pot (PACKAGE VERSION)  #-#-#-#-#
#. used by: GMutex:
#. #-#-#-#-#  gthread.pot (PACKAGE VERSION)  #-#-#-#-#
#. used by: GMutex:
#. #-#-#-#-#  gthread.pot (PACKAGE VERSION)  #-#-#-#-#
#. used by: GMutex:
#. #-#-#-#-#  gthread.pot (PACKAGE VERSION)  #-#-#-#-#
#. used by: GCond:
#. #-#-#-#-#  gthread.pot (PACKAGE VERSION)  #-#-#-#-#
#. used by: GPrivate:
#. #-#-#-#-#  gthread.pot (PACKAGE VERSION)  #-#-#-#-#
#. used by: GStaticMutex:
#. #-#-#-#-#  gthread.pot (PACKAGE VERSION)  #-#-#-#-#
#. used by: GStaticPrivate:
#. #-#-#-#-#  gthread.pot (PACKAGE VERSION)  #-#-#-#-#
#. used by: GStaticRWLock:
#: gthread.c:1176:1 gthread.c:1611:1 gthread.c:194:1 gthread.c:2191:1
#: gthread.c:379:1 gthread.c:404:1 gthread.c:441:1 gthread.c:573:1
#: gthread.c:708:1
msgid "</example>"
msgstr ""

#. used by: GStaticMutex:
#: gthread.c:1178:8
msgid ""
"Sometimes you would like to dynamically create a mutex. If you don't want to "
"require prior calling to g_thread_init(), because your code should also be "
"usable in non-threaded programs, you are not able to use g_mutex_new() and "
"thus #GMutex, as that requires a prior call to g_thread_init(). In theses "
"cases you can also use a #GStaticMutex. It must be initialized with "
"g_static_mutex_init() before using it and freed with with g_static_mutex_free"
"() when not needed anymore to free up any allocated resources."
msgstr ""

#. used by: GStaticMutex:
#: gthread.c:1187:3
msgid ""
"Even though #GStaticMutex is not opaque, it should only be used with the "
"following functions, as it is defined differently on different platforms."
msgstr ""

#. used by: GStaticMutex:
#: gthread.c:1191:5
msgid ""
"All of the <function>g_static_mutex_*</function> functions apart from "
"<function>g_static_mutex_get_mutex</function> can also be used even if "
"g_thread_init() has not yet been called. Then they do nothing, apart from "
"<function>g_static_mutex_trylock</function>, which does nothing but "
"returning %TRUE."
msgstr ""

#. used by: GStaticMutex:
#: gthread.c:1197:3
msgid ""
"<note><para>All of the <function>g_static_mutex_*</function> functions are "
"actually macros. Apart from taking their addresses, you can however use them "
"as if they were functions.</para></note>"
msgstr ""

#. used by: G_STATIC_MUTEX_INIT:
#: gthread.c:1205:4
msgid ""
"A #GStaticMutex must be initialized with this macro, before it can be used. "
"This macro can used be to initialize a variable, but it cannot be assigned "
"to a variable. In that case you have to use g_static_mutex_init()."
msgstr ""

#. used by: SECTION: threads
#: gthread.c:121:4
msgid ""
"To help debugging problems in multithreaded applications, GLib supports "
"error-checking mutexes that will give you helpful error messages on common "
"problems. To use error-checking mutexes, define the symbol "
"#G_ERRORCHECK_MUTEXES when compiling the application."
msgstr ""

#. used by: g_static_mutex_init:
#: gthread.c:1219:1
msgid "@mutex: a #GStaticMutex to be initialized."
msgstr ""

#. used by: g_static_mutex_init:
#: gthread.c:1221:2
msgid ""
"Initializes @mutex. Alternatively you can initialize it with "
"#G_STATIC_MUTEX_INIT."
msgstr ""

#. #-#-#-#-#  gthread.pot (PACKAGE VERSION)  #-#-#-#-#
#. used by: g_static_mutex_get_mutex:
#. #-#-#-#-#  gthread.pot (PACKAGE VERSION)  #-#-#-#-#
#. used by: g_static_mutex_lock:
#. #-#-#-#-#  gthread.pot (PACKAGE VERSION)  #-#-#-#-#
#. used by: g_static_mutex_trylock:
#. #-#-#-#-#  gthread.pot (PACKAGE VERSION)  #-#-#-#-#
#. used by: g_static_mutex_unlock:
#: gthread.c:1253:1 gthread.c:1288:1 gthread.c:1295:1 gthread.c:1303:1
msgid "@mutex: a #GStaticMutex."
msgstr ""

#. used by: g_static_mutex_get_mutex:
#: gthread.c:1254:1
msgid "@Returns: the #GMutex corresponding to @mutex."
msgstr ""

#. used by: g_static_mutex_get_mutex:
#: gthread.c:1256:3
msgid ""
"For some operations (like g_cond_wait()) you must have a #GMutex instead of "
"a #GStaticMutex. This function will return the corresponding #GMutex for "
"@mutex."
msgstr ""

#. used by: g_static_mutex_lock:
#: gthread.c:1290:1
msgid "Works like g_mutex_lock(), but for a #GStaticMutex."
msgstr ""

#. used by: g_static_mutex_trylock:
#: gthread.c:1296:1
msgid "@Returns: %TRUE, if the #GStaticMutex could be locked."
msgstr ""

#. used by: g_static_mutex_trylock:
#: gthread.c:1298:1
msgid "Works like g_mutex_trylock(), but for a #GStaticMutex."
msgstr ""

#. used by: G_THREADS_IMPL_POSIX:
#: gthread.c:130:1
msgid "This macro is defined if POSIX style threads are used."
msgstr ""

#. used by: g_static_mutex_unlock:
#: gthread.c:1305:1
msgid "Works like g_mutex_unlock(), but for a #GStaticMutex."
msgstr ""

#. used by: g_static_mutex_free:
#: gthread.c:1310:1
msgid "@mutex: a #GStaticMutex to be freed."
msgstr ""

#. used by: g_static_mutex_free:
#: gthread.c:1312:1
msgid "Releases all resources allocated to @mutex."
msgstr ""

#. used by: g_static_mutex_free:
#: gthread.c:1314:4
msgid ""
"You don't have to call this functions for a #GStaticMutex with an unbounded "
"lifetime, i.e. objects declared 'static', but if you have a #GStaticMutex as "
"a member of a structure and the structure is freed, you should also free the "
"#GStaticMutex."
msgstr ""

#. used by: g_static_mutex_free:
#: gthread.c:1319:2
msgid ""
"<note><para>Calling g_static_mutex_free() on a locked mutex may result in "
"undefined behaviour.</para></note>"
msgstr ""

#. used by: GStaticRecMutex:
#: gthread.c:1347:8
msgid ""
"A #GStaticRecMutex works like a #GStaticMutex, but it can be locked multiple "
"times by one thread. If you enter it n times, you have to unlock it n times "
"again to let other threads lock it. An exception is the function "
"g_static_rec_mutex_unlock_full(): that allows you to unlock a "
"#GStaticRecMutex completely returning the depth, (i.e. the number of times "
"this mutex was locked). The depth can later be used to restore the state of "
"the #GStaticRecMutex by calling g_static_rec_mutex_lock_full()."
msgstr ""

#. used by: GStaticRecMutex:
#: gthread.c:1356:2
msgid ""
"Even though #GStaticRecMutex is not opaque, it should only be used with the "
"following functions."
msgstr ""

#. used by: GStaticRecMutex:
#: gthread.c:1359:4
msgid ""
"All of the <function>g_static_rec_mutex_*</function> functions can be used "
"even if g_thread_init() has not been called. Then they do nothing, apart "
"from <function>g_static_rec_mutex_trylock</function>, which does nothing but "
"returning %TRUE."
msgstr ""

#. used by: G_THREADS_ENABLED:
#: gthread.c:136:6
msgid ""
"This macro is defined if GLib was compiled with thread support. This does "
"not necessarily mean that there is a thread implementation available, but it "
"does mean that the infrastructure is in place and that once you provide a "
"thread implementation to g_thread_init(), GLib will be multi-thread safe. If "
"#G_THREADS_ENABLED is not defined, then Glib is not, and cannot be, multi-"
"thread safe."
msgstr ""

#. used by: G_STATIC_REC_MUTEX_INIT:
#: gthread.c:1368:4
msgid ""
"A #GStaticRecMutex must be initialized with this macro before it can be "
"used. This macro can used be to initialize a variable, but it cannot be "
"assigned to a variable. In that case you have to use g_static_rec_mutex_init"
"()."
msgstr ""

#. used by: g_static_rec_mutex_init:
#: gthread.c:1382:1
msgid "@mutex: a #GStaticRecMutex to be initialized."
msgstr ""

#. used by: g_static_rec_mutex_init:
#: gthread.c:1384:3
msgid ""
"A #GStaticRecMutex must be initialized with this function before it can be "
"used. Alternatively you can initialize it with #G_STATIC_REC_MUTEX_INIT."
msgstr ""

#. #-#-#-#-#  gthread.pot (PACKAGE VERSION)  #-#-#-#-#
#. used by: g_static_rec_mutex_lock:
#. #-#-#-#-#  gthread.pot (PACKAGE VERSION)  #-#-#-#-#
#. used by: g_static_rec_mutex_trylock:
#. #-#-#-#-#  gthread.pot (PACKAGE VERSION)  #-#-#-#-#
#. used by: g_static_rec_mutex_lock_full:
#: gthread.c:1400:1 gthread.c:1431:1 gthread.c:1495:1
msgid "@mutex: a #GStaticRecMutex to lock."
msgstr ""

#. used by: g_static_rec_mutex_lock:
#: gthread.c:1402:4
msgid ""
"Locks @mutex. If @mutex is already locked by another thread, the current "
"thread will block until @mutex is unlocked by the other thread. If @mutex is "
"already locked by the calling thread, this functions increases the depth of "
"@mutex and returns immediately."
msgstr ""

#. #-#-#-#-#  gthread.pot (PACKAGE VERSION)  #-#-#-#-#
#. used by: g_mutex_trylock:
#. #-#-#-#-#  gthread.pot (PACKAGE VERSION)  #-#-#-#-#
#. used by: g_static_rec_mutex_trylock:
#: gthread.c:1432:1 gthread.c:489:1
msgid "@Returns: %TRUE, if @mutex could be locked."
msgstr ""

#. used by: g_static_rec_mutex_trylock:
#: gthread.c:1434:5
msgid ""
"Tries to lock @mutex. If @mutex is already locked by another thread, it "
"immediately returns %FALSE. Otherwise it locks @mutex and returns %TRUE. If "
"@mutex is already locked by the calling thread, this functions increases the "
"depth of @mutex and immediately returns %TRUE."
msgstr ""

#. used by: g_static_rec_mutex_unlock:
#: gthread.c:1468:1
msgid "@mutex: a #GStaticRecMutex to unlock."
msgstr ""

#. used by: G_THREADS_IMPL_NONE:
#: gthread.c:147:3
msgid ""
"This macro is defined if no thread implementation is used. You can, however, "
"provide one to g_thread_init() to make GLib multi-thread safe."
msgstr ""

#. used by: g_static_rec_mutex_unlock:
#: gthread.c:1470:5
msgid ""
"Unlocks @mutex. Another thread will be allowed to lock @mutex only when it "
"has been unlocked as many times as it had been locked before. If @mutex is "
"completely unlocked and another thread is blocked in a "
"g_static_rec_mutex_lock() call for @mutex, it will be woken and can lock "
"@mutex itself."
msgstr ""

#. used by: g_static_rec_mutex_lock_full:
#: gthread.c:1496:2
msgid ""
"@depth: number of times this mutex has to be unlocked to be completely "
"unlocked."
msgstr ""

#. used by: g_static_rec_mutex_lock_full:
#: gthread.c:1499:1
msgid "Works like calling g_static_rec_mutex_lock() for @mutex @depth times."
msgstr ""

#. used by: g_static_rec_mutex_unlock_full:
#: gthread.c:1528:1
msgid "@mutex: a #GStaticRecMutex to completely unlock."
msgstr ""

#. used by: g_static_rec_mutex_unlock_full:
#: gthread.c:1529:2
msgid "@Returns: number of times @mutex has been locked by the current thread."
msgstr ""

#. used by: g_static_rec_mutex_unlock_full:
#: gthread.c:1532:7
msgid ""
"Completely unlocks @mutex. If another thread is blocked in a "
"g_static_rec_mutex_lock() call for @mutex, it will be woken and can lock "
"@mutex itself. This function returns the number of times that @mutex has "
"been locked by the current thread. To restore the state before the call to "
"g_static_rec_mutex_unlock_full() you can call g_static_rec_mutex_lock_full() "
"with the depth returned by this function."
msgstr ""

#. used by: g_static_rec_mutex_free:
#: gthread.c:1561:1
msgid "@mutex: a #GStaticRecMutex to be freed."
msgstr ""

#. used by: g_static_rec_mutex_free:
#: gthread.c:1563:1
msgid "Releases all resources allocated to a #GStaticRecMutex."
msgstr ""

#. used by: g_static_rec_mutex_free:
#: gthread.c:1565:4
msgid ""
"You don't have to call this functions for a #GStaticRecMutex with an "
"unbounded lifetime, i.e. objects declared 'static', but if you have a "
"#GStaticRecMutex as a member of a structure and the structure is freed, you "
"should also free the #GStaticRecMutex."
msgstr ""

#. used by: GStaticPrivate:
#: gthread.c:1583:6
msgid ""
"A #GStaticPrivate works almost like a #GPrivate, but it has one significant "
"advantage. It doesn't need to be created at run-time like a #GPrivate, but "
"can be defined at compile-time. This is similar to the difference between "
"#GMutex and #GStaticMutex. Now look at our <function>give_me_next_number()</"
"function> example with #GStaticPrivate:"
msgstr ""

#. used by: GStaticPrivate:
#: gthread.c:1590:2
msgid "<example> <title>Using GStaticPrivate for per-thread data</title>"
msgstr ""

#. used by: G_STATIC_PRIVATE_INIT:
#: gthread.c:1617:2
msgid ""
"Every #GStaticPrivate must be initialized with this macro, before it can be "
"used."
msgstr ""

#. #-#-#-#-#  gthread.pot (PACKAGE VERSION)  #-#-#-#-#
#. used by: G_LOCK_DEFINE:
#. #-#-#-#-#  gthread.pot (PACKAGE VERSION)  #-#-#-#-#
#. used by: G_LOCK_DEFINE_STATIC:
#. #-#-#-#-#  gthread.pot (PACKAGE VERSION)  #-#-#-#-#
#. used by: G_LOCK_EXTERN:
#. #-#-#-#-#  gthread.pot (PACKAGE VERSION)  #-#-#-#-#
#. used by: G_LOCK:
#. #-#-#-#-#  gthread.pot (PACKAGE VERSION)  #-#-#-#-#
#. used by: G_TRYLOCK:
#. #-#-#-#-#  gthread.pot (PACKAGE VERSION)  #-#-#-#-#
#. used by: G_UNLOCK:
#: gthread.c:162:1 gthread.c:199:1 gthread.c:206:1 gthread.c:214:1
#: gthread.c:222:1 gthread.c:231:1
msgid "@name: the name of the lock."
msgstr ""

#. used by: g_static_private_init:
#: gthread.c:1629:1
msgid "@private_key: a #GStaticPrivate to be initialized."
msgstr ""

#. used by: g_static_private_init:
#: gthread.c:1631:2
msgid ""
"Initializes @private_key. Alternatively you can initialize it with "
"#G_STATIC_PRIVATE_INIT."
msgstr ""

#. used by: G_LOCK_DEFINE:
#: gthread.c:164:11
msgid ""
"The %G_LOCK_* macros provide a convenient interface to #GStaticMutex with "
"the advantage that they will expand to nothing in programs compiled against "
"a thread-disabled GLib, saving code and memory there. #G_LOCK_DEFINE defines "
"a lock. It can appear anywhere variable definitions may appear in programs, "
"i.e. in the first block of a function or outside of functions. The @name "
"parameter will be mangled to get the name of the #GStaticMutex. This means "
"that you can use names of existing variables as the parameter - e.g. the "
"name of the variable you intent to protect with the lock. Look at our "
"<function>give_me_next_number()</function> example using the %G_LOCK_* "
"macros:"
msgstr ""

#. #-#-#-#-#  gthread.pot (PACKAGE VERSION)  #-#-#-#-#
#. used by: g_static_private_get:
#. #-#-#-#-#  gthread.pot (PACKAGE VERSION)  #-#-#-#-#
#. used by: g_static_private_set:
#: gthread.c:1642:1 gthread.c:1670:1
msgid "@private_key: a #GStaticPrivate."
msgstr ""

#. #-#-#-#-#  gthread.pot (PACKAGE VERSION)  #-#-#-#-#
#. used by: g_private_get:
#. #-#-#-#-#  gthread.pot (PACKAGE VERSION)  #-#-#-#-#
#. used by: g_static_private_get:
#: gthread.c:1643:1 gthread.c:750:1
msgid "@Returns: the corresponding pointer."
msgstr ""

#. used by: g_static_private_get:
#: gthread.c:1645:1
msgid "Works like g_private_get() only for a #GStaticPrivate."
msgstr ""

#. used by: g_static_private_get:
#: gthread.c:1647:1
msgid "This function works even if g_thread_init() has not yet been called."
msgstr ""

#. #-#-#-#-#  gthread.pot (PACKAGE VERSION)  #-#-#-#-#
#. used by: g_private_set:
#. #-#-#-#-#  gthread.pot (PACKAGE VERSION)  #-#-#-#-#
#. used by: g_static_private_set:
#: gthread.c:1671:1 gthread.c:770:1
msgid "@data: the new pointer."
msgstr ""

#. used by: g_static_private_set:
#: gthread.c:1672:2
msgid ""
"@notify: a function to be called with the pointer whenever the current "
"thread ends or sets this pointer again."
msgstr ""

#. used by: g_static_private_set:
#: gthread.c:1675:4
msgid ""
"Sets the pointer keyed to @private_key for the current thread and the "
"function @notify to be called with that pointer (%NULL or non-%NULL), "
"whenever the pointer is set again or whenever the current thread ends."
msgstr ""

#. used by: g_static_private_set:
#: gthread.c:1680:4
msgid ""
"This function works even if g_thread_init() has not yet been called. If "
"g_thread_init() is called later, the @data keyed to @private_key will be "
"inherited only by the main thread, i.e. the one that called g_thread_init()."
msgstr ""

#. used by: g_static_private_set:
#: gthread.c:1685:2
msgid ""
"<note><para>@notify is used quite differently from @destructor in "
"g_private_new().</para></note>"
msgstr ""

#. used by: g_static_private_free:
#: gthread.c:1749:1
msgid "@private_key: a #GStaticPrivate to be freed."
msgstr ""

#. used by: g_static_private_free:
#: gthread.c:1751:1
msgid "Releases all resources allocated to @private_key."
msgstr ""

#. used by: g_static_private_free:
#: gthread.c:1753:4
msgid ""
"You don't have to call this functions for a #GStaticPrivate with an "
"unbounded lifetime, i.e. objects declared 'static', but if you have a "
"#GStaticPrivate as a member of a structure and the structure is freed, you "
"should also free the #GStaticPrivate."
msgstr ""

#. used by: G_LOCK_DEFINE:
#: gthread.c:176:2
msgid "<example> <title>Using the %G_LOCK_* convenience macros</title>"
msgstr ""

#. #-#-#-#-#  gthread.pot (PACKAGE VERSION)  #-#-#-#-#
#. used by: g_thread_create:
#. #-#-#-#-#  gthread.pot (PACKAGE VERSION)  #-#-#-#-#
#. used by: g_thread_create_full:
#: gthread.c:1904:1 gthread.c:820:1
msgid "@func: a function to execute in the new thread."
msgstr ""

#. #-#-#-#-#  gthread.pot (PACKAGE VERSION)  #-#-#-#-#
#. used by: g_thread_create:
#. #-#-#-#-#  gthread.pot (PACKAGE VERSION)  #-#-#-#-#
#. used by: g_thread_create_full:
#: gthread.c:1905:1 gthread.c:821:1
msgid "@data: an argument to supply to the new thread."
msgstr ""

#. used by: g_thread_create_full:
#: gthread.c:1906:1
msgid "@stack_size: a stack size for the new thread."
msgstr ""

#. #-#-#-#-#  gthread.pot (PACKAGE VERSION)  #-#-#-#-#
#. used by: g_thread_create:
#. #-#-#-#-#  gthread.pot (PACKAGE VERSION)  #-#-#-#-#
#. used by: g_thread_create_full:
#: gthread.c:1907:1 gthread.c:822:1
msgid "@joinable: should this thread be joinable?"
msgstr ""

#. used by: g_thread_create_full:
#: gthread.c:1908:1
msgid "@bound: should this thread be bound to a system thread?"
msgstr ""

#. used by: g_thread_create_full:
#: gthread.c:1909:1
msgid "@priority: a priority for the thread."
msgstr ""

#. #-#-#-#-#  gthread.pot (PACKAGE VERSION)  #-#-#-#-#
#. used by: g_thread_create:
#. #-#-#-#-#  gthread.pot (PACKAGE VERSION)  #-#-#-#-#
#. used by: g_thread_create_full:
#: gthread.c:1910:1 gthread.c:823:1
msgid "@error: return location for error."
msgstr ""

#. #-#-#-#-#  gthread.pot (PACKAGE VERSION)  #-#-#-#-#
#. used by: g_thread_create:
#. #-#-#-#-#  gthread.pot (PACKAGE VERSION)  #-#-#-#-#
#. used by: g_thread_create_full:
#: gthread.c:1911:1 gthread.c:824:1
msgid "@Returns: the new #GThread on success."
msgstr ""

#. used by: g_thread_create_full:
#: gthread.c:1913:4
msgid ""
"This function creates a new thread with the priority @priority. If the "
"underlying thread implementation supports it, the thread gets a stack size "
"of @stack_size or the default value for the current platform, if @stack_size "
"is 0."
msgstr ""

#. used by: g_thread_create_full:
#: gthread.c:1918:7
msgid ""
"If @joinable is %TRUE, you can wait for this threads termination calling "
"g_thread_join(). Otherwise the thread will just disappear when it "
"terminates. If @bound is %TRUE, this thread will be scheduled in the system "
"scope, otherwise the implementation is free to do scheduling in the process "
"scope. The first variant is more expensive resource-wise, but generally "
"faster. On some systems (e.g. Linux) all threads are bound."
msgstr ""

#. #-#-#-#-#  gthread.pot (PACKAGE VERSION)  #-#-#-#-#
#. used by: g_thread_create:
#. #-#-#-#-#  gthread.pot (PACKAGE VERSION)  #-#-#-#-#
#. used by: g_thread_create_full:
#: gthread.c:1926:2 gthread.c:832:2
msgid ""
"The new thread executes the function @func with the argument @data. If the "
"thread was created successfully, it is returned."
msgstr ""

#. #-#-#-#-#  gthread.pot (PACKAGE VERSION)  #-#-#-#-#
#. used by: g_thread_create:
#. #-#-#-#-#  gthread.pot (PACKAGE VERSION)  #-#-#-#-#
#. used by: g_thread_create_full:
#: gthread.c:1929:2 gthread.c:835:2
msgid ""
"@error can be %NULL to ignore errors, or non-%NULL to report errors. The "
"error is set, if and only if the function returns %NULL."
msgstr ""

#. used by: g_thread_create_full:
#: gthread.c:1932:6
msgid ""
"<note><para>It is not guaranteed that threads with different priorities "
"really behave accordingly. On some systems (e.g. Linux) there are no thread "
"priorities. On other systems (e.g. Solaris) there doesn't seem to be "
"different scheduling for different priorities. All in all try to avoid being "
"dependent on priorities. Use %G_THREAD_PRIORITY_NORMAL here as a default.</"
"para></note>"
msgstr ""

#. used by: g_thread_create_full:
#: gthread.c:1939:4
msgid ""
"<note><para>Only use g_thread_create_full() if you really can't use "
"g_thread_create() instead. g_thread_create() does not take @stack_size, "
"@bound, and @priority as arguments, as they should only be used in cases in "
"which it is unavoidable.</para></note>"
msgstr ""

#. used by: g_thread_exit:
#: gthread.c:1989:1
msgid "@retval: the return value of this thread."
msgstr ""

#. used by: g_thread_exit:
#: gthread.c:1991:5
msgid ""
"Exits the current thread. If another thread is waiting for that thread using "
"g_thread_join() and the current thread is joinable, the waiting thread will "
"be woken up and get @retval as the return value of g_thread_join(). If the "
"current thread is not joinable, @retval is ignored. Calling"
msgstr ""

#. used by: g_thread_exit:
#: gthread.c:2003:2
msgid ""
"is equivalent to returning @retval from the function @func, as given to "
"g_thread_create()."
msgstr ""

#. used by: g_thread_exit:
#: gthread.c:2006:3
msgid ""
"<note><para>Never call g_thread_exit() from within a thread of a "
"#GThreadPool, as that will mess up the bookkeeping and lead to funny and "
"unwanted results.</para></note>"
msgstr ""

#. used by: G_LOCK_DEFINE_STATIC:
#: gthread.c:201:1
msgid "This works like #G_LOCK_DEFINE, but it creates a static object."
msgstr ""

#. used by: g_thread_join:
#: gthread.c:2020:1
msgid "@thread: a #GThread to be waited for."
msgstr ""

#. used by: g_thread_join:
#: gthread.c:2021:1
msgid "@Returns: the return value of the thread."
msgstr ""

#. used by: g_thread_join:
#: gthread.c:2023:6
msgid ""
"Waits until @thread finishes, i.e. the function @func, as given to "
"g_thread_create(), returns or g_thread_exit() is called by @thread. All "
"resources of @thread including the #GThread struct are released. @thread "
"must have been created with @joinable=%TRUE in g_thread_create(). The value "
"returned by @func or given to g_thread_exit() by @thread is returned by this "
"function."
msgstr ""

#. used by: g_thread_set_priority:
#: gthread.c:2075:1
msgid "@thread: a #GThread."
msgstr ""

#. used by: g_thread_set_priority:
#: gthread.c:2076:1
msgid "@priority: a new priority for @thread."
msgstr ""

#. used by: g_thread_set_priority:
#: gthread.c:2078:1
msgid "Changes the priority of @thread to @priority."
msgstr ""

#. used by: G_LOCK_EXTERN:
#: gthread.c:208:2
msgid ""
"This declares a lock, that is defined with #G_LOCK_DEFINE in another module."
msgstr ""

#. #-#-#-#-#  gthread.pot (PACKAGE VERSION)  #-#-#-#-#
#. used by: GThreadPriority:
#. #-#-#-#-#  gthread.pot (PACKAGE VERSION)  #-#-#-#-#
#. used by: g_thread_set_priority:
#: gthread.c:2080:5 gthread.c:811:5
msgid ""
"<note><para>It is not guaranteed that threads with different priorities "
"really behave accordingly. On some systems (e.g. Linux) there are no thread "
"priorities. On other systems (e.g. Solaris) there doesn't seem to be "
"different scheduling for different priorities. All in all try to avoid being "
"dependent on priorities.</para></note>"
msgstr ""

#. used by: g_thread_self:
#: gthread.c:2105:1
msgid "@Returns: the current thread."
msgstr ""

#. used by: g_thread_self:
#: gthread.c:2107:2
msgid ""
"This functions returns the #GThread corresponding to the calling thread."
msgstr ""

#. used by: GStaticRWLock:
#: gthread.c:2147:6
msgid ""
"The #GStaticRWLock struct represents a read-write lock. A read-write lock "
"can be used for protecting data that some portions of code only read from, "
"while others also write. In such situations it is desirable that several "
"readers can read at once, whereas of course only one writer may write at a "
"time. Take a look at the following example:"
msgstr ""

#. used by: GStaticRWLock:
#: gthread.c:2154:2
msgid "<example> <title>An array with access functions</title>"
msgstr ""

#. used by: G_LOCK:
#: gthread.c:216:2
msgid "Works like g_mutex_lock(), but for a lock defined with #G_LOCK_DEFINE."
msgstr ""

#. used by: GStaticRWLock:
#: gthread.c:2193:7
msgid ""
"This example shows an array which can be accessed by many readers (the "
"<function>my_array_get()</function> function) simultaneously, whereas the "
"writers (the <function>my_array_set()</function> function) will only be "
"allowed once at a time and only if no readers currently access the array. "
"This is because of the potentially dangerous resizing of the array. Using "
"these functions is fully multi-thread safe now."
msgstr ""

#. used by: GStaticRWLock:
#: gthread.c:2201:6
msgid ""
"Most of the time, writers should have precedence over readers. That means, "
"for this implementation, that as soon as a writer wants to lock the data, no "
"other reader is allowed to lock the data, whereas, of course, the readers "
"that already have locked the data are allowed to finish their operation. As "
"soon as the last reader unlocks the data, the writer will lock it."
msgstr ""

#. used by: GStaticRWLock:
#: gthread.c:2208:2
msgid ""
"Even though #GStaticRWLock is not opaque, it should only be used with the "
"following functions."
msgstr ""

#. used by: GStaticRWLock:
#: gthread.c:2211:4
msgid ""
"All of the <function>g_static_rw_lock_*</function> functions can be used "
"even if g_thread_init() has not been called. Then they do nothing, apart "
"from <function>g_static_rw_lock_*_trylock</function>, which does nothing but "
"returning %TRUE."
msgstr ""

#. used by: GStaticRWLock:
#: gthread.c:2216:9
msgid ""
"<note><para>A read-write lock has a higher overhead than a mutex. For "
"example, both g_static_rw_lock_reader_lock() and "
"g_static_rw_lock_reader_unlock() have to lock and unlock a #GStaticMutex, so "
"it takes at least twice the time to lock and unlock a #GStaticRWLock that it "
"does to lock and unlock a #GStaticMutex. So only data structures that are "
"accessed by multiple readers, and which keep the lock for a considerable "
"time justify a #GStaticRWLock. The above example most probably would fare "
"better with a #GStaticMutex.</para></note>"
msgstr ""

#. used by: G_TRYLOCK:
#: gthread.c:223:1
msgid "@Returns: %TRUE, if the lock could be locked."
msgstr ""

#. used by: G_STATIC_RW_LOCK_INIT:
#: gthread.c:2230:4
msgid ""
"A #GStaticRWLock must be initialized with this macro before it can be used. "
"This macro can used be to initialize a variable, but it cannot be assigned "
"to a variable. In that case you have to use g_static_rw_lock_init()."
msgstr ""

#. used by: g_static_rw_lock_init:
#: gthread.c:2244:1
msgid "@lock: a #GStaticRWLock to be initialized."
msgstr ""

#. used by: g_static_rw_lock_init:
#: gthread.c:2246:3
msgid ""
"A #GStaticRWLock must be initialized with this function before it can be "
"used. Alternatively you can initialize it with #G_STATIC_RW_LOCK_INIT."
msgstr ""

#. used by: G_TRYLOCK:
#: gthread.c:225:2
msgid ""
"Works like g_mutex_trylock(), but for a lock defined with #G_LOCK_DEFINE."
msgstr ""

#. #-#-#-#-#  gthread.pot (PACKAGE VERSION)  #-#-#-#-#
#. used by: g_static_rw_lock_reader_lock:
#. #-#-#-#-#  gthread.pot (PACKAGE VERSION)  #-#-#-#-#
#. used by: g_static_rw_lock_reader_trylock:
#: gthread.c:2279:1 gthread.c:2312:1
msgid "@lock: a #GStaticRWLock to lock for reading."
msgstr ""

#. used by: g_static_rw_lock_reader_lock:
#: gthread.c:2281:7
msgid ""
"Locks @lock for reading. There may be unlimited concurrent locks for reading "
"of a #GStaticRWLock at the same time.  If @lock is already locked for "
"writing by another thread or if another thread is already waiting to lock "
"@lock for writing, this function will block until @lock is unlocked by the "
"other writing thread and no other writing threads want to lock @lock. This "
"lock has to be unlocked by g_static_rw_lock_reader_unlock()."
msgstr ""

#. used by: g_static_rw_lock_reader_lock:
#: gthread.c:2289:3
msgid ""
"#GStaticRWLock is not recursive. It might seem to be possible to recursively "
"lock for reading, but that can result in a deadlock, due to writer "
"preference."
msgstr ""

#. used by: g_static_rw_lock_reader_trylock:
#: gthread.c:2313:1
msgid "@Returns: %TRUE, if @lock could be locked for reading."
msgstr ""

#. used by: g_static_rw_lock_reader_trylock:
#: gthread.c:2315:5
msgid ""
"Tries to lock @lock for reading. If @lock is already locked for writing by "
"another thread or if another thread is already waiting to lock @lock for "
"writing, immediately returns %FALSE. Otherwise locks @lock for reading and "
"returns %TRUE. This lock has to be unlocked by g_static_rw_lock_reader_unlock"
"()."
msgstr ""

#. used by: G_UNLOCK:
#: gthread.c:233:2
msgid ""
"Works like g_mutex_unlock(), but for a lock defined with #G_LOCK_DEFINE."
msgstr ""

#. used by: g_static_rw_lock_reader_unlock:
#: gthread.c:2343:1
msgid "@lock: a #GStaticRWLock to unlock after reading."
msgstr ""

#. used by: g_static_rw_lock_reader_unlock:
#: gthread.c:2345:3
msgid ""
"Unlocks @lock. If a thread waits to lock @lock for writing and all locks for "
"reading have been unlocked, the waiting thread is woken up and can lock "
"@lock for writing."
msgstr ""

#. #-#-#-#-#  gthread.pot (PACKAGE VERSION)  #-#-#-#-#
#. used by: g_static_rw_lock_writer_lock:
#. #-#-#-#-#  gthread.pot (PACKAGE VERSION)  #-#-#-#-#
#. used by: g_static_rw_lock_writer_trylock:
#: gthread.c:2366:1 gthread.c:2395:1
msgid "@lock: a #GStaticRWLock to lock for writing."
msgstr ""

#. used by: g_static_rw_lock_writer_lock:
#: gthread.c:2368:7
msgid ""
"Locks @lock for writing. If @lock is already locked for writing or reading "
"by other threads, this function will block until @lock is completely "
"unlocked and then lock @lock for writing. While this functions waits to lock "
"@lock, no other thread can lock @lock for reading. When @lock is locked for "
"writing, no other thread can lock @lock (neither for reading nor writing). "
"This lock has to be unlocked by g_static_rw_lock_writer_unlock()."
msgstr ""

#. used by: g_static_rw_lock_writer_trylock:
#: gthread.c:2396:1
msgid "@Returns: %TRUE, if @lock could be locked for writing."
msgstr ""

#. used by: g_static_rw_lock_writer_trylock:
#: gthread.c:2398:4
msgid ""
"Tries to lock @lock for writing. If @lock is already locked (for either "
"reading or writing) by another thread, it immediately returns %FALSE. "
"Otherwise it locks @lock for writing and returns %TRUE. This lock has to be "
"unlocked by g_static_rw_lock_writer_unlock()."
msgstr ""

#. used by: GThreadError:
#: gthread.c:240:2
msgid ""
"@G_THREAD_ERROR_AGAIN: a thread couldn't be created due to resource "
"shortage. Try again later."
msgstr ""

#. used by: g_static_rw_lock_writer_unlock:
#: gthread.c:2425:1
msgid "@lock: a #GStaticRWLock to unlock after writing."
msgstr ""

#. used by: g_static_rw_lock_writer_unlock:
#: gthread.c:2427:6
msgid ""
"Unlocks @lock. If a thread is waiting to lock @lock for writing and all "
"locks for reading have been unlocked, the waiting thread is woken up and can "
"lock @lock for writing. If no thread is waiting to lock @lock for writing, "
"and some thread or threads are waiting to lock @lock for reading, the "
"waiting threads are woken up and can lock @lock for reading."
msgstr ""

#. used by: GThreadError:
#: gthread.c:243:1
msgid "Possible errors of thread related functions."
msgstr ""

#. used by: g_static_rw_lock_free:
#: gthread.c:2450:1
msgid "@lock: a #GStaticRWLock to be freed."
msgstr ""

#. used by: g_static_rw_lock_free:
#: gthread.c:2452:1
msgid "Releases all resources allocated to @lock."
msgstr ""

#. used by: g_static_rw_lock_free:
#: gthread.c:2454:4
msgid ""
"You don't have to call this functions for a #GStaticRWLock with an unbounded "
"lifetime, i.e. objects declared 'static', but if you have a #GStaticRWLock "
"as a member of a structure, and the structure is freed, you should also free "
"the #GStaticRWLock."
msgstr ""

#. used by: g_thread_foreach
#: gthread.c:2481:1
msgid "@thread_func: function to call for all GThread structures"
msgstr ""

#. used by: g_thread_foreach
#: gthread.c:2482:1
msgid "@user_data:   second argument to @thread_func"
msgstr ""

#. used by: g_thread_foreach
#: gthread.c:2484:6
msgid ""
"Call @thread_func on all existing #GThread structures. Note that threads may "
"decide to exit while @thread_func is running, so without intimate knowledge "
"about the lifetime of foreign threads, @thread_func shouldn't access the "
"GThread* pointer passed in as first argument. However, @thread_func will not "
"be called for threads which are known to have exited already."
msgstr ""

#. used by: G_THREAD_ERROR:
#: gthread.c:249:1
msgid "The error domain of the GLib thread subsystem."
msgstr ""

#. used by: g_thread_foreach
#: gthread.c:2491:2
msgid ""
"Due to thread lifetime checks, this function has an execution complexity "
"which is quadratic in the number of existing threads."
msgstr ""

#. used by: g_thread_foreach
#: gthread.c:2494:1
msgid "Since: 2.10"
msgstr ""

#. used by: g_thread_get_initialized
#: gthread.c:2528:1
msgid "Indicates if g_thread_init() has been called."
msgstr ""

#. used by: g_thread_get_initialized
#: gthread.c:2530:1
msgid "Returns: %TRUE if threads have been initialized."
msgstr ""

#. used by: g_thread_get_initialized
#: gthread.c:2532:1
msgid "Since: 2.20"
msgstr ""

#. used by: g_thread_supported:
#: gthread.c:289:1
msgid "@Returns: %TRUE, if the thread system is initialized."
msgstr ""

#. used by: g_thread_supported:
#: gthread.c:291:2
msgid ""
"This function returns %TRUE if the thread system is initialized, and %FALSE "
"if it is not."
msgstr ""

#. used by: g_thread_supported:
#: gthread.c:294:3
msgid ""
"<note><para>This function is actually a macro. Apart from taking the address "
"of it you can however use it as if it was a function.</para></note>"
msgstr ""

#. used by: GThreadFunctions:
#: gthread.c:310:1
msgid "@mutex_new: virtual function pointer for g_mutex_new()"
msgstr ""

#. used by: GThreadFunctions:
#: gthread.c:311:1
msgid "@mutex_lock: virtual function pointer for g_mutex_lock()"
msgstr ""

#. used by: GThreadFunctions:
#: gthread.c:312:1
msgid "@mutex_trylock: virtual function pointer for g_mutex_trylock()"
msgstr ""

#. used by: GThreadFunctions:
#: gthread.c:313:1
msgid "@mutex_unlock: virtual function pointer for g_mutex_unlock()"
msgstr ""

#. used by: GThreadFunctions:
#: gthread.c:314:1
msgid "@mutex_free: virtual function pointer for g_mutex_free()"
msgstr ""

#. used by: GThreadFunctions:
#: gthread.c:315:1
msgid "@cond_new: virtual function pointer for g_cond_new()"
msgstr ""

#. used by: GThreadFunctions:
#: gthread.c:316:1
msgid "@cond_signal: virtual function pointer for g_cond_signal()"
msgstr ""

#. used by: GThreadFunctions:
#: gthread.c:317:1
msgid "@cond_broadcast: virtual function pointer for g_cond_broadcast()"
msgstr ""

#. used by: GThreadFunctions:
#: gthread.c:318:1
msgid "@cond_wait: virtual function pointer for g_cond_wait()"
msgstr ""

#. used by: GThreadFunctions:
#: gthread.c:319:1
msgid "@cond_timed_wait: virtual function pointer for g_cond_timed_wait()"
msgstr ""

#. used by: GThreadFunctions:
#: gthread.c:320:1
msgid "@cond_free: virtual function pointer for g_cond_free()"
msgstr ""

#. used by: GThreadFunctions:
#: gthread.c:321:1
msgid "@private_new: virtual function pointer for g_private_new()"
msgstr ""

#. used by: GThreadFunctions:
#: gthread.c:322:1
msgid "@private_get: virtual function pointer for g_private_get()"
msgstr ""

#. used by: GThreadFunctions:
#: gthread.c:323:1
msgid "@private_set: virtual function pointer for g_private_set()"
msgstr ""

#. used by: GThreadFunctions:
#: gthread.c:324:1
msgid "@thread_create: virtual function pointer for g_thread_create()"
msgstr ""

#. used by: GThreadFunctions:
#: gthread.c:325:1
msgid "@thread_yield: virtual function pointer for g_thread_yield()"
msgstr ""

#. used by: GThreadFunctions:
#: gthread.c:326:1
msgid "@thread_join: virtual function pointer for g_thread_join()"
msgstr ""

#. used by: GThreadFunctions:
#: gthread.c:327:1
msgid "@thread_exit: virtual function pointer for g_thread_exit()"
msgstr ""

#. used by: GThreadFunctions:
#: gthread.c:328:2
msgid ""
"@thread_set_priority: virtual function pointer for g_thread_set_priority()"
msgstr ""

#. used by: GThreadFunctions:
#: gthread.c:330:1
msgid "@thread_self: virtual function pointer for g_thread_self()"
msgstr ""

#. used by: GThreadFunctions:
#: gthread.c:331:2
msgid ""
"@thread_equal: used internally by recursive mutex locks and by some "
"assertion checks"
msgstr ""

#. used by: GThreadFunctions:
#: gthread.c:334:5
msgid ""
"This function table is used by g_thread_init() to initialize the thread "
"system. The functions in the table are directly used by their g_* prepended "
"counterparts (described in this document).  For example, if you call "
"g_mutex_new() then mutex_new() from the table provided to g_thread_init() "
"will be called."
msgstr ""

#. used by: GThreadFunctions:
#: gthread.c:340:2
msgid ""
"<note><para>Do not use this struct unless you know what you are doing.</"
"para></note>"
msgstr ""

#. used by: GMutex:
#: gthread.c:359:3
msgid ""
"The #GMutex struct is an opaque data structure to represent a mutex (mutual "
"exclusion). It can be used to protect data against shared access. Take for "
"example the following function:"
msgstr ""

#. used by: GMutex:
#: gthread.c:363:2
msgid ""
"<example> <title>A function which will not work in a threaded environment</"
"title>"
msgstr ""

#. used by: GMutex:
#: gthread.c:381:3
msgid ""
"It is easy to see that this won't work in a multi-threaded application. "
"There current_number must be protected against shared access. A first naive "
"implementation would be:"
msgstr ""

#. used by: GMutex:
#: gthread.c:385:2
msgid "<example> <title>The wrong way to write a thread-safe function</title>"
msgstr ""

#. used by: GMutex:
#: gthread.c:406:4
msgid ""
"This looks like it would work, but there is a race condition while "
"constructing the mutex and this code cannot work reliable. Please do not use "
"such constructs in your own programs! One working solution is:"
msgstr ""

#. used by: GMutex:
#: gthread.c:411:2
msgid "<example> <title>A correct thread-safe function</title>"
msgstr ""

#. used by: GMutex:
#: gthread.c:443:1
msgid "#GStaticMutex provides a simpler and safer way of doing this."
msgstr ""

#. used by: GMutex:
#: gthread.c:445:4
msgid ""
"If you want to use a mutex, and your code should also work without calling "
"g_thread_init() first, then you can not use a #GMutex, as g_mutex_new() "
"requires that the thread system be initialized. Use a #GStaticMutex instead."
msgstr ""

#. used by: GMutex:
#: gthread.c:450:1
msgid "A #GMutex should only be accessed via the following functions."
msgstr ""

#. used by: GMutex:
#: gthread.c:452:3
msgid ""
"<note><para>All of the <function>g_mutex_*</function> functions are actually "
"macros. Apart from taking their addresses, you can however use them as if "
"they were functions.</para></note>"
msgstr ""

#. used by: g_mutex_new:
#: gthread.c:459:1
msgid "@Returns: a new #GMutex."
msgstr ""

#. used by: g_mutex_new:
#: gthread.c:461:1
msgid "Creates a new #GMutex."
msgstr ""

#. #-#-#-#-#  gthread.pot (PACKAGE VERSION)  #-#-#-#-#
#. used by: g_mutex_new:
#. #-#-#-#-#  gthread.pot (PACKAGE VERSION)  #-#-#-#-#
#. used by: g_private_new:
#: gthread.c:463:2 gthread.c:742:2
msgid ""
"<note><para>This function will abort if g_thread_init() has not been called "
"yet.</para></note>"
msgstr ""

#. #-#-#-#-#  gthread.pot (PACKAGE VERSION)  #-#-#-#-#
#. used by: g_mutex_lock:
#. #-#-#-#-#  gthread.pot (PACKAGE VERSION)  #-#-#-#-#
#. used by: g_mutex_trylock:
#. #-#-#-#-#  gthread.pot (PACKAGE VERSION)  #-#-#-#-#
#. used by: g_mutex_unlock:
#. #-#-#-#-#  gthread.pot (PACKAGE VERSION)  #-#-#-#-#
#. used by: g_mutex_free:
#: gthread.c:470:1 gthread.c:488:1 gthread.c:508:1 gthread.c:520:1
msgid "@mutex: a #GMutex."
msgstr ""

#. used by: g_mutex_lock:
#: gthread.c:472:3
msgid ""
"Locks @mutex. If @mutex is already locked by another thread, the current "
"thread will block until @mutex is unlocked by the other thread."
msgstr ""

#. #-#-#-#-#  gthread.pot (PACKAGE VERSION)  #-#-#-#-#
#. used by: g_mutex_lock:
#. #-#-#-#-#  gthread.pot (PACKAGE VERSION)  #-#-#-#-#
#. used by: g_mutex_unlock:
#. #-#-#-#-#  gthread.pot (PACKAGE VERSION)  #-#-#-#-#
#. used by: g_cond_signal:
#. #-#-#-#-#  gthread.pot (PACKAGE VERSION)  #-#-#-#-#
#. used by: g_cond_broadcast:
#: gthread.c:476:2 gthread.c:513:2 gthread.c:612:2 gthread.c:625:2
msgid ""
"This function can be used even if g_thread_init() has not yet been called, "
"and, in that case, will do nothing."
msgstr ""

#. used by: g_mutex_lock:
#: gthread.c:479:4
msgid ""
"<note><para>#GMutex is neither guaranteed to be recursive nor to be non-"
"recursive, i.e. a thread could deadlock while calling g_mutex_lock(), if it "
"already has locked @mutex. Use #GStaticRecMutex, if you need recursive "
"mutexes.</para></note>"
msgstr ""

#. used by: g_mutex_trylock:
#: gthread.c:491:3
msgid ""
"Tries to lock @mutex. If @mutex is already locked by another thread, it "
"immediately returns %FALSE. Otherwise it locks @mutex and returns %TRUE."
msgstr ""

#. #-#-#-#-#  gthread.pot (PACKAGE VERSION)  #-#-#-#-#
#. used by: g_mutex_trylock:
#. #-#-#-#-#  gthread.pot (PACKAGE VERSION)  #-#-#-#-#
#. used by: g_cond_timed_wait:
#: gthread.c:495:2 gthread.c:656:2
msgid ""
"This function can be used even if g_thread_init() has not yet been called, "
"and, in that case, will immediately return %TRUE."
msgstr ""

#. used by: g_mutex_trylock:
#: gthread.c:498:5
msgid ""
"<note><para>#GMutex is neither guaranteed to be recursive nor to be non-"
"recursive, i.e. the return value of g_mutex_trylock() could be both %FALSE "
"or %TRUE, if the current thread already has locked @mutex. Use "
"#GStaticRecMutex, if you need recursive mutexes.</para></note>"
msgstr ""

#. used by: g_mutex_unlock:
#: gthread.c:510:2
msgid ""
"Unlocks @mutex. If another thread is blocked in a g_mutex_lock() call for "
"@mutex, it will be woken and can lock @mutex itself."
msgstr ""

#. used by: g_mutex_free:
#: gthread.c:522:1
msgid "Destroys @mutex."
msgstr ""

#. used by: g_mutex_free:
#: gthread.c:524:2
msgid ""
"<note><para>Calling g_mutex_free() on a locked mutex may result in undefined "
"behaviour.</para></note>"
msgstr ""

#. used by: GCond:
#: gthread.c:534:5
msgid ""
"The #GCond struct is an opaque data structure that represents a condition. "
"Threads can block on a #GCond if they find a certain condition to be false. "
"If other threads change the state of this condition they signal the #GCond, "
"and that causes the waiting threads to be woken up."
msgstr ""

#. used by: GCond:
#: gthread.c:540:4
msgid ""
"<example> <title> Using GCond to block a thread until a condition is "
"satisfied </title>"
msgstr ""

#. used by: GCond:
#: gthread.c:575:3
msgid ""
"Whenever a thread calls <function>pop_data()</function> now, it will wait "
"until current_data is non-%NULL, i.e. until some other thread has called "
"<function>push_data()</function>."
msgstr ""

#. used by: GCond:
#: gthread.c:579:8
msgid ""
"<note><para>It is important to use the g_cond_wait() and g_cond_timed_wait() "
"functions only inside a loop which checks for the condition to be true.  It "
"is not guaranteed that the waiting thread will find the condition fulfilled "
"after it wakes up, even if the signaling thread left the condition in that "
"state: another thread may have altered the condition before the waiting "
"thread got the chance to be woken up, even if the condition itself is "
"protected by a #GMutex, like above.</para></note>"
msgstr ""

#. used by: GCond:
#: gthread.c:588:1
msgid "A #GCond should only be accessed via the following functions."
msgstr ""

#. used by: GCond:
#: gthread.c:590:3
msgid ""
"<note><para>All of the <function>g_cond_*</function> functions are actually "
"macros. Apart from taking their addresses, you can however use them as if "
"they were functions.</para></note>"
msgstr ""

#. used by: g_cond_new:
#: gthread.c:597:1
msgid "@Returns: a new #GCond."
msgstr ""

#. used by: g_cond_new:
#: gthread.c:599:2
msgid ""
"Creates a new #GCond. This function will abort, if g_thread_init() has not "
"been called yet."
msgstr ""

#. #-#-#-#-#  gthread.pot (PACKAGE VERSION)  #-#-#-#-#
#. used by: g_cond_signal:
#. #-#-#-#-#  gthread.pot (PACKAGE VERSION)  #-#-#-#-#
#. used by: g_cond_broadcast:
#. #-#-#-#-#  gthread.pot (PACKAGE VERSION)  #-#-#-#-#
#. used by: g_cond_wait:
#. #-#-#-#-#  gthread.pot (PACKAGE VERSION)  #-#-#-#-#
#. used by: g_cond_timed_wait:
#. #-#-#-#-#  gthread.pot (PACKAGE VERSION)  #-#-#-#-#
#. used by: g_cond_free:
#: gthread.c:606:1 gthread.c:619:1 gthread.c:632:1 gthread.c:645:1
#: gthread.c:666:1
msgid "@cond: a #GCond."
msgstr ""

#. used by: g_cond_signal:
#: gthread.c:608:3
msgid ""
"If threads are waiting for @cond, exactly one of them is woken up. It is "
"good practice to hold the same lock as the waiting thread while calling this "
"function, though not required."
msgstr ""

#. used by: g_cond_broadcast:
#: gthread.c:621:3
msgid ""
"If threads are waiting for @cond, all of them are woken up. It is good "
"practice to lock the same mutex as the waiting threads, while calling this "
"function, though not required."
msgstr ""

#. used by: g_cond_wait:
#: gthread.c:633:1
msgid "@mutex: a #GMutex, that is currently locked."
msgstr ""

#. used by: g_cond_wait:
#: gthread.c:635:2
msgid ""
"Waits until this thread is woken up on @cond. The @mutex is unlocked before "
"falling asleep and locked again before resuming."
msgstr ""

#. used by: g_cond_wait:
#: gthread.c:638:2
msgid ""
"This function can be used even if g_thread_init() has not yet been called, "
"and, in that case, will immediately return."
msgstr ""

#. used by: g_cond_timed_wait:
#: gthread.c:646:1
msgid "@mutex: a #GMutex that is currently locked."
msgstr ""

#. used by: g_cond_timed_wait:
#: gthread.c:647:1
msgid "@abs_time: a #GTimeVal, determining the final time."
msgstr ""

#. used by: g_cond_timed_wait:
#: gthread.c:648:1
msgid "@Returns: %TRUE if @cond was signalled, or %FALSE on timeout."
msgstr ""

#. used by: g_cond_timed_wait:
#: gthread.c:650:3
msgid ""
"Waits until this thread is woken up on @cond, but not longer than until the "
"time specified by @abs_time. The @mutex is unlocked before falling asleep "
"and locked again before resuming."
msgstr ""

#. used by: g_cond_timed_wait:
#: gthread.c:654:1
msgid "If @abs_time is %NULL, g_cond_timed_wait() acts like g_cond_wait()."
msgstr ""

#. used by: g_cond_timed_wait:
#: gthread.c:659:2
msgid ""
"To easily calculate @abs_time a combination of g_get_current_time() and "
"g_time_val_add() can be used."
msgstr ""

#. used by: g_cond_free:
#: gthread.c:668:1
msgid "Destroys the #GCond."
msgstr ""

#. used by: SECTION: threads
#: gthread.c:67:1
msgid "@title: Threads"
msgstr ""

#. used by: GPrivate:
#: gthread.c:677:7
msgid ""
"The #GPrivate struct is an opaque data structure to represent a thread "
"private data key. Threads can thereby obtain and set a pointer which is "
"private to the current thread. Take our <function>give_me_next_number(<!-- --"
">)</function> example from above.  Suppose we don't want "
"<literal>current_number</literal> to be shared between the threads, but "
"instead to be private to each thread. This can be done as follows:"
msgstr ""

#. used by: SECTION: threads
#: gthread.c:68:2
msgid ""
"@short_description: thread abstraction; including threads, different "
"mutexes, conditions and thread private data"
msgstr ""

#. used by: GPrivate:
#: gthread.c:685:2
msgid "<example> <title>Using GPrivate for per-thread data</title>"
msgstr ""

#. used by: SECTION: threads
#: gthread.c:70:1
msgid "@see_also: #GThreadPool, #GAsyncQueue"
msgstr ""

#. used by: GPrivate:
#: gthread.c:710:5
msgid ""
"Here the pointer belonging to the key <literal>current_number_key</literal> "
"is read. If it is %NULL, it has not been set yet. Then get memory for an "
"integer value, assign this memory to the pointer and write the pointer back. "
"Now we have an integer value that is private to the current thread."
msgstr ""

#. used by: GPrivate:
#: gthread.c:716:2
msgid ""
"The #GPrivate struct should only be accessed via the following functions."
msgstr ""

#. used by: GPrivate:
#: gthread.c:719:3
msgid ""
"<note><para>All of the <function>g_private_*</function> functions are "
"actually macros. Apart from taking their addresses, you can however use them "
"as if they were functions.</para></note>"
msgstr ""

#. used by: SECTION: threads
#: gthread.c:72:9
msgid ""
"Threads act almost like processes, but unlike processes all threads of one "
"process share the same memory. This is good, as it provides easy "
"communication between the involved threads via this shared memory, and it is "
"bad, because strange things (so called \"Heisenbugs\") might happen if the "
"program is not carefully designed. In particular, due to the concurrent "
"nature of threads, no assumptions on the order of execution of code running "
"in different threads can be made, unless order is explicitly forced by the "
"programmer through synchronization primitives."
msgstr ""

#. used by: g_private_new:
#: gthread.c:726:2
msgid ""
"@destructor: a function to destroy the data keyed to #GPrivate when a thread "
"ends."
msgstr ""

#. used by: g_private_new:
#: gthread.c:728:1
msgid "@Returns: a new #GPrivate."
msgstr ""

#. used by: g_private_new:
#: gthread.c:730:5
msgid ""
"Creates a new #GPrivate. If @destructor is non-%NULL, it is a pointer to a "
"destructor function. Whenever a thread ends and the corresponding pointer "
"keyed to this instance of #GPrivate is non-%NULL, the destructor is called "
"with this pointer as the argument."
msgstr ""

#. used by: g_private_new:
#: gthread.c:736:2
msgid ""
"<note><para>@destructor is used quite differently from @notify in "
"g_static_private_set().</para></note>"
msgstr ""

#. used by: g_private_new:
#: gthread.c:739:2
msgid ""
"<note><para>A #GPrivate can not be freed. Reuse it instead, if you can, to "
"avoid shortage, or use #GStaticPrivate.</para></note>"
msgstr ""

#. #-#-#-#-#  gthread.pot (PACKAGE VERSION)  #-#-#-#-#
#. used by: g_private_get:
#. #-#-#-#-#  gthread.pot (PACKAGE VERSION)  #-#-#-#-#
#. used by: g_private_set:
#: gthread.c:749:1 gthread.c:769:1
msgid "@private_key: a #GPrivate."
msgstr ""

#. used by: g_private_get:
#: gthread.c:752:3
msgid ""
"Returns the pointer keyed to @private_key for the current thread. If "
"g_private_set() hasn't been called for the current @private_key and thread "
"yet, this pointer will be %NULL."
msgstr ""

#. used by: g_private_get:
#: gthread.c:756:8
msgid ""
"This function can be used even if g_thread_init() has not yet been called, "
"and, in that case, will return the value of @private_key casted to "
"#gpointer. Note however, that private data set <emphasis>before</emphasis> "
"g_thread_init() will <emphasis>not</emphasis> be retained <emphasis>after</"
"emphasis> the call. Instead, %NULL will be returned in all threads directly "
"after g_thread_init(), regardless of any g_private_set() calls issued before "
"threading system intialization."
msgstr ""

#. used by: g_private_set:
#: gthread.c:772:1
msgid "Sets the pointer keyed to @private_key for the current thread."
msgstr ""

#. used by: g_private_set:
#: gthread.c:774:3
msgid ""
"This function can be used even if g_thread_init() has not yet been called, "
"and, in that case, will set @private_key to @data casted to #GPrivate*. See "
"g_private_get() for resulting caveats."
msgstr ""

#. used by: GThread:
#: gthread.c:784:3
msgid ""
"The #GThread struct represents a running thread. It has three public read-"
"only members, but the underlying struct is bigger, so you must not copy this "
"struct."
msgstr ""

#. used by: GThread:
#: gthread.c:788:2
msgid ""
"<note><para>Resources for a joinable thread are not fully released until "
"g_thread_join() is called for that thread.</para></note>"
msgstr ""

#. used by: GThreadFunc:
#: gthread.c:794:1
msgid "@data: data passed to the thread."
msgstr ""

#. used by: GThreadFunc:
#: gthread.c:795:2
msgid ""
"@Returns: the return value of the thread, which will be returned by "
"g_thread_join()."
msgstr ""

#. used by: GThreadFunc:
#: gthread.c:798:2
msgid ""
"Specifies the type of the @func functions passed to g_thread_create() or "
"g_thread_create_full()."
msgstr ""

#. used by: GThreadPriority:
#: gthread.c:804:1
msgid "@G_THREAD_PRIORITY_LOW: a priority lower than normal"
msgstr ""

#. used by: GThreadPriority:
#: gthread.c:805:1
msgid "@G_THREAD_PRIORITY_NORMAL: the default priority"
msgstr ""

#. used by: GThreadPriority:
#: gthread.c:806:1
msgid "@G_THREAD_PRIORITY_HIGH: a priority higher than normal"
msgstr ""

#. used by: GThreadPriority:
#: gthread.c:807:1
msgid "@G_THREAD_PRIORITY_URGENT: the highest priority"
msgstr ""

#. used by: GThreadPriority:
#: gthread.c:809:1
msgid "Specifies the priority of a thread."
msgstr ""

#. used by: SECTION: threads
#: gthread.c:82:9
msgid ""
"The aim of the thread related functions in GLib is to provide a portable "
"means for writing multi-threaded software. There are primitives for mutexes "
"to protect the access to portions of memory (#GMutex, #GStaticMutex, "
"#G_LOCK_DEFINE, #GStaticRecMutex and #GStaticRWLock). There are primitives "
"for condition variables to allow synchronization of threads (#GCond).  There "
"are primitives for thread-private data - data that every thread has a "
"private instance of (#GPrivate, #GStaticPrivate). Last but definitely not "
"least there are primitives to portably create and manage threads (#GThread)."
msgstr ""

#. used by: g_thread_create:
#: gthread.c:826:1
msgid "This function creates a new thread with the default priority."
msgstr ""

#. used by: g_thread_create:
#: gthread.c:828:3
msgid ""
"If @joinable is %TRUE, you can wait for this threads termination calling "
"g_thread_join(). Otherwise the thread will just disappear when it terminates."
msgstr ""

#. used by: g_thread_yield:
#: gthread.c:845:1
msgid "Gives way to other threads waiting to be scheduled."
msgstr ""

#. used by: g_thread_yield:
#: gthread.c:847:3
msgid ""
"This function is often used as a method to make busy wait less evil. But in "
"most cases you will encounter, there are better methods to do that. So in "
"general you shouldn't use this function."
msgstr ""

#. used by: g_thread_init:
#: gthread.c:876:2
msgid ""
"@vtable: a function table of type #GThreadFunctions, that provides the entry "
"points to the thread system to be used."
msgstr ""

#. used by: g_thread_init:
#: gthread.c:879:3
msgid ""
"If you use GLib from more than one thread, you must initialize the thread "
"system by calling g_thread_init(). Most of the time you will only have to "
"call <literal>g_thread_init (NULL)</literal>."
msgstr ""

#. used by: g_thread_init:
#: gthread.c:883:2
msgid ""
"<note><para>Do not call g_thread_init() with a non-%NULL parameter unless "
"you really know what you are doing.</para></note>"
msgstr ""

#. used by: g_thread_init:
#: gthread.c:886:3
msgid ""
"<note><para>g_thread_init() must not be called directly or indirectly as a "
"callback from GLib. Also no mutexes may be currently locked while calling "
"g_thread_init().</para></note>"
msgstr ""

#. used by: g_thread_init:
#: gthread.c:890:3
msgid ""
"<note><para>g_thread_init() changes the way in which #GTimer measures "
"elapsed time. As a consequence, timers that are running while g_thread_init"
"() is called may report unreliable times.</para></note>"
msgstr ""

#. used by: g_thread_init:
#: gthread.c:894:4
msgid ""
"Calling g_thread_init() multiple times is allowed (since version 2.24), but "
"nothing happens except for the first call. If the argument is non-%NULL on "
"such a call a warning will be printed, but otherwise the argument is ignored."
msgstr ""

#. used by: g_thread_init:
#: gthread.c:899:2
msgid ""
"If no thread system is available and @vtable is %NULL or if not all elements "
"of @vtable are non-%NULL, then g_thread_init() will abort."
msgstr ""

#. used by: g_thread_init:
#: gthread.c:902:5
msgid ""
"<note><para>To use g_thread_init() in your program, you have to link with "
"the libraries that the command <command>pkg-config --libs gthread-2.0</"
"command> outputs. This is not the case for all the other thread related "
"functions of GLib. Those can be used without having to link with the thread "
"libraries.</para></note>"
msgstr ""

#. used by: SECTION: threads
#: gthread.c:92:6
msgid ""
"The threading system is initialized with g_thread_init(), which takes an "
"optional custom thread implementation or %NULL for the default "
"implementation. If you want to call g_thread_init() with a non-%NULL "
"argument this must be done before executing any other GLib functions (except "
"g_mem_set_vtable()). This is a requirement even if no threads are in fact "
"ever created by the process."
msgstr ""

#. used by: GOnce:
#: gthread.c:960:1
msgid "@status: the status of the #GOnce"
msgstr ""

#. used by: GOnce:
#: gthread.c:961:2
msgid ""
"@retval: the value returned by the call to the function, if @status is "
"%G_ONCE_STATUS_READY"
msgstr ""

#. used by: GOnce:
#: gthread.c:964:3
msgid ""
"A #GOnce struct controls a one-time initialization function. Any one-time "
"initialization function must have its own unique #GOnce struct."
msgstr ""

#. used by: G_ONCE_INIT:
#: gthread.c:974:1
msgid "A #GOnce must be initialized with this macro before it can be used."
msgstr ""

#. used by: GOnceStatus:
#: gthread.c:987:1
msgid "@G_ONCE_STATUS_NOTCALLED: the function has not been called yet."
msgstr ""

#. used by: GOnceStatus:
#: gthread.c:988:1
msgid "@G_ONCE_STATUS_PROGRESS: the function call is currently in progress."
msgstr ""

#. used by: GOnceStatus:
#: gthread.c:989:1
msgid "@G_ONCE_STATUS_READY: the function has been called."
msgstr ""

#. used by: SECTION: threads
#: gthread.c:99:6
msgid ""
"Calling g_thread_init() with a %NULL argument is somewhat more relaxed. You "
"may call any other glib functions in the main thread before g_thread_init() "
"as long as g_thread_init() is not called from a glib callback, or with any "
"locks held. However, many libraries above glib does not support late "
"initialization of threads, so doing this should be avoided if possible."
msgstr ""

#. used by: GOnceStatus:
#: gthread.c:991:2
msgid ""
"The possible statuses of a one-time initialization function controlled by a "
"#GOnce struct."
msgstr ""

#. used by: g_once:
#: gthread.c:999:1
msgid "@once: a #GOnce structure"
msgstr ""
