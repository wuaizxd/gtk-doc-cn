<?xml version='1.0' encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN" 
               "http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd" [
]>
  <chapter id="chapter-gtype">
    <title>GLib动态类型系统</title>

      <para>
	由 Glib 类型系统操作的一个类型，比传统上所讲的 Object 类型更具一般化。
	下面查看类型系统中有关类结构和注册新类型的函数，是会对此最好的解释。
        <programlisting>
typedef struct _GTypeInfo               GTypeInfo;
struct _GTypeInfo
{
  /* interface types, classed types, instantiated types */
  guint16                class_size;
  
  GBaseInitFunc          base_init;
  GBaseFinalizeFunc      base_finalize;
  
  /* classed types, instantiated types */
  GClassInitFunc         class_init;
  GClassFinalizeFunc     class_finalize;
  gconstpointer          class_data;
  
  /* instantiated types */
  guint16                instance_size;
  guint16                n_preallocs;
  GInstanceInitFunc      instance_init;
  
  /* value handling */
  const GTypeValueTable *value_table;
};
GType g_type_register_static (GType             parent_type,
                              const gchar      *type_name,
                              const GTypeInfo  *info,
                              GTypeFlags        flags);
GType g_type_register_fundamental (GType                       type_id,
                                   const gchar                *type_name,
                                   const GTypeInfo            *info,
                                   const GTypeFundamentalInfo *finfo,
                                   GTypeFlags                  flags);
        </programlisting>
      </para>

      <para>
        <function><link linkend="g-type-register-static">g_type_register_static</link></function> 和
        <function><link linkend="g-type-register-fundamental">g_type_register_fundamental</link></function>
        这两个C函数定义在<filename>gtype.h</filename> 中，并在<filename>gtype.c</filename>
	中具体实现。
	你可以用来在程序的类型系统中注册一个新的 <link linkend="GType"><type>GType</type></link>。
	一般情况下你永远也不需要使用 <function><link linkend="g-type-register-fundamental">g_type_register_fundamental</link></function>
	（除非你是Tim Janik才会这样做），但是这次你要做，在最后一章会向你解释如何创建一个基本类型。
        <footnote>
          <para>
	    请注意，另外一个注册函数是 <function><link linkend="g-type-register-dynamic">g_type_register_dynamic</link></function>。
	    我们将不讨论这个函数，因为它与 <function>_static</function> 版本非常相似。
          </para>
        </footnote>
      </para>

      <para>
	基本类型是不需要从任何其他类型取得的最顶级的类型，相对的， 其他非基本类型是继承于其他类型的。
	在由 <function><link linkend="g-type-init">g_type_init</link></function>初始化时，类型系统不仅仅初始化它的内部数据结构，
	同时也注册一些核心类型：其中一些是基本类型，其他则是从基本类型继承的。
      </para>

      <para>
	不论是基本还是非基本类型，均由下面的定义步骤：
        <itemizedlist>
          <listitem><para>
	    类的大小：<link linkend="GTypeInfo"><type>GTypeInfo</type></link>的 class_size。
          </para></listitem>
          <listitem><para>
	    类的初始化函数（C++ 构造函数）：<link linkend="GTypeInfo"><type>GTypeInfo</type></link>的 base_init 和 class_init。
          </para></listitem>
          <listitem><para>
	    类的销毁函数（C++析构函数）：<link linkend="GTypeInfo"><type>GTypeInfo</type></link>的 base_finalize 和 class_finalize。
          </para></listitem>
          <listitem><para>
	    实例的大小（C++参数new）：<link linkend="GTypeInfo"><type>GTypeInfo</type></link>中 的 instance_size。
          </para></listitem>
          <listitem><para>
	    实例化策略（C++ 类的new operator）：<link linkend="GTypeInfo"><type>GTypeInfo</type></link>的n_preallocs。
          </para></listitem>
          <listitem><para>
	    复制函数（C++的复制操作）：<link linkend="GTypeInfo"><type>GTypeInfo</type></link>的 value_table。
          </para></listitem>
          <listitem><para>
	    类的字符标志：<link linkend="GTypeFlags"><type>GTypeFlags</type></link>。
          </para></listitem>
        </itemizedlist>
	基本类型同样可以由 <link linkend="GTypeFundamentalFlags"><type>GTypeFundamentalFlags</type></link>
	来定义，并保存在 <link linkend="GTypeFundamentalInfo"><type>GTypeFundamentalInfo</type></link>
	中。非基本类型一般传递一个 parent_type 至<function><link linkend="g-type-register-static">g_type_register_static</link></function>
	和 <function><link linkend="g-type-register-dynamic">g_type_register_dynamic</link></function> 中，然后交给父类来定义。
      </para>
      
      <sect1 id="gtype-copy">
        <title>复制函数</title>

        <para>
	  所有的 Glib 类型（基本和非基本，类化和非类化，
	  可实例化和不可实例化）的最大共同点是都可以通过单一的 
	  API 来复制或指定它们。
        </para>

        <para>
	  <link linkend="GValue"><type>GValue</type></link>结构被用作所有类型的抽象的容器，
	  它的极度简化的 API（定义在 <filename>gobject/gvalue.h</filename>）可以被使用请求
	  value_table 函数被注册当类型注册中：
	  举个例子，<function><link linkend="g-value-copy">g_value_copy</link></function> 复制了  <link linkend="GValue"><type>GValue</type></link>的内容至另一个<link linkend="GValue"><type>GValue</type></link>。
	  这与 C++ 指派它的复制操作来修改默认的按位复制 C++/C 结构是类似的。
        </para>

        <para>
		下面的代码向你展示了你是如何复制一个64位的整型，同样 <link linkend="GObject"><type>GObject</type></link>
		的实例指针也是这样（代码在<filename>sample/gtype/test.c</filename>中）：
<programlisting>
static void test_int (void)
{
  GValue a_value = {0, }; 
  GValue b_value = {0, };
  guint64 a, b;

  a = 0xdeadbeaf;

  g_value_init (&amp;a_value, G_TYPE_UINT64);
  g_value_set_uint64 (&amp;a_value, a);

  g_value_init (&amp;b_value, G_TYPE_UINT64);
  g_value_copy (&amp;a_value, &amp;b_value);

  b = g_value_get_uint64 (&amp;b_value);

  if (a == b) {
    g_print ("Yay !! 10 lines of code to copy around a uint64.\n");
  } else {
    g_print ("Are you sure this is not a Z80 ?\n");
  }
}

static void test_object (void)
{
  GObject *obj;
  GValue obj_vala = {0, };
  GValue obj_valb = {0, };
  obj = g_object_new (MAMAN_TYPE_BAR, NULL);

  g_value_init (&amp;obj_vala, MAMAN_TYPE_BAR);
  g_value_set_object (&amp;obj_vala, obj);

  g_value_init (&amp;obj_valb, G_TYPE_OBJECT);

  /* g_value_copy's semantics for G_TYPE_OBJECT types is to copy the reference.
     This function thus calls g_object_ref.
     It is interesting to note that the assignment works here because
     MAMAN_TYPE_BAR is a G_TYPE_OBJECT.
   */
  g_value_copy (&amp;obj_vala, &amp;obj_valb);

  g_object_unref (G_OBJECT (obj));
  g_object_unref (G_OBJECT (obj));
}
</programlisting>
	  上面代码的重点是关于复制指令的确切语义，并没有详细的定义复制是如何实现的。
	  复制函数的实现可能是决定请求一新块的内存，并把数据从源复制到目的。
	  或者可能是简单的增加实例的引用数和复制引用至新的 GValue。
        </para>
        
        <para>
	  value_table 用于详细说明这些定义在 <filename>gtype.h</filename> 
	  的函数的使用并彻底地描述在由 GObject 提供的API文档中，这是为什么我们不追究细节的原因。
          <programlisting>
typedef struct _GTypeValueTable         GTypeValueTable;
struct _GTypeValueTable
{
  void     (*value_init)         (GValue       *value);
  void     (*value_free)         (GValue       *value);
  void     (*value_copy)         (const GValue *src_value,
                                  GValue       *dest_value);
  /* varargs functionality (optional) */
  gpointer (*value_peek_pointer) (const GValue *value);
  gchar            *collect_format;
  gchar*   (*collect_value)      (GValue       *value,
                                  guint         n_collect_values,
                                  GTypeCValue  *collect_values,
                                  guint                collect_flags);
  gchar            *lcopy_format;
  gchar*   (*lcopy_value)        (const GValue *value,
                                  guint         n_collect_values,
                                  GTypeCValue  *collect_values,
                                  guint                collect_flags);
};
          </programlisting>
	  有趣的是，你同样不需要详细指定一个 value_table 在注册过程中，
	  因为 value_tables 一般从非基本类型的父类中继承，这意味着除非你想写一个基本类型，
	  否则你将不需要提供一个新的 value_table 因为它可以从父类继承 value_table。
        </para>
      </sect1>

      <sect1 id="gtype-conventions">
        <title>约定</title>


      <para>
	当用户在头文件中创建新类型时，有一些规范用户需要注意：
        <itemizedlist>
          <listitem><para>
	    使用 <function>object_method</function>的形式来定义函数名称：
	    例如在一个 bar 类中定义一个名为 foo 的函数，则用 <function>bar_foo</function> 。

          </para></listitem>
	    <listitem><para>使用前缀来避免与其他工程的命名空间冲突。
	    如果你的库（或应用程序）名为 <emphasis>Maman</emphasis>，
            <footnote>
              <para>
                <emphasis>Maman</emphasis>在法语中是<emphasis>妈妈</emphasis>
                或<emphasis>母亲</emphasis>的意思 - 仅此而已。
              </para>
            </footnote>
	    那么所有的函数名称前缀为<emphasis>maman_</emphasis>。
	    举例: <function>maman_object_method</function>.

          </para></listitem>
	  <listitem><para>创建一个宏命为 <function>PREFIX_TYPE_OBJECT</function>用来返回 GType 关联的对象类型。
	    比如，<emphasis>Bar</emphasis>这个类在一个以 <emphasis>maman</emphasis>前缀的库中，则使用 <function>MAMAN_TYPE_BAR</function>。
	    另有一个不成文的规定是，定义一个使用全局静态变或一个名为<function>prefix_object_get_type</function>
	    的函数来实现这个宏。我们将在后面的章节中讨论这个函数。
          </para></listitem>
	  <listitem><para>创建一个宏命名为 <function>PREFIX_OBJECT (obj)</function> 
	   来返回一个指向<type>PrefixObject</type> 类型的指针。
	   这个宏用于必要时安全地强制转换一个静态类型。
	   运行环境检查时，同样也是安全地执行动态类型。
	   在编译glib时是可以禁止动态类型检查的（参见：<link linkend="glib-building">编译glib</link>）。
	   在处理过程中禁用动态类型检查是可行的。
	   例如，我们可以创建 MAMAN_BAR(obj) 来保持先前的例子。
          </para></listitem>
	  <listitem><para>如果类型是类化的，那么创建一个命令为 <function>PREFIX_OBJECT_CLASS (klass)</function>的宏。
	  这个宏与前面那个是非常相似的：
	  它以类结构的动态类型检查来进行静态转换，并返回一个指向 <type>PrefixObjectClass</type>
	  这个类型的类结构的指针。
	  同样，例子为：<function>MAMAN_BAR_CLASS</function>。
          </para></listitem>
	  <listitem><para>创建一个宏命名为<function>PREFIX_IS_BAR (obj)</function>：
	  这个宏的返回值是 <type>gboolean</type> 类型的，用于判断输入的对象实例是否是 BAR类型的。
          </para></listitem>
	  <listitem><para>如果类型是类化的，创建一个名为 <function>PREFIX_IS_OBJECT_CLASS (klass)</function>
	  的宏，与上面的类似，返回输入的类型指针是否是 OBJECT 类型。
          </para></listitem>
	  <listitem><para>如果类型是类化的，创建一个名为<function>PREFIX_OBJECT_GET_CLASS (obj)</function>，返回一个实例所属的类的类型指针。
			  这个宏因为安全的原因，被静态和动态类型所使用，就像上面的转换宏一样。
          </para></listitem>
        </itemizedlist>
	至于这些宏的实现是非常直观的：
	一些数量的简单使用的宏由<filename>gtype.h</filename>提供。
	针对上面我们兴趣的例子，我们写了下面的代码来声明这些宏：
<programlisting>
#define MAMAN_TYPE_BAR                  (maman_bar_get_type ())
#define MAMAN_BAR(obj)                  (G_TYPE_CHECK_INSTANCE_CAST ((obj), MAMAN_TYPE_BAR, MamanBar))
#define MAMAN_BAR_CLASS(klass)          (G_TYPE_CHECK_CLASS_CAST ((klass), MAMAN_TYPE_BAR, MamanBarClass))
#define MAMAN_IS_BAR(obj)          (G_TYPE_CHECK_INSTANCE_TYPE ((obj), MAMAN_TYPE_BAR))
#define MAMAN_IS_BAR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), MAMAN_TYPE_BAR))
#define MAMAN_BAR_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), MAMAN_TYPE_BAR, MamanBarClass))
</programlisting>
        <note><simpara>这里使用<varname>klass</varname>这个名字，是因为 <varname>class</varname>已经被注册为 c++ 的关键字了。</simpara></note>
      </para>

      <para>
	下面的代码实现了<function>maman_bar_get_type</function>这个函数：
<programlisting>
GType maman_bar_get_type (void)
{
  static GType type = 0;
  if (type == 0) {
    static const GTypeInfo info = {
      /* You fill this structure. */
    };
    type = g_type_register_static (G_TYPE_OBJECT,
                                   "MamanBarType",
                                   &amp;info, 0);
  }
  return type;
}
</programlisting>
      </para>

      <para>
	如果没有特别需要，你也可以使用<function>G_DEFINE_TYPE</function> 宏：
<programlisting>
G_DEFINE_TYPE (MamanBar, maman_bar, G_TYPE_OBJECT)
</programlisting>
      </para>

      </sect1>

      <sect1 id="gtype-non-instantiable">
        <title>不可实例化和不可类化的基础类型</title>

        <para>
	  在类型系统中，许多类型是不可实例化而且没有父类的。
	  大多数这些类型是最基础的基本类型，如<emphasis>gchar</emphasis>，它由<function>g_value_types_init</function>注册（在<filename>gvaluetypes.c</filename>中）。
        </para>

        <para>
	  如果想在类型系统中注册这样一个类型，你仅仅需要用 0 来填充<link linkend="GTypeInfo"><type>GTypeInfo</type></link>结构。
          <programlisting>
  GTypeInfo info = {
    0,                                /* class_size */
    NULL,                        /* base_init */
    NULL,                        /* base_destroy */
    NULL,                        /* class_init */
    NULL,                        /* class_destroy */
    NULL,                        /* class_data */
    0,                                /* instance_size */
    0,                                /* n_preallocs */
    NULL,                        /* instance_init */
    NULL,                        /* value_table */
  };
  static const GTypeValueTable value_table = {
    value_init_long0,                /* value_init */
    NULL,                        /* value_free */
    value_copy_long0,                /* value_copy */
    NULL,                        /* value_peek_pointer */
    "i",                        /* collect_format */
    value_collect_int,        /* collect_value */
    "p",                        /* lcopy_format */
    value_lcopy_char,                /* lcopy_value */
  };
  info.value_table = &amp;value_table;
  type = g_type_register_fundamental (G_TYPE_CHAR, "gchar", &amp;info, &amp;finfo, 0);
          </programlisting>
        </para>


        <para>
	  使用不可实例的类型似乎是无用的：
	  定义一个不能实例化的类型有什么好处呢？
	  大多数这种类型与 <link linkend="GValue"><type>GValue</type></link>用作一块：
	  一个GValue由一个整型或一个字符串来初始化，
	  再被传递了一个已注册类型的 value_table 。
	  <link linkend="GValue"><type>GValue</type></link>（以基本类型延伸）最有用的时候是在与对象的属性和信号用在一块时。
        </para>

      </sect1>

      <sect1 id="gtype-instantiable-classed">
        <title>可实例化的类型：object</title>

        <para>
	  一个以类来注册，并声明为可实例化的类型常常称作<emphasis>object</emphasis>。
	  <link linkend="GObject"><type>GObject</type></link>（详见：<xref linkend="chapter-gobject"/> 中）是最有名的一个可实例化的类了，
	  其他相似的类都继承于这个基本类来进行开发，他们都基于下面所述的基本特征。
        </para>

        <para>
	  下面的例子告诉你怎样才可以在类型系统中注册这样一个基本的类:
<programlisting>
typedef struct {
  GObject parent;
  /* instance members */
  int field_a;
} MamanBar;

typedef struct {
  GObjectClass parent;
  /* class members */
  void (*do_action_public_virtual) (MamanBar *self, guint8 i);

  void (*do_action_public_pure_virtual) (MamanBar *self, guint8 i);
} MamanBarClass;

#define MAMAN_TYPE_BAR (maman_bar_get_type ())

GType 
maman_bar_get_type (void)
{
  static GType type = 0;
  if (type == 0) {
    static const GTypeInfo info = {
      sizeof (MamanBarClass),
      NULL,           /* base_init */
      NULL,           /* base_finalize */
      (GClassInitFunc) foo_class_init,
      NULL,           /* class_finalize */
      NULL,           /* class_data */
      sizeof (MamanBar),
      0,              /* n_preallocs */
      (GInstanceInitFunc) NULL /* instance_init */
    };
    type = g_type_register_static (G_TYPE_OBJECT,
                                   "BarType",
                                   &amp;info, 0);
  }
  return type;
}
</programlisting>
	  在调用<function>maman_bar_get_type</function>之前，
	  名为<emphasis>BarType</emphasis>的继承于<emphasis>G_TYPE_OBJECT</emphasis>的类将在类型系统中被注册。
        </para>

        <para>
	  每个对象必须定义为两个结构：它的类结构和它的实例结构。
	  所有的类结构的第一个成员必须是一个<link linkend="GTypeClass"><type>GTypeClass</type></link> 结构。
	  所有的实例结构的第一个成员必须是 <link linkend="GTypeInstance"><type>GTypeInstance</type></link>结构。
	  下面显示了这些来自<filename>gtype.h</filename> 的 C 类型的声明：
<programlisting>
struct _GTypeClass
{
  GType g_type;
};
struct _GTypeInstance
{
  GTypeClass *g_class;
};
</programlisting>
	  这些约束使得类型系统可以确保每个对象的实例(由指向该对象的实例结构的指针所标识) 的首字节指向该对象的类结构。
        </para>
        <para>
	  这个关系可以由下面的例子来很好的解释：让我们来看看这个继承于对象A的对象B：
<programlisting>
/* A definitions */
typedef struct {
  GTypeInstance parent;
  int field_a;
  int field_b;
} A;
typedef struct {
  GTypeClass parent_class;
  void (*method_a) (void);
  void (*method_b) (void);
} AClass;

/* B definitions. */
typedef struct {
  A parent;
  int field_c;
  int field_d;
} B;
typedef struct {
  AClass parent_class;
  void (*method_c) (void);
  void (*method_d) (void);
} BClass;
</programlisting>          
	  上述标准的C结构定义指示了这个C结构的第一个领域存储着类的结构。
        </para>

        <para>
	  多亏了这些简单的条件，所以按下面的方法来就可能取得每个对象实例的类型：
<programlisting>
B *b;
b->parent.parent.g_class->g_type
</programlisting>
	  或者，更快的：
<programlisting>
B *b;
((GTypeInstance*)b)->g_class->g_type
</programlisting>
        </para>

        <sect2 id="gtype-instantiable-classed-init-done">
          <title>初始化和销毁</title>

          <para>
	实例化这些类型可以用 <function><link linkend="g-type-create-instance">g_type_create_instance</link></function>来完成：
<programlisting>
GTypeInstance* g_type_create_instance (GType          type);
void           g_type_free_instance   (GTypeInstance *instance);
</programlisting>
            <function><link linkend="g-type-create-instance">g_type_create_instance</link></function> 
	    将查找请求的类型所关联的类型信息结构。
	    然后由用户声明的实例的大小和实例化策略（如果 n_preallocs 设置为一个非零值，
	    类型系统将会把对象的实例结构分配在内存块上，而不将依次分配每个实例）
	    将得到一个缓存来保存对象实例的结构。
          </para>

          <para>
            If this is the first instance of the object ever created, the type system must create
	    如果实例是这个对象第一次创建的，那么类型系统必须创建一个类结构：
	    它为其分配一个缓冲来保存这个对象的类结构并初始化它。
	    它先用父类的类结构覆盖（如果没有父类，它将初始化为零），
	    然后从最顶层的基本对象至最底层的对象调用 base_class_initialization 函数（<link linkend="GBaseInitFunc"><type>GBaseInitFunc</type></link>）。
	    对象的类初始化函数（<link linkend="GClassInitFunc"><type>GClassInitFunc</type></link>）被调用来完成类结构的初始化。
	    最终，这个类的接口被初始化了（我们将在后面讨论接口初始化）。
          </para>

          <para>
	    一旦类型系统有一个指向初始化的类结构的指针，
	    它设置对象的实例类指针指向对象的类结构并调用实例的初始化函数（<link linkend="GInstanceInitFunc"><type>GInstanceInitFunc</type></link>），
	    同样是从顶到底的顺序。
          </para>

          <para>
	    对象的实例的销毁非常简单，通过<function><link linkend="g-type-free-instance">g_type_free_instance</link></function>即可：
	    实例结构被返回到实例池中，如果这是对象的还有一个而且是最后一个存活的实例，那么这个类即被摧毁。
          </para>


          <para>
	    类的销毁（关于这个销毁的另一概念是 GType 的终结）的过程与初始化的刚好对称：
	    接口先被销毁。
	    然后，调用类终结函数 class_finalize（<link linkend="ClassFinalizeFunc"><type>ClassFinalizeFunc</type></link>）。
	    最终，将 base_class_finalize（<link linkend="GBaseFinalizeFunc"><type>GBaseFinalizeFunc</type></link>）
	    从底至顶的调用，直到类结构被销毁。
          </para>

          <para>
	   很多读者已经明白了，基本的初始化/终结化过程与C++的构造/析构函数非常相似。
	   实际上细节是非常不同的，千万不要被表现的相似所迷惑。
	   特别是，大多数用户开始认识到GType中并不存在类似于C++的构造器（这实际上是一个方法列表，
	   由对象实例来调用所有有继承关系的方法），它必须建立在由GType 提供的特定的设施里。
	   同样的，GType没有实例销毁机制。
	   这是用户的职责，在现存的GType代码的顶端来实现正确的销毁（见：<xref linkend="chapter-gobject"/>）。
	   举个例子，如果从A继承的对象B被实例化了，GType将只调用对象B的instance_init回调函数，
	   而C++运行环境将先调用对象A的构造器，接着再是对象B。
	   事实上，C++代码与GType的base_init和class_init回调是等同的，
	   不过C++常常是不需要这些的，因为它并不能真的在运行时创建类型。
          </para>

          <para>
	    关于实例化和终结化的处理过程可以归纳如下：
            <table id="gtype-init-fini-table">
              <title>GType Instantiation/Finalization</title>
              <tgroup cols="3">
                <colspec colwidth="*" colnum="1" align="left"/>
                <colspec colwidth="*" colnum="2" align="left"/>
                <colspec colwidth="8*" colnum="3" align="left"/>
    
                <thead>
                  <row>
                    <entry>Invocation time</entry>
                    <entry>Function Invoked</entry>
                    <entry>Function's parameters</entry>
                  </row>
                </thead>
                <tbody>
                  <row>
                    <entry morerows="2">First call to <function><link linkend="g-type-create-instance">g_type_create_instance</link></function> for target type</entry>
                    <entry>type's base_init function</entry>
                    <entry>On the inheritance tree of classes from fundamental type to target type. 
                      base_init is invoked once for each class structure.</entry>
                  </row>
                  <row>
                    <!--entry>First call to <function><link linkend="g-type-create-instance">g_type_create_instance</link></function> for target type</entry-->
                    <entry>target type's class_init function</entry>
                    <entry>On target type's class structure</entry>
                  </row>
                  <row>
                    <!--entry>First call to <function><link linkend="g-type-create-instance">g_type_create_instance</link></function> for target type</entry-->
                    <entry>interface initialization, see 
                      <xref linkend="gtype-non-instantiable-classed-init"/></entry>
                    <entry></entry>
                  </row>
                  <row>
                    <entry>Each call to <function><link linkend="g-type-create-instance">g_type_create_instance</link></function> for target type</entry>
                    <entry>target type's instance_init function</entry>
                    <entry>On object's instance</entry>
                  </row>
                  <row>
                    <entry morerows="2">Last call to <function><link linkend="g-type-free-instance">g_type_free_instance</link></function> for target type</entry>
                    <entry>interface destruction, see
                      <xref linkend="gtype-non-instantiable-classed-dest"/></entry>
                    <entry></entry>
                  </row>
                  <row>
                    <!--entry>Last call to <function><link linkend="g-type-free-instance">g_type_free_instance</link></function> for target type</entry-->
                    <entry>target type's class_finalize function</entry>
                    <entry>On target type's class structure</entry>
                  </row>
                  <row>
                    <!--entry>Last call to <function><link linkend="g-type-free-instance">g_type_free_instance</link></function> for target type</entry-->
                    <entry>type's base_finalize function</entry>
                    <entry>On the inheritance tree of classes from fundamental type to target type. 
                      base_finalize is invoked once for each class structure.</entry>
                  </row>
                </tbody>
              </tgroup>
            </table>
          </para>
          
        </sect2>

      </sect1>

      <sect1 id="gtype-non-instantiable-classed">
        <title>不可实例的类型：接口</title>

        <para>
          GType's interfaces are very similar to Java's interfaces. They allow
	  GType的接口（Interface）与Java的接口非常类似。
	  它允许描述一个通用的API，使得多个类可以粘合在一起。
	  想像一下，Hi-Fi音响设备中的暂停和播放按钮──这可以被视做一个回放接口。
	  如果你知道你要做什么，你可以用来这个接口来控制你的CD机，MP3或其他使用相同符号的东西。
	  要声明一个接口，你需要注册一个从<link linkend="GTypeInterface"><type>GTypeInterface</type></link>
	  继承的不可实例的类型。
	  下面的代码声明了这样的一个接口：
<programlisting>
#define MAMAN_TYPE_IBAZ                (maman_ibaz_get_type ())
#define MAMAN_IBAZ(obj)                (G_TYPE_CHECK_INSTANCE_CAST ((obj), MAMAN_TYPE_IBAZ, MamanIbaz))
#define MAMAN_IS_IBAZ(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), MAMAN_TYPE_IBAZ))
#define MAMAN_IBAZ_GET_INTERFACE(inst) (G_TYPE_INSTANCE_GET_INTERFACE ((inst), MAMAN_TYPE_IBAZ, MamanIbazInterface))

typedef struct _MamanIbaz MamanIbaz; /* dummy object */
typedef struct _MamanIbazInterface MamanIbazInterface;

struct _MamanIbazInterface {
  GTypeInterface parent;

  void (*do_action) (MamanIbaz *self);
};

GType maman_ibaz_get_type (void);

void maman_ibaz_do_action (MamanIbaz *self);
</programlisting>
这里用非常简单的方法来实现<function>maman_ibaz_do_action</function>这个接口函数：
<programlisting>
void maman_ibaz_do_action (MamanIbaz *self)
{
  MAMAN_IBAZ_GET_INTERFACE (self)->do_action (self);
}
</programlisting>
	 <function>maman_ibaz_get_type</function> 注册了一个从G_TYPE_INTERFACE继承的名为<emphasis>MamanIBaz</emphasis>的类型。
	 在继承树中，所有的接口必须是G_TYPE_INTERFACE的子类。
        </para>

        <para>
	  一个接口只有一个包含<link linkend="GTypeInterface"><type>GTypeInterface</type></link>的结构来定义。
	  接口的结构应该要包含一个函数指针指向这个接口的方法。
	  用类似于<function>maman_ibaz_do_action</function>的方法在每个接口方法中定义帮助函数，
	  可以使得我们直接调用接口方法，这是一个良好的风格。
        </para>

        <para>
	  一旦一个接口的类型被注册后，你必须来实现这个接口。
	  其中，命名为<function>maman_baz_get_type</function>
	  注册一个名为<type>MamanIBaz</type>的由<link linkend="GObject"><type>GObject</type></link>继承来的新的GType，
	  并在接口Interface中实现。
<programlisting>
static void maman_baz_do_action (MamanIbaz *self)
{
  g_print ("Baz implementation of IBaz interface Action.\n");
}


static void
baz_interface_init (gpointer         g_iface,
                    gpointer         iface_data)
{
  MamanIbazInterface *iface = (MamanIbazInterface *)g_iface;
  iface->do_action = maman_baz_do_action;
}

GType 
maman_baz_get_type (void)
{
  static GType type = 0;
  if (type == 0) {
    static const GTypeInfo info = {
      sizeof (MamanBazInterface),
      NULL,   /* base_init */
      NULL,   /* base_finalize */
      NULL,   /* class_init */
      NULL,   /* class_finalize */
      NULL,   /* class_data */
      sizeof (MamanBaz),
      0,      /* n_preallocs */
      NULL    /* instance_init */
    };
    static const GInterfaceInfo ibaz_info = {
      (GInterfaceInitFunc) baz_interface_init,    /* interface_init */
      NULL,               /* interface_finalize */
      NULL          /* interface_data */
    };
    type = g_type_register_static (G_TYPE_OBJECT,
                                   "MamanBazType",
                                   &amp;info, 0);
    g_type_add_interface_static (type,
                                 MAMAN_TYPE_IBAZ,
                                 &amp;ibaz_info);
  }
  return type;
}
</programlisting>
        </para>

        <para>
	  <function><link linkend="g-type-add-interface-static">g_type_add_interface_static</link></function> 记录了在类型系统中如
	  <type>FooInterface</type>来实现的接口（<function>foo_interface_get_type</function>返回<type>FooInterface</type>的类型），
	  <link linkend="GInterfaceInfo"><type>GInterfaceInfo</type></link>保存着关于接口实现的信息：
<programlisting>
struct _GInterfaceInfo
{
  GInterfaceInitFunc     interface_init;
  GInterfaceFinalizeFunc interface_finalize;
  gpointer               interface_data;
};
</programlisting>
        </para>
        <para>
        如果没有特殊的需求，你可以直接使用<function>G_DEFINE_INTERFACE</function>这个宏：
<programlisting>
G_DEFINE_INTERFACE (MamanBaz, maman_baz, G_TYPE_OBJECT)
</programlisting>
        </para>


        <sect2 id="gtype-non-instantiable-classed-init">
          <title>接口初始化</title>

          <para>
            When an instantiable classed type which registered an interface 
            implementation is created for the first time, its class structure 
            is initialized following the process
            described in <xref linkend="gtype-instantiable-classed"/>. 
            After that, the interface implementations associated with
            the type are initialized.
          </para>

          <para>
            First a memory buffer is allocated to hold the interface structure. The parent's
            interface structure is then copied over to the new interface structure (the parent
            interface is already initialized at that point). If there is no parent interface,
            the interface structure is initialized with zeros. The g_type and the g_instance_type
            fields are then initialized: g_type is set to the type of the most-derived interface
            and g_instance_type is set to the type of the most derived type which implements 
            this interface.
          </para>

          <para>
            Finally, the interface' most-derived <function>base_init</function> function and then 
            the implementation's <function>interface_init</function>
            function are invoked. It is important to understand that if there are multiple 
            implementations of an interface the <function>base_init</function> and 
            <function>interface_init</function> functions will be
            invoked once for each implementation initialized.
          </para>

          <para>
            It is thus common for base_init functions to hold a local static boolean variable
            which makes sure that the interface type is initialized only once even if there are 
            multiple implementations of the interface:
<programlisting>
static void
maman_ibaz_base_init (gpointer g_iface)
{
  static gboolean initialized = FALSE;

  if (!initialized) {
    /* create interface signals here. */
    initialized = TRUE;
  }
}
</programlisting>
          </para>

        <para>
          If you have found the stuff about interface hairy, you are right: it is hairy but
          there is not much I can do about it. What I can do is summarize what you need to know
          about interfaces:          
        </para>

          <para>
            The above process can be summarized as follows:
          <table id="ginterface-init-table">
            <title>Interface Initialization</title>
            <tgroup cols="3">
              <colspec colwidth="*" colnum="1" align="left"/>
              <colspec colwidth="*" colnum="2" align="left"/>
              <colspec colwidth="8*" colnum="3" align="left"/>
              
              <thead>
                <row>
                  <entry>Invocation time</entry>
                  <entry>Function Invoked</entry>
                  <entry>Function's parameters</entry>
                  <entry>Remark</entry>
                </row>
              </thead>
              <tbody>
                <row>
                  <entry morerows="1">First call to <function><link linkend="g-type-create-instance">g_type_create_instance</link></function> for type
                    implementing interface
                   </entry>
                  <entry>interface' base_init function</entry>
                  <entry>On interface' vtable</entry>
                  <entry>Register interface' signals here (use a local static 
                    boolean variable as described above to make sure not to register them
                    twice.).</entry>
                </row>
                <row>
                  <!--entry>First call to <function><link linkend="g-type-create-instance">g_type_create_instance</link></function> for type
                    implementing interface
                   </entry-->
                  <entry>interface' interface_init function</entry>
                  <entry>On interface' vtable</entry>
                  <entry>
                    Initialize interface' implementation. That is, initialize the interface 
                    method pointers in the interface structure to the function's implementation.
                  </entry>
                </row>
              </tbody>
            </tgroup>
          </table>
          It is highly unlikely (i.e. I do not know of <emphasis>anyone</emphasis> who actually 
          used it) you will ever need other more fancy things such as the ones described in the
          following section (<xref linkend="gtype-non-instantiable-classed-dest"/>).
        </para>
        
        </sect2>
        
        <sect2 id="gtype-non-instantiable-classed-dest">
          <title>Interface Destruction</title>

          <para>
            When the last instance of an instantiable type which registered 
            an interface implementation is destroyed, the interface's 
            implementations associated to the type are destroyed.
          </para>

          <para>
            To destroy an interface implementation, GType first calls the 
            implementation's <function>interface_finalize</function> function 
            and then the interface's most-derived 
            <function>base_finalize</function> function.
          </para>

          <para>
            Again, it is important to understand, as in 
            <xref linkend="gtype-non-instantiable-classed-init"/>,
              that both <function>interface_finalize</function> and <function>base_finalize</function>
              are invoked exactly once for the destruction of each implementation of an interface. Thus,
              if you were to use one of these functions, you would need to use a static integer variable
              which would hold the number of instances of implementations of an interface such that
              the interface's class is destroyed only once (when the integer variable reaches zero).
          </para>
          
        <para>
          The above process can be summarized as follows:
          <table id="ginterface-fini-table">
            <title>Interface Finalization</title>
            <tgroup cols="3">
              <colspec colwidth="*" colnum="1" align="left"/>
              <colspec colwidth="*" colnum="2" align="left"/>
              <colspec colwidth="8*" colnum="3" align="left"/>
              
              <thead>
                <row>
                  <entry>Invocation time</entry>
                  <entry>Function Invoked</entry>
                  <entry>Function's parameters</entry>
                </row>
              </thead>
              <tbody>
                <row>
                  <entry morerows="1">Last call to <function><link linkend="g-type-free-instance">g_type_free_instance</link></function> for type
                    implementing interface
                   </entry>
                  <entry>interface' interface_finalize function</entry>
                  <entry>On interface' vtable</entry>
                </row>
                <row>
                  <!--entry>Last call to <function><link linkend="g-type-free-instance">g_type_free_instance</link></function>for type
                    implementing interface
                   </entry-->
                  <entry>interface' base_finalize function</entry>
                  <entry>On interface' vtable</entry>
                </row>
              </tbody>
            </tgroup>
          </table>
        </para>
      </sect2>
    </sect1>
  </chapter>
