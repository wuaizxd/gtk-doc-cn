<refentry id="glib-cross-compiling" revision="8 Apr 2003">
<refmeta>
<refentrytitle>交叉编译GLib软件包</refentrytitle>
<manvolnum>3</manvolnum>
<refmiscinfo>GLib库</refmiscinfo>
</refmeta>

<refnamediv>
<refname>交叉编译GLib软件包</refname>
<refpurpose>
如何交叉编译GLib
</refpurpose>
</refnamediv>

    <refsect1 id="cross">
      <title>在不同的体系结构中编译</title>
      <para>
        编译出来的程序或库将在不同的平台或操作系统上运行时，
	这种编译过程就叫做交叉编译。
	GLib和一些常见软件包的交叉编译稍微有些不同，
	因为GLib需要隐藏不同系统之间的一些差异。
      </para>
      <para>
        下面说明一些GLib交叉编译时的特殊之处，
	一般的交叉编译信息请查看
	<application>autoconf</application> 信息页。
      </para>
      <para>
        GLib在编译和链接时会努力去尝试检测尽可能多的有关
	目标系统的信息。但是，GLib需要的一些信息不是通过
	这种方式的。这些信息通过一个"cache"文件提供给配置
	(configure)脚本或者通过设置环境变量的方式实现。
      </para>
      <para>
        作为一份示例的cache文件，用于在Linux系统上采用"MingW32"交叉
	编译可运行于Win32环境中的GLib。
	创建一个名为"win32.cache"的文件，包含以下内容：
      </para>
      <programlisting> 
glib_cv_long_long_format=I64
glib_cv_stack_grows=no
      </programlisting>
      <para>
        接着执行以下命令：
      </para>
      <programlisting>
PATH=/path/to/mingw32-compiler/bin:$PATH
chmod a-w win32.cache   # prevent configure from changing it
./configure --cache-file=win32.cache --host=mingw32
      </programlisting>
      <para>
      下面列出了cache文件的全部变量。其中一些变量通常并不需要设置。
      </para>
    </refsect1>
    <refsect1 id="cache-file-variables">
      <title>缓存文件变量</title>
      <formalpara>
        <title>glib_cv_long_long_format=[ll/q/I64]</title>
        
        <para>
	为64位整形数而使用于<function>printf()</function>和<function>scanf()</function>函数的格式化部分。
	"ll"是C99的标准，
	被'trio'库使用来编译GLib,
	如果你的<function>printf()</function>函数不能胜任的话。
	如果你正在编译使用trio的话是不需要设置的。
        </para>
      </formalpara>
      <formalpara>
        <title>glib_cv_stack_grows=[yes/no]</title>

        <para>
	堆栈是否向上或向下增长。大多数地方都需要设置为"no"，
	有几个体系结构，如PA-RISC等需要设置为"yes"。
        </para>
      </formalpara>
      <formalpara>
        <title>glib_cv_working_bcopy=[yes/no]</title>

        <para>
	<function>bcopy()</function>函数是否可以处理重叠的复制。
	如果你没有<function>memmove()</function>, 就需要设置。（可能性非常小）
	</para>
      </formalpara>
      <formalpara>
         <title>glib_cv_sane_realloc=[yes/np]</title>

         <para>  
	 是否<function>realloc()</function>函数符合ANSI C标准并能够处理第一个参数为<literal>NULL</literal>的情况。
	 默认为"yes", 你可能并不需要设定它。
	</para>
      </formalpara>
      <formalpara>
         <title>glib_cv_have_strlcpy=[yes/no]</title>

         <para>
	 是否有匹配OpenBSD的<function>strlcpy()</function>函数。
	 默认值为"no"，这是安全的，因为在这种情况下GLib使用内置的版本。
	</para>
      </formalpara>
      <formalpara>
         <title>glib_cv_va_val_copy=[yes/no]</title>
   
         <para>
	 <type>va_list</type>是否可以作为指针复制。
	 如果设置为"no"，那么<function>memcopy()</function>将被使用。
	 如果你没有<function>va_copy()</function>或<function>__va_copy()</function>会有问题。（所以，GCC不存在问题。）
	 默认为"yes"，这种情况比"no"要多一些。
	</para>
      </formalpara>
      <formalpara>
         <title>glib_cv_rtldglobal_broken=[yes/no]</title>
 
         <para>
	 是否在OSF/1 v5.0中发现存在有bug。默认为"no"。
         </para>
      </formalpara>
      <formalpara>
         <title>glib_cv_uscore=[yes/no]</title>

         <para>
            Whether an underscore needs to be prepended to symbols when
            looking them up via <function>dlsym()</function>. Only needs to 
            be set if your system uses
	    <function>dlopen()</function>/<function>dlsym()</function>.
	 </para>
      </formalpara>
      <formalpara>
         <title>ac_cv_func_posix_getpwuid_r=[yes/no]</title>

         <para>
            Whether you have a getpwuid_r function (in your C library,
	    not your thread library) that conforms to the POSIX spec.
            (Takes a 'struct passwd **' as the final argument)
         </para>
      </formalpara>
      <formalpara>
         <title>ac_cv_func_nonposix_getpwuid_r=[yes/no]</title>
 
         <para>
            Whether you have some variant of <function>getpwuid_r()</function>
            that doesn't conform to to the POSIX spec, but GLib might be able
            to use (or might segfault.) Only needs to be set if 
	    <literal>ac_cv_func_posix_getpwuid_r</literal> is not set. It's 
            safest to set this to "no".
         </para>
      </formalpara>
      <formalpara>
         <title>ac_cv_func_posix_getgrgid_r=[yes/no]</title>
 
         <para>
            Whether you have a getgrgid_r function that conforms to
            the POSIX spec.
         </para>
      </formalpara>
      <formalpara>
         <title>glib_cv_use_pid_surrogate=[yes/no]</title>

         <para>
            Whether to use a <function>setpriority()</function> on the PID of 
            the thread as a method for setting the priority of threads. This 
            only needs to be set when using POSIX threads.
         </para>
      </formalpara>
      <formalpara>
         <title>ac_cv_func_printf_unix98=[yes/no]</title>

         <para>
	是否你的<function>printf()</function>函数支持Unix98样式的<literal>%N$</literal> 位置参数。
	默认为"no"。
         </para>
      </formalpara>
      <formalpara>
         <title>ac_cv_func_vsnprintf_c99=[yes/no]</title>

         <para>
            Whether you have a <function>vsnprintf()</function> with C99 
            semantics. (C99 semantics means returning the number of bytes 
            that would have been written had the output buffer had enough 
            space.) Defaults to "no".
         </para>
      </formalpara>

    </refsect1>    

</refentry>
