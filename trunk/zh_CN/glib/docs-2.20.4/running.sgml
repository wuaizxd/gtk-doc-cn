<refentry id="glib-running" revision="17 Jan 2002">
<refmeta>
<refentrytitle>运行GLib应用程序</refentrytitle>
<manvolnum>3</manvolnum>
<refmiscinfo>GLib库</refmiscinfo>
</refmeta>

<refnamediv>
<refname>运行GLib应用程序</refname>
<refpurpose>
如何运行和调试GLib应用程序
</refpurpose>
</refnamediv>

<refsect1>
<title>运行和调试GLib应用程序</title>

<refsect2>
<title>环境变量</title>

<para> 
GLib 会检查除了像 <envar>LANG</envar>, <envar>PATH</envar> or <envar>HOME</envar> 
一样的标准环境变量之外的一小部分环境变量.
</para>

<formalpara id="G_FILENAME_ENCODING">
  <title><envar>G_FILENAME_ENCODING</envar></title>

  <para>
    这个环境变量可以被设置为逗号为分隔字符集名称的列表. 
    GLib 假设文件名编码是以此列表第一个变量指定的编码方式而不是UTF-8.
    特别标记 "@locale" 可用于指定当前语言环境的字符集编码.
  </para>
</formalpara>

<formalpara id="G_BROKEN_FILENAMES">
  <title><envar>G_BROKEN_FILENAMES</envar></title>

  <para>
    如果设置了这个环境变量,GLib 假设文件名为当前语言环境编码而不是UTF-8.  
    G_FILENAME_ENCODING 优先于 G_BROKEN_FILENAMES. 
  </para>
</formalpara>

<formalpara id="G_MESSAGES_PREFIXED">
  <title><envar>G_MESSAGES_PREFIXED</envar></title>

  <para>
    日志级别的信息的前缀应该是程序名和程序的PID.默认前缀是除了<literal>G_LOG_LEVEL_MESSAGE</literal>
    和<literal>G_LOG_LEVEL_INFO</literal>的一切.
  </para>
</formalpara>

<formalpara id="G_DEBUG">
  <title><envar>G_DEBUG</envar></title>
  <para>
    如果 GLib 已经定义了 <option>--enable-debug=yes</option>,
    这个变量可用于设置调试选, 将打印出调试信息中的各种类型.
    <variablelist>
      <varlistentry>
        <term>fatal_warnings</term>
        <listitem><para>首次调用<link linkend="g-warning">g_warning</link>()或 
	   <link linkend="g-critical">g_critical</link>()即中止程序的运行.特别地，此选项不需要GLib配置成
	   调试支持.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>fatal_criticals</term>
        <listitem><para>首次调用<link linkend="g-critical">g_critical</link>()即中止程序的运行. 此选项不需要GLib配置成
	   调试支持.</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>gc-friendly</term>
	<listitem>
		<para>
		  新分配的内存没有被直接初始化,内存释放后将被重置为0.
		  这里的要点是允许内存检查系统和使用bohem GC 类似算法
		  的程序来计算更多精确的結果.此选项比较特殊,不需要将
		  GLib配置成调试支持.
		</para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>resident-modules</term>
	<listitem>
	  <para>
	    所有由GModule加载的模块将长驻内存的.
	    这可用于在模块卸载后追踪模块的内存泄漏.
	    但也可能在模块正常卸载后隐藏代码访问时的bugs.
	    此选项比较特殊,不需要将GLib配置成调试支持.
	  </para>
        </listitem>
      </varlistentry>
      <varlistentry>
        <term>bind-now-modules</term>
	<listitem>
	  <para>
	    所有模块被GModule加载时就会绑定他们的符号,即使代码使用了
	    %G_MODULE_BIND_LAZY.
	    此选项比较特殊,不需要将GLib配置成调试支持.
	  </para>
        </listitem>
      </varlistentry>
    </variablelist>
    特殊值可以用来打开所有的调试选项.
    特殊值可以用来打印所有可用的选项.
  </para>
</formalpara>

<formalpara id="G_SLICE">
	<title><envar>G_SLICE</envar></title>
	<para>
	　该环境变量允许重新配置GSlice内存分配器.
	  <variablelist>
	    <varlistentry>
	      <term>always-malloc</term>
	      <listitem>
		<para>
		　这将导致所有通过g_slice_alloc()和g_slice_free1()操作的片分配器将
		　直接调用g_malloc()和g_free()来分配.这对于内存检查系统和使用Bohem GC
		　算法的相关程序计算更精确的結果最有帮助.　
		  它还可以连接系统malloc实现中的调试特性，比如glibc中的MALLOC_CHECK_=2,
		  然后来调试错误的片分配代码,即使<literal>debug-blocks</literal>通常是
		  更适合的调试工具.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term>debug-blocks</term>
	      <listitem>
		<para>
		  使用此选项(出现自GLib-2.13)执行额外的代码将在释放内存片时进行完整
		  性检查.无效的片地址或片大小将会被报告并导致程序停止。此选项用于调试
		  方案.特别地，客户端软件包在运行自有的测试套件时应该<emphasis>始终打开此选项</emphasis>.
		  全局片验证是为了确保存储每个分配块的大小和地址信息,并为此数据维护
		  一个全局的哈希表.因此,多线程的可扩展性被放弃,而且内存消耗增加.然而
		  生成的代码通常表现得更好,可能比同类使用外部工具检查内存的还要好.
		  在一个内存损坏的情况下,<literal>G_SLICE=always-malloc</literal>将不能进行复制,
		  但设置<literal>G_SLICE=debug-blocks</literal>将能如下面一样捕获:
		  <programlisting>
		    void *slist = g_slist_alloc(); /* void* gives up type-safety */
		    g_list_free (slist);           /* corruption: sizeof (GSList) != sizeof (GList) */
		  </programlisting>
		</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	    特殊值可以用来打开所有的调试选项.
	    特殊值可以用来打印所有可用的选项.
	</para>
</formalpara>

<formalpara id="G_RANDOM_VERSION">
  <title><envar>G_RANDOM_VERSION</envar></title>

  <para>
  　如果这个环境变量设置为 '2.0'. GLib-2.0中已经过时的伪随机播种和生成
  　算法将会替代新的算法. 只有你需要精确重现GLib-2.0生成的数字序列时才
  　使用GLib-2.0的算法.
  </para>
</formalpara> 

<formalpara id="LIBCHARSET_ALIAS_DIR">
  <title><envar>LIBCHARSET_ALIAS_DIR</envar></title>

  <para>
  　允许为<filename>charset.aliases</filename>文件指定一个非标准的位置,
    这文件通常用于字符集转换全程.默认位置是编译时指定的<replaceable>libdir</replaceable>.
  </para>
</formalpara> 

</refsect2>

<refsect2 id="setlocale">
<title>区域设置</title>

<para>
相当数量的GLib接口取决于应用程序在运行时的当前区域设置.
因此大多数使用GLib的程序应该调用<function>setlocale(LC_ALL,"")</function>
来设置当前区域.
</para>

<para>
在Windows中,C程序中有几个区域设置的概念并不是同步的.
一方面,有系统默认的ANSI代码页,由C库和Win32API来决定用什么
编码来处理文件名.(我们现在谈论的是"窄"函数处理字符指针,不是
"宽"的那种.)
</para>

<para>
另一方面,有一个C函数库的 当前区域.该字符集(代码页)并不一定像
系统默认ANSI代码页一样使用.它返回的字符集类似<function>strftime()</function>.
</para>

</refsect2>

<refsect2>
<title>陷阱与追踪</title>

<para>
<indexterm><primary>g_trap_free_size</primary></indexterm>
<indexterm><primary>g_trap_realloc_size</primary></indexterm>
<indexterm><primary>g_trap_malloc_size</primary></indexterm>
在GLib配置好<option>--enable-debugging=yes</option>
的调试中,有些包含陷阱变量的代码可被设置.这些陷阱导致代码停止检查
当前的程序状态并回溯.
</para>

<para>
当前,有下列陷阱变量存在:
<programlisting>
static volatile gulong g_trap_free_size;
static volatile gulong g_trap_realloc_size;
static volatile gulong g_trap_malloc_size;
</programlisting>
如果设置 size > 0, 其大小匹配内存块的大小的话,<link linkend="g-free">g_free</link>(),
<link linkend="g-realloc">g_realloc</link>()和 
<link linkend="g-malloc">g_malloc</link>() 将被拦截.
这只会在<literal>g_mem_set_vtable(glib_mem_profiler_table)</literal>启动时才会生效,
因为内存分析需要匹配内存块的大小.
</para>
<para>
注意,许多现代调试器支持条件断点,其实现大同小异,例如.在gdb中，你可以做
<programlisting>
break g_malloc
condition 1 n_bytes == 20
</programlisting>
来在只有g_malloc()分配20字节的时候才中断它.
</para>
</refsect2>

<refsect2>
<title>静态内存</title>

<para>
如果内存分析已在启动时通过 <literal>g_mem_set_vtable(glib_mem_profiler_table)</literal> 启动,g_mem_profile()
将输出g_malloc()的内存使用摘要.
</para>

<para>
如果GLib已经配置了选项<option>--enable-debug=yes</option>,
那么在调试器中则可以调用g_slice_debug_tree_statistics()来查看
内存片使用的细节.
</para>

</refsect2>
</refsect1>
</refentry>
