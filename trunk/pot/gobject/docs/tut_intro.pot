msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2011-04-18 23:25+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. Put one translator per line, in the form of NAME <EMAIL>, YEAR1, YEAR2
#: tut_intro.xml:0(None)
msgid "translator-credits"
msgstr ""

#: tut_intro.xml:112(para)
msgid ""
"Now, let's say we want to call the C function <function>function_foo</"
"function> from a Python program. To do this, the Python interpreter needs "
"to: <placeholder-1/>"
msgstr ""

#: tut_intro.xml:116(para)
msgid ""
"Find where the function is located. This probably means finding the binary "
"generated by the C compiler which exports this function."
msgstr ""

#: tut_intro.xml:118(para)
msgid "Load the code of the function in executable memory."
msgstr ""

#: tut_intro.xml:119(para)
msgid ""
"Convert the Python parameters to C-compatible parameters before calling the "
"function."
msgstr ""

#: tut_intro.xml:12(para)
msgid "object-oriented C-based APIs and"
msgstr ""

#: tut_intro.xml:121(para)
msgid "Call the function with the right calling convention."
msgstr ""

#: tut_intro.xml:122(para)
msgid ""
"Convert the return values of the C function to Python-compatible variables "
"to return them to the Python code."
msgstr ""

#: tut_intro.xml:127(para)
msgid ""
"The process described above is pretty complex and there are a lot of ways to "
"make it entirely automatic and transparent to C and Python programmers: "
"<placeholder-1/> The greatest advantage of the solution implemented by GType "
"is that the glue code sitting at the runtime domain boundaries is written "
"once: the figure below states this more clearly. <placeholder-2/> Currently, "
"there exist at least Python and Perl generic glue code which makes it "
"possible to use C objects written with GType directly in Python or Perl, "
"with a minimum amount of work: there is no need to generate huge amounts of "
"glue code either automatically or by hand."
msgstr ""

#: tut_intro.xml:13(para)
msgid ""
"automatic transparent API bindings to other compiled or interpreted "
"languages."
msgstr ""

#: tut_intro.xml:131(para)
msgid ""
"The first solution is to write by hand a lot of glue code, once for each "
"function exported or imported, which does the Python-to-C parameter "
"conversion and the C-to-Python return value conversion. This glue code is "
"then linked with the interpreter which allows Python programs to call Python "
"functions which delegate work to C functions."
msgstr ""

#: tut_intro.xml:135(para)
msgid ""
"Another, nicer solution is to automatically generate the glue code, once for "
"each function exported or imported, with a special compiler which reads the "
"original function signature."
msgstr ""

#: tut_intro.xml:138(para)
msgid ""
"The solution used by GLib is to use the GType library which holds at runtime "
"a description of all the objects manipulated by the programmer. This so-"
"called <emphasis>dynamic type</emphasis><placeholder-1/> library is then "
"used by special generic glue code to automatically convert function "
"parameters and function calling conventions between different runtime "
"domains."
msgstr ""

#: tut_intro.xml:141(para)
msgid ""
"There are numerous different implementations of dynamic type systems: all C+"
"+ compilers have one, Java and .NET have one too. A dynamic type system "
"allows you to get information about every instantiated object at runtime. It "
"can be implemented by a process-specific database: every new object created "
"registers the characteristics of its associated type in the type system. It "
"can also be implemented by introspection interfaces. The common point "
"between all these different type systems and implementations is that they "
"all allow you to query for object metadata at runtime."
msgstr ""

#. When image changes, this message will be marked fuzzy or untranslated for you.
#. It doesn't matter what you translate it to: it's not used at all.
#: tut_intro.xml:159(None)
msgid "@@image: 'glue.png'; md5=THIS FILE DOESN'T EXIST"
msgstr ""

#. When image changes, this message will be marked fuzzy or untranslated for you.
#. It doesn't matter what you translate it to: it's not used at all.
#: tut_intro.xml:162(None)
msgid "@@image: 'glue.jpg'; md5=THIS FILE DOESN'T EXIST"
msgstr ""

#: tut_intro.xml:172(para)
msgid ""
"Although that goal was arguably laudable, its pursuit has had a major "
"influence on the whole GType/GObject library. C programmers are likely to be "
"puzzled at the complexity of the features exposed in the following chapters "
"if they forget that the GType/GObject library was not only designed to offer "
"OO-like features to C programmers but also transparent cross-language "
"interoperability."
msgstr ""

#: tut_intro.xml:18(para)
msgid ""
"A lot of programmers are used to working with compiled-only or dynamically "
"interpreted-only languages and do not understand the challenges associated "
"with cross-language interoperability. This introduction tries to provide an "
"insight into these challenges and briefly describes the solution chosen by "
"GLib."
msgstr ""

#: tut_intro.xml:25(para)
msgid ""
"The following chapters go into greater detail into how GType and GObject "
"work and how you can use them as a C programmer. It is useful to keep in "
"mind that allowing access to C objects from other interpreted languages was "
"one of the major design goals: this can often explain the sometimes rather "
"convoluted APIs and features present in this library."
msgstr ""

#: tut_intro.xml:34(title)
msgid "Data types and programming"
msgstr ""

#: tut_intro.xml:36(para)
msgid ""
"One could say (I have seen such definitions used in some textbooks on "
"programming language theory) that a programming language is merely a way to "
"create data types and manipulate them. Most languages provide a number of "
"language-native types and a few primitives to create more complex types "
"based on these primitive types."
msgstr ""

#: tut_intro.xml:43(para)
msgid ""
"In C, the language provides types such as <emphasis>char</emphasis>, "
"<emphasis>long</emphasis>, <emphasis>pointer</emphasis>. During compilation "
"of C code, the compiler maps these language types to the compiler's target "
"architecture machine types. If you are using a C interpreter (I have never "
"seen one myself but it is possible :), the interpreter (the program which "
"interprets the source code and executes it) maps the language types to the "
"machine types of the target machine at runtime, during the program execution "
"(or just before execution if it uses a Just In Time compiler engine)."
msgstr ""

#: tut_intro.xml:52(para)
msgid ""
"Perl and Python are interpreted languages which do not really provide type "
"definitions similar to those used by C. Perl and Python programmers "
"manipulate variables and the type of the variables is decided only upon the "
"first assignment or upon the first use which forces a type on the variable. "
"The interpreter also often provides a lot of automatic conversions from one "
"type to the other. For example, in Perl, a variable which holds an integer "
"can be automatically converted to a string given the required context: "
"<placeholder-1/> Of course, it is also often possible to explicitly specify "
"conversions when the default conversions provided by the language are not "
"intuitive."
msgstr ""

#: tut_intro.xml:59(programlisting)
#, no-wrap
msgid ""
"\n"
"my $tmp = 10;\n"
"print \"this is an integer converted to a string:\" . $tmp . \"\\n\";\n"
msgstr ""

#: tut_intro.xml:6(title)
msgid "Background"
msgstr ""

#: tut_intro.xml:70(title)
msgid "Exporting a C API"
msgstr ""

#: tut_intro.xml:72(para)
msgid ""
"C APIs are defined by a set of functions and global variables which are "
"usually exported from a binary. C functions have an arbitrary number of "
"arguments and one return value. Each function is thus uniquely identified by "
"the function name and the set of C types which describe the function "
"arguments and return value. The global variables exported by the API are "
"similarly identified by their name and their type."
msgstr ""

#: tut_intro.xml:8(para)
msgid ""
"GObject, and its lower-level type system, GType, are used by GTK+ and most "
"GNOME libraries to provide: <placeholder-1/>"
msgstr ""

#: tut_intro.xml:80(para)
msgid ""
"A C API is thus merely defined by a set of names to which a set of types are "
"associated. If you know the function calling convention and the mapping of "
"the C types to the machine types used by the platform you are on, you can "
"resolve the name of each function to find where the code associated to this "
"function is located in memory, and then construct a valid argument list for "
"the function. Finally, all you have to do is trigger a call to the target C "
"function with the argument list."
msgstr ""

#: tut_intro.xml:88(para)
msgid ""
"For the sake of discussion, here is a sample C function and the associated "
"32 bit x86 assembly code generated by GCC on my Linux box: <placeholder-1/> "
"The assembly code shown above is pretty straightforward: the first "
"instruction pushes the hexadecimal value 0xa (decimal value 10) as a 32-bit "
"integer on the stack and calls <function>function_foo</function>. As you can "
"see, C function calls are implemented by gcc by native function calls (this "
"is probably the fastest implementation possible)."
msgstr ""

#: tut_intro.xml:91(programlisting)
#, no-wrap
msgid ""
"\n"
"static void function_foo (int foo)\n"
"{}\n"
"\n"
"int main (int argc, char *argv[])\n"
"{\n"
"\n"
"        function_foo (10);\n"
"\n"
"        return 0;\n"
"}\n"
"\n"
"push   $0xa\n"
"call   0x80482f4 &lt;function_foo&gt;\n"
msgstr ""
