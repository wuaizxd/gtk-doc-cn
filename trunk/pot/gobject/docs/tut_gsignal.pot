msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2011-04-18 23:25+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. Put one translator per line, in the form of NAME <EMAIL>, YEAR1, YEAR2
#: tut_gsignal.xml:0(None)
msgid "translator-credits"
msgstr ""

#: tut_gsignal.xml:102(para)
msgid ""
"<function><link linkend=\"g-cclosure-new-swap\">g_cclosure_new_swap</link></"
"function> will create a new closure which can invoke the user-provided "
"callback_func with the user-provided user_data as first parameter (instead "
"of being the last parameter as with <function><link linkend=\"g-cclosure-new"
"\">g_cclosure_new</link></function>). When the closure is finalized (second "
"stage of the destruction process), it will invoke the destroy_data function "
"if the user has supplied one."
msgstr ""

#: tut_gsignal.xml:11(para)
msgid ""
"Closures are central to the concept of asynchronous signal delivery which is "
"widely used throughout GTK+ and GNOME applications. A closure is an "
"abstraction, a generic representation of a callback. It is a small structure "
"which contains three objects: <placeholder-1/>"
msgstr ""

#: tut_gsignal.xml:112(title)
msgid "Non-C closures (for the fearless)"
msgstr ""

#: tut_gsignal.xml:114(para)
msgid ""
"As was explained above, closures hide the details of callback invocation. In "
"C, callback invocation is just like function invocation: it is a matter of "
"creating the correct stack frame for the called function and executing a "
"<emphasis>call</emphasis> assembly instruction."
msgstr ""

#: tut_gsignal.xml:121(para)
msgid ""
"C closure marshallers transform the array of GValues which represent the "
"parameters to the target function into a C-style function parameter list, "
"invoke the user-supplied C function with this new parameter list, get the "
"return value of the function, transform it into a GValue and return this "
"GValue to the marshaller caller."
msgstr ""

#: tut_gsignal.xml:128(para)
msgid ""
"The following code implements a simple marshaller in C for a C function "
"which takes an integer as first parameter and returns void. <placeholder-1/>"
msgstr ""

#: tut_gsignal.xml:131(programlisting)
#, no-wrap
msgid ""
"\n"
"g_cclosure_marshal_VOID__INT (GClosure     *closure,\n"
"                              GValue       *return_value,\n"
"                              guint         n_param_values,\n"
"                              const GValue *param_values,\n"
"                              gpointer      invocation_hint,\n"
"                              gpointer      marshal_data)\n"
"{\n"
"  typedef void (*GMarshalFunc_VOID__INT) (gpointer     data1,\n"
"                                          gint         arg_1,\n"
"                                          gpointer     data2);\n"
"  register GMarshalFunc_VOID__INT callback;\n"
"  register GCClosure *cc = (GCClosure*) closure;\n"
"  register gpointer data1, data2;\n"
"\n"
"  g_return_if_fail (n_param_values == 2);\n"
"\n"
"  data1 = g_value_peek_pointer (param_values + 0);\n"
"  data2 = closure-&gt;data;\n"
"\n"
"  callback = (GMarshalFunc_VOID__INT) (marshal_data ? marshal_data : cc-&gt;callback);\n"
"\n"
"  callback (data1,\n"
"            g_marshal_value_peek_int (param_values + 1),\n"
"            data2);\n"
"}\n"
msgstr ""

#: tut_gsignal.xml:160(para)
msgid ""
"Of course, there exist other kinds of marshallers. For example, James "
"Henstridge wrote a generic Python marshaller which is used by all Python "
"closures (a Python closure is used to have Python-based callback be invoked "
"by the closure invocation process). This Python marshaller transforms the "
"input GValue list representing the function parameters into a Python tuple "
"which is the equivalent structure in Python (you can look in "
"<function>pyg_closure_marshal</function> in <filename>pygtype.c</filename> "
"in the <emphasis>pygobject</emphasis> module in the GNOME source code "
"repository)."
msgstr ""

#: tut_gsignal.xml:17(para)
msgid ""
"a function pointer (the callback itself) whose prototype looks like: "
"<placeholder-1/>"
msgstr ""

#: tut_gsignal.xml:174(title)
msgid "Signals"
msgstr ""

#: tut_gsignal.xml:176(para)
msgid ""
"GObject's signals have nothing to do with standard UNIX signals: they "
"connect arbitrary application-specific events with any number of listeners. "
"For example, in GTK+, every user event (keystroke or mouse move) is received "
"from the X server and generates a GTK+ event under the form of a signal "
"emission on a given object instance."
msgstr ""

#: tut_gsignal.xml:18(programlisting)
#, no-wrap
msgid ""
"\n"
"return_type function_callback (... , gpointer user_data);\n"
msgstr ""

#: tut_gsignal.xml:184(para)
msgid ""
"Each signal is registered in the type system together with the type on which "
"it can be emitted: users of the type are said to <emphasis>connect</"
"emphasis> to the signal on a given type instance when they register a "
"closure to be invoked upon the signal emission. Users can also emit the "
"signal by themselves or stop the emission of the signal from within one of "
"the closures connected to the signal."
msgstr ""

#: tut_gsignal.xml:193(para)
msgid ""
"When a signal is emitted on a given type instance, all the closures "
"connected to this signal on this type instance will be invoked. All the "
"closures connected to such a signal represent callbacks whose signature "
"looks like: <placeholder-1/>"
msgstr ""

#: tut_gsignal.xml:197(programlisting)
#, no-wrap
msgid ""
"\n"
"return_type function_callback (gpointer instance, ... , gpointer user_data);\n"
msgstr ""

#: tut_gsignal.xml:203(title)
msgid "Signal registration"
msgstr ""

#: tut_gsignal.xml:205(para)
msgid ""
"To register a new signal on an existing type, we can use any of "
"<function><link linkend=\"g-signal-newv\">g_signal_newv</link></function>, "
"<function><link linkend=\"g-signal-new-valist\">g_signal_new_valist</link></"
"function> or <function><link linkend=\"g-signal-new\">g_signal_new</link></"
"function> functions: <placeholder-1/> The number of parameters to these "
"functions is a bit intimidating but they are relatively simple: "
"<placeholder-2/>"
msgstr ""

#: tut_gsignal.xml:208(programlisting)
#, no-wrap
msgid ""
"\n"
"guint g_signal_newv (const gchar        *signal_name,\n"
"                     GType               itype,\n"
"                     GSignalFlags        signal_flags,\n"
"                     GClosure           *class_closure,\n"
"                     GSignalAccumulator  accumulator,\n"
"                     gpointer            accu_data,\n"
"                     GSignalCMarshaller  c_marshaller,\n"
"                     GType               return_type,\n"
"                     guint               n_params,\n"
"                     GType              *param_types);\n"
msgstr ""

#: tut_gsignal.xml:22(para)
msgid ""
"the user_data pointer which is passed to the callback upon invocation of the "
"closure"
msgstr ""

#: tut_gsignal.xml:223(para)
msgid ""
"signal_name: is a string which can be used to uniquely identify a given "
"signal."
msgstr ""

#: tut_gsignal.xml:226(para)
msgid "itype: is the instance type on which this signal can be emitted."
msgstr ""

#: tut_gsignal.xml:229(para)
msgid ""
"signal_flags: partly defines the order in which closures which were "
"connected to the signal are invoked."
msgstr ""

#: tut_gsignal.xml:233(para)
msgid ""
"class_closure: this is the default closure for the signal: if it is not NULL "
"upon the signal emission, it will be invoked upon this emission of the "
"signal. The moment where this closure is invoked compared to other closures "
"connected to that signal depends partly on the signal_flags."
msgstr ""

#: tut_gsignal.xml:239(para)
msgid ""
"accumulator: this is a function pointer which is invoked after each closure "
"has been invoked. If it returns FALSE, signal emission is stopped. If it "
"returns TRUE, signal emission proceeds normally. It is also used to compute "
"the return value of the signal based on the return value of all the invoked "
"closures."
msgstr ""

#: tut_gsignal.xml:245(para)
msgid ""
"accumulator_data: this pointer will be passed down to each invocation of the "
"accumulator during emission."
msgstr ""

#: tut_gsignal.xml:249(para)
msgid ""
"c_marshaller: this is the default C marshaller for any closure which is "
"connected to this signal."
msgstr ""

#: tut_gsignal.xml:25(para)
msgid ""
"a function pointer which represents the destructor of the closure: whenever "
"the closure's refcount reaches zero, this function will be called before the "
"closure structure is freed."
msgstr ""

#: tut_gsignal.xml:253(para)
msgid "return_type: this is the type of the return value of the signal."
msgstr ""

#: tut_gsignal.xml:256(para)
msgid "n_params: this is the number of parameters this signal takes."
msgstr ""

#: tut_gsignal.xml:259(para)
msgid ""
"param_types: this is an array of GTypes which indicate the type of each "
"parameter of the signal. The length of this array is indicated by n_params."
msgstr ""

#: tut_gsignal.xml:266(para)
msgid ""
"As you can see from the above definition, a signal is basically a "
"description of the closures which can be connected to this signal and a "
"description of the order in which the closures connected to this signal will "
"be invoked."
msgstr ""

#: tut_gsignal.xml:275(title)
msgid "Signal connection"
msgstr ""

#: tut_gsignal.xml:277(para)
msgid ""
"If you want to connect to a signal with a closure, you have three "
"possibilities: <placeholder-1/> It is also possible to connect a different "
"kind of callback on a given signal: emission hooks are invoked whenever a "
"given signal is emitted whatever the instance on which it is emitted. "
"Emission hooks are used for example to get all mouse_clicked emissions in an "
"application to be able to emit the small mouse click sound. Emission hooks "
"are connected with <function><link linkend=\"g-signal-add-emission-hook"
"\">g_signal_add_emission_hook</link></function> and removed with "
"<function><link linkend=\"g-signal-remove-emission-hook"
"\">g_signal_remove_emission_hook</link></function>."
msgstr ""

#: tut_gsignal.xml:280(para)
msgid ""
"You can register a class closure at signal registration: this is a system-"
"wide operation. i.e.: the class_closure will be invoked during each emission "
"of a given signal on all the instances of the type which supports that "
"signal."
msgstr ""

#: tut_gsignal.xml:285(para)
msgid ""
"You can use <function><link linkend=\"g-signal-override-class-closure"
"\">g_signal_override_class_closure</link></function> which overrides the "
"class_closure of a given type. It is possible to call this function only on "
"a derived type of the type on which the signal was registered. This function "
"is of use only to language bindings."
msgstr ""

#: tut_gsignal.xml:291(para)
msgid ""
"You can register a closure with the <function><link linkend=\"g-signal-"
"connect\">g_signal_connect</link></function> family of functions. This is an "
"instance-specific operation: the closure will be invoked only during "
"emission of a given signal on a given instance."
msgstr ""

#: tut_gsignal.xml:308(title)
msgid "Signal emission"
msgstr ""

#: tut_gsignal.xml:310(para)
msgid ""
"Signal emission is done through the use of the <function><link linkend=\"g-"
"signal-emit\">g_signal_emit</link></function> family of functions. "
"<placeholder-1/><placeholder-2/>"
msgstr ""

#: tut_gsignal.xml:313(programlisting)
#, no-wrap
msgid ""
"\n"
"void g_signal_emitv (const GValue *instance_and_params,\n"
"                     guint         signal_id,\n"
"                     GQuark        detail,\n"
"                     GValue       *return_value);\n"
msgstr ""

#: tut_gsignal.xml:320(para)
msgid ""
"The instance_and_params array of GValues contains the list of input "
"parameters to the signal. The first element of the array is the instance "
"pointer on which to invoke the signal. The following elements of the array "
"contain the list of parameters to the signal."
msgstr ""

#: tut_gsignal.xml:326(para)
msgid "signal_id identifies the signal to invoke."
msgstr ""

#: tut_gsignal.xml:329(para)
msgid ""
"detail identifies the specific detail of the signal to invoke. A detail is a "
"kind of magic token/argument which is passed around during signal emission "
"and which is used by closures connected to the signal to filter out unwanted "
"signal emissions. In most cases, you can safely set this value to zero. See "
"<xref linkend=\"signal-detail\"/> for more details about this parameter."
msgstr ""

#: tut_gsignal.xml:33(para)
msgid ""
"The <link linkend=\"GClosure\"><type>GClosure</type></link> structure "
"represents the common functionality of all closure implementations: there "
"exists a different Closure implementation for each separate runtime which "
"wants to use the GObject type system. <placeholder-1/> The GObject library "
"provides a simple <link linkend=\"GCClosure\"><type>GCClosure</type></link> "
"type which is a specific implementation of closures to be used with C/C++ "
"callbacks."
msgstr ""

#: tut_gsignal.xml:336(para)
msgid ""
"return_value holds the return value of the last closure invoked during "
"emission if no accumulator was specified. If an accumulator was specified "
"during signal creation, this accumulator is used to calculate the "
"return_value as a function of the return values of all the closures invoked "
"during emission. <placeholder-1/> If no closure is invoked during emission, "
"the return_value is nonetheless initialized to zero/null."
msgstr ""

#: tut_gsignal.xml:341(para)
msgid ""
"James (again!!) gives a few non-trivial examples of accumulators: <quote> "
"For instance, you may have an accumulator that ignores NULL returns from "
"closures, and only accumulates the non-NULL ones. Another accumulator may "
"try to return the list of values returned by the closures. </quote>"
msgstr ""

#: tut_gsignal.xml:355(para)
msgid ""
"Internally, the GValue array is passed to the emission function proper, "
"<function>signal_emit_unlocked_R</function> (implemented in "
"<filename>gsignal.c</filename>). Signal emission can be decomposed in 5 "
"steps: <placeholder-1/>"
msgstr ""

#: tut_gsignal.xml:360(para)
msgid ""
"<emphasis>RUN_FIRST</emphasis>: if the G_SIGNAL_RUN_FIRST flag was used "
"during signal registration and if there exist a class_closure for this "
"signal, the class_closure is invoked. Jump to <emphasis>EMISSION_HOOK</"
"emphasis> state."
msgstr ""

#: tut_gsignal.xml:365(para)
msgid ""
"<emphasis>EMISSION_HOOK</emphasis>: if any emission hook was added to the "
"signal, they are invoked from first to last added. Accumulate return values "
"and jump to <emphasis>HANDLER_RUN_FIRST</emphasis> state."
msgstr ""

#: tut_gsignal.xml:37(para)
msgid ""
"In practice, closures sit at the boundary of language runtimes: if you are "
"writing Python code and one of your Python callbacks receives a signal from "
"a GTK+ widget, the C code in GTK+ needs to execute your Python code. The "
"closure invoked by the GTK+ object invokes the Python callback: it behaves "
"as a normal C object for GTK+ and as a normal Python object for Python code."
msgstr ""

#: tut_gsignal.xml:370(para)
msgid ""
"<emphasis>HANDLER_RUN_FIRST</emphasis>: if any closure were connected with "
"the <function><link linkend=\"g-signal-connect\">g_signal_connect</link></"
"function> family of functions, and if they are not blocked (with the "
"<function><link linkend=\"g-signal-handler-block\">g_signal_handler_block</"
"link></function> family of functions) they are run here, from first to last "
"connected. Jump to <emphasis>RUN_LAST</emphasis> state."
msgstr ""

#: tut_gsignal.xml:377(para)
msgid ""
"<emphasis>RUN_LAST</emphasis>: if the G_SIGNAL_RUN_LAST flag was set during "
"registration and if a class_closure was set, it is invoked here. Jump to "
"<emphasis>HANDLER_RUN_LAST</emphasis> state."
msgstr ""

#: tut_gsignal.xml:383(para)
msgid ""
"<emphasis>HANDLER_RUN_LAST</emphasis>: if any closure were connected with "
"the <function>g_signal_connect_after</function> family of functions, if they "
"were not invoked during HANDLER_RUN_FIRST and if they are not blocked, they "
"are run here, from first to last connected. Jump to <emphasis>RUN_CLEANUP</"
"emphasis> state."
msgstr ""

#: tut_gsignal.xml:390(para)
msgid ""
"<emphasis>RUN_CLEANUP</emphasis>: if the G_SIGNAL_RUN_CLEANUP flag was set "
"during registration and if a class_closure was set, it is invoked here. "
"Signal emission is completed here."
msgstr ""

#: tut_gsignal.xml:398(para)
msgid ""
"If, at any point during emission (except in RUN_CLEANUP state), one of the "
"closures or emission hook stops the signal emission with <function><link "
"linkend=\"g-signal-stop\">g_signal_stop</link></function>, emission jumps to "
"CLEANUP state."
msgstr ""

#: tut_gsignal.xml:404(para)
msgid ""
"If, at any point during emission, one of the closures or emission hook emits "
"the same signal on the same instance, emission is restarted from the "
"RUN_FIRST state."
msgstr ""

#: tut_gsignal.xml:410(para)
msgid ""
"The accumulator function is invoked in all states, after invocation of each "
"closure (except in EMISSION_HOOK and CLEANUP). It accumulates the closure "
"return value into the signal return value and returns TRUE or FALSE. If, at "
"any point, it does not return TRUE, emission jumps to CLEANUP state."
msgstr ""

#: tut_gsignal.xml:417(para)
msgid ""
"If no accumulator function was provided, the value returned by the last "
"handler run will be returned by <function><link linkend=\"g-signal-emit"
"\">g_signal_emit</link></function>."
msgstr ""

#: tut_gsignal.xml:426(title)
msgid "The <emphasis>detail</emphasis> argument"
msgstr ""

#: tut_gsignal.xml:428(para)
msgid ""
"All the functions related to signal emission or signal connection have a "
"parameter named the <emphasis>detail</emphasis>. Sometimes, this parameter "
"is hidden by the API but it is always there, under one form or another."
msgstr ""

#: tut_gsignal.xml:433(para)
msgid ""
"Of the three main connection functions, only one has an explicit detail "
"parameter as a <link linkend=\"GQuark\"><type>GQuark</type></"
"link><placeholder-1/>: <placeholder-2/> The two other functions hide the "
"detail parameter in the signal name identification: <placeholder-3/> Their "
"detailed_signal parameter is a string which identifies the name of the "
"signal to connect to. However, the format of this string is structured to "
"look like <emphasis>signal_name::detail_name</emphasis>. Connecting to the "
"signal named <emphasis>notify::cursor_position</emphasis> will actually "
"connect to the signal named <emphasis>notify</emphasis> with the "
"<emphasis>cursor_position</emphasis> name. Internally, the detail string is "
"transformed to a GQuark if it is present."
msgstr ""

#: tut_gsignal.xml:437(para)
msgid ""
"A GQuark is an integer which uniquely represents a string. It is possible to "
"transform back and forth between the integer and string representations with "
"the functions <function><link linkend=\"g-quark-from-string"
"\">g_quark_from_string</link></function> and <function><link linkend=\"g-"
"quark-to-string\">g_quark_to_string</link></function>."
msgstr ""

#: tut_gsignal.xml:442(programlisting)
#, no-wrap
msgid ""
"\n"
"gulong     g_signal_connect_closure_by_id          (gpointer          instance,\n"
"                           guint          signal_id,\n"
"                           GQuark          detail,\n"
"                           GClosure         *closure,\n"
"                           gboolean          after);\n"
msgstr ""

#: tut_gsignal.xml:450(programlisting)
#, no-wrap
msgid ""
"\n"
"gulong     g_signal_connect_closure          (gpointer          instance,\n"
"                           const gchar       *detailed_signal,\n"
"                           GClosure         *closure,\n"
"                           gboolean          after);\n"
"gulong     g_signal_connect_data              (gpointer          instance,\n"
"                           const gchar     *detailed_signal,\n"
"                           GCallback      c_handler,\n"
"                           gpointer          data,\n"
"                           GClosureNotify      destroy_data,\n"
"                           GConnectFlags      connect_flags);\n"
msgstr ""

#: tut_gsignal.xml:470(para)
msgid ""
"Of the four main signal emission functions, three have an explicit detail "
"parameter as a <link linkend=\"GQuark\"><type>GQuark</type></link> again: "
"<placeholder-1/> The fourth function hides it in its signal name parameter: "
"<placeholder-2/> The format of the detailed_signal parameter is exactly the "
"same as the format used by the <function><link linkend=\"g-signal-connect"
"\">g_signal_connect</link></function> functions: <emphasis>signal_name::"
"detail_name</emphasis>."
msgstr ""

#: tut_gsignal.xml:473(programlisting)
#, no-wrap
msgid ""
"\n"
"void                  g_signal_emitv        (const GValue       *instance_and_params,\n"
"                         guint               signal_id,\n"
"                         GQuark              detail,\n"
"                         GValue             *return_value);\n"
"void                  g_signal_emit_valist  (gpointer            instance,\n"
"                         guint               signal_id,\n"
"                         GQuark              detail,\n"
"                         va_list             var_args);\n"
"void                  g_signal_emit         (gpointer            instance,\n"
"                         guint               signal_id,\n"
"                         GQuark              detail,\n"
"                         ...);\n"
msgstr ""

#: tut_gsignal.xml:48(para)
msgid ""
"A <link linkend=\"GClosure\"><type>GClosure</type></link> provides simple "
"services: <placeholder-1/>"
msgstr ""

#: tut_gsignal.xml:488(programlisting)
#, no-wrap
msgid ""
"\n"
"void                  g_signal_emit_by_name (gpointer            instance,\n"
"                         const gchar        *detailed_signal,\n"
"                         ...);\n"
msgstr ""

#: tut_gsignal.xml:497(para)
msgid ""
"If a detail is provided by the user to the emission function, it is used "
"during emission to match against the closures which also provide a detail. "
"If the closures' detail does not match the detail provided by the user, they "
"will not be invoked (even though they are connected to a signal which is "
"being emitted)."
msgstr ""

#: tut_gsignal.xml:504(para)
msgid ""
"This completely optional filtering mechanism is mainly used as an "
"optimization for signals which are often emitted for many different reasons: "
"the clients can filter out which events they are interested in before the "
"closure's marshalling code runs. For example, this is used extensively by "
"the <emphasis>notify</emphasis> signal of GObject: whenever a property is "
"modified on a GObject, instead of just emitting the <emphasis>notify</"
"emphasis> signal, GObject associates as a detail to this signal emission the "
"name of the property modified. This allows clients who wish to be notified "
"of changes to only one property to filter most events before receiving them."
msgstr ""

#: tut_gsignal.xml:51(para)
msgid ""
"Invocation (<function><link linkend=\"g-closure-invoke\">g_closure_invoke</"
"link></function>): this is what closures were created for: they hide the "
"details of callback invocation from the callback invoker."
msgstr ""

#: tut_gsignal.xml:514(para)
msgid ""
"As a simple rule, users can and should set the detail parameter to zero: "
"this will disable completely this optional filtering."
msgstr ""

#: tut_gsignal.xml:56(para)
msgid ""
"Notification: the closure notifies listeners of certain events such as "
"closure invocation, closure invalidation and closure finalization. Listeners "
"can be registered with <function><link linkend=\"g-closure-add-finalize-"
"notifier\">g_closure_add_finalize_notifier</link></function> (finalization "
"notification), <function><link linkend=\"g-closure-add-invalidate-notifier"
"\">g_closure_add_invalidate_notifier</link></function> (invalidation "
"notification) and <function><link linkend=\"g-closure-add-marshal-guards"
"\">g_closure_add_marshal_guards</link></function> (invocation notification). "
"There exist symmetric deregistration functions for finalization and "
"invalidation events (<function><link linkend=\"g-closure-remove-finalize-"
"notifier\">g_closure_remove_finalize_notifier</link></function> and "
"<function><link linkend=\"g-closure-remove-invalidate-notifier"
"\">g_closure_remove_invalidate_notifier</link></function>) but not for the "
"invocation process. <placeholder-1/>"
msgstr ""

#: tut_gsignal.xml:6(title)
msgid "The GObject messaging system"
msgstr ""

#: tut_gsignal.xml:67(para)
msgid ""
"Closures are reference counted and notify listeners of their destruction in "
"a two-stage process: the invalidation notifiers are invoked before the "
"finalization notifiers."
msgstr ""

#: tut_gsignal.xml:76(title)
msgid "C Closures"
msgstr ""

#: tut_gsignal.xml:78(para)
msgid ""
"If you are using C or C++ to connect a callback to a given event, you will "
"either use simple <link linkend=\"GCClosure\"><type>GCClosure</type></link>s "
"which have a pretty minimal API or the even simpler <function><link linkend="
"\"g-signal-connect\">g_signal_connect</link></function> functions (which "
"will be presented a bit later :). <placeholder-1/>"
msgstr ""

#: tut_gsignal.xml:83(programlisting)
#, no-wrap
msgid ""
"\n"
"GClosure *g_cclosure_new             (GCallback      callback_func,\n"
"                                      gpointer       user_data,\n"
"                                      GClosureNotify destroy_data);\n"
"GClosure *g_cclosure_new_swap        (GCallback      callback_func,\n"
"                                      gpointer       user_data,\n"
"                                      GClosureNotify destroy_data);\n"
"GClosure *g_signal_type_cclosure_new (GType          itype,\n"
"                                      guint          struct_offset);\n"
msgstr ""

#: tut_gsignal.xml:9(title)
msgid "Closures"
msgstr ""

#: tut_gsignal.xml:95(para)
msgid ""
"<function><link linkend=\"g-cclosure-new\">g_cclosure_new</link></function> "
"will create a new closure which can invoke the user-provided callback_func "
"with the user-provided user_data as last parameter. When the closure is "
"finalized (second stage of the destruction process), it will invoke the "
"destroy_data function if the user has supplied one."
msgstr ""
