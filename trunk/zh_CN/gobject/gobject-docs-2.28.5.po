msgid ""
msgstr ""
"Project-Id-Version: gtk+ 3.0.8\n"
"POT-Creation-Date: 2011-04-17 23:55+0800\n"
"PO-Revision-Date: 2011-04-23 14:01+0800\n"
"Last-Translator: yetist <yetist@gmail.com>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"X-Poedit-Language: Chinese\n"
"X-Poedit-Country: CHINA\n"
"X-Poedit-SourceCharset: utf-8\n"

#. Put one translator per line, in the form of NAME <EMAIL>, YEAR1, YEAR2
#: glib-genmarshal.xml:0(None) glib-mkenums.xml:0(None)
#: gobject-docs.sgml:0(None) gobject-query.xml:0(None) tut_gobject.xml:0(None)
#: tut_gsignal.xml:0(None) tut_gtype.xml:0(None) tut_howto.xml:0(None)
#: tut_intro.xml:0(None) tut_tools.xml:0(None)
msgid "translator-credits"
msgstr "translator-credits"

#: glib-genmarshal.xml:10(refname) glib-genmarshal.xml:16(command)
#: glib-genmarshal.xml:4(refentrytitle) glib-mkenums.xml:289(refentrytitle)
msgid "glib-genmarshal"
msgstr ""

#: glib-genmarshal.xml:103(title)
msgid "Marshaller list format"
msgstr ""

#: glib-genmarshal.xml:104(para)
msgid ""
"The marshaller lists are processed line by line, a line can contain a "
"comment in the form of <placeholder-1/> or a marshaller specification of the "
"form <placeholder-2/> (up to 16 <replaceable>PTYPE</replaceable>s may be "
"present)."
msgstr ""

#: glib-genmarshal.xml:107(programlisting)
#, no-wrap
msgid ""
"\n"
"# this is a comment\n"
msgstr ""

#: glib-genmarshal.xml:11(refpurpose)
msgid "C code marshaller generation utility for GLib closures"
msgstr ""

#: glib-genmarshal.xml:111(programlisting)
#, no-wrap
msgid ""
"\n"
"<replaceable>RTYPE</replaceable>:<replaceable>PTYPE</replaceable>\n"
"<replaceable>RTYPE</replaceable>:<replaceable>PTYPE</replaceable>,<replaceable>PTYPE</replaceable>\n"
"<replaceable>RTYPE</replaceable>:<replaceable>PTYPE</replaceable>,<replaceable>PTYPE</replaceable>,<replaceable>PTYPE</replaceable>\n"
msgstr ""

#: glib-genmarshal.xml:118(para)
msgid ""
"The <replaceable>RTYPE</replaceable> part specifies the callback's return "
"type and the <replaceable>PTYPE</replaceable>s right to the colon specify "
"the callback's parameter list, except for the first and the last arguments "
"which are always pointers."
msgstr ""

#: glib-genmarshal.xml:125(title)
msgid "Parameter types"
msgstr ""

#: glib-genmarshal.xml:126(para)
msgid "Currently, the following types are supported: <placeholder-1/>"
msgstr ""

#: glib-genmarshal.xml:130(replaceable)
msgid "VOID"
msgstr ""

#: glib-genmarshal.xml:131(para)
msgid ""
"indicates no return type, or no extra parameters. If <replaceable>VOID</"
"replaceable> is used as the parameter list, no additional parameters may be "
"present."
msgstr ""

#: glib-genmarshal.xml:139(replaceable)
msgid "BOOLEAN"
msgstr ""

#: glib-genmarshal.xml:140(para)
msgid "for boolean types (gboolean)"
msgstr ""

#: glib-genmarshal.xml:146(replaceable)
msgid "CHAR"
msgstr ""

#: glib-genmarshal.xml:147(para)
msgid "for signed char types (gchar)"
msgstr ""

#: glib-genmarshal.xml:153(replaceable)
msgid "UCHAR"
msgstr ""

#: glib-genmarshal.xml:154(para)
msgid "for unsigned char types (guchar)"
msgstr ""

#: glib-genmarshal.xml:160(replaceable)
msgid "INT"
msgstr ""

#: glib-genmarshal.xml:161(para)
msgid "for signed integer types (gint)"
msgstr ""

#: glib-genmarshal.xml:167(replaceable)
msgid "UINT"
msgstr ""

#: glib-genmarshal.xml:168(para)
msgid "for unsigned integer types (guint)"
msgstr ""

#: glib-genmarshal.xml:17(arg) glib-mkenums.xml:17(arg)
#: gobject-query.xml:18(arg) gobject-query.xml:23(arg)
msgid "options"
msgstr ""

#: glib-genmarshal.xml:174(replaceable)
msgid "LONG"
msgstr ""

#: glib-genmarshal.xml:175(para)
msgid "for signed long integer types (glong)"
msgstr ""

#: glib-genmarshal.xml:18(arg) glib-mkenums.xml:18(arg)
msgid "files"
msgstr ""

#: glib-genmarshal.xml:181(replaceable)
msgid "ULONG"
msgstr ""

#: glib-genmarshal.xml:182(para)
msgid "for unsigned long integer types (gulong)"
msgstr ""

#: glib-genmarshal.xml:188(replaceable)
msgid "INT64"
msgstr ""

#: glib-genmarshal.xml:189(para)
msgid "for signed 64bit integer types (gint64)"
msgstr ""

#: glib-genmarshal.xml:195(replaceable)
msgid "UINT64"
msgstr ""

#: glib-genmarshal.xml:196(para)
msgid "for unsigned 64bit integer types (guint64)"
msgstr ""

#: glib-genmarshal.xml:202(replaceable)
msgid "ENUM"
msgstr ""

#: glib-genmarshal.xml:203(para)
msgid "for enumeration types (gint)"
msgstr ""

#: glib-genmarshal.xml:209(replaceable)
msgid "FLAGS"
msgstr ""

#: glib-genmarshal.xml:210(para)
msgid "for flag enumeration types (guint)"
msgstr ""

#: glib-genmarshal.xml:216(replaceable)
msgid "FLOAT"
msgstr ""

#: glib-genmarshal.xml:217(para)
msgid "for single-precision float types (gfloat)"
msgstr ""

#: glib-genmarshal.xml:22(title) glib-mkenums.xml:22(title)
#: gobject-query.xml:27(title)
msgid "Description"
msgstr ""

#: glib-genmarshal.xml:223(replaceable)
msgid "DOUBLE"
msgstr ""

#: glib-genmarshal.xml:224(para)
msgid "for double-precision float types (gdouble)"
msgstr ""

#: glib-genmarshal.xml:23(para)
msgid ""
"<command>glib-genmarshal</command> is a small utility that generates C code "
"marshallers for callback functions of the GClosure mechanism in the GObject "
"sublibrary of GLib. The marshaller functions have a standard signature, they "
"get passed in the invoking closure, an array of value structures holding the "
"callback function parameters and a value structure for the return value of "
"the callback. The marshaller is then responsible to call the respective C "
"code function of the closure with all the parameters on the stack and to "
"collect its return value."
msgstr ""

#: glib-genmarshal.xml:230(replaceable)
msgid "STRING"
msgstr ""

#: glib-genmarshal.xml:231(para)
msgid "for string types (gchar*)"
msgstr ""

#: glib-genmarshal.xml:237(replaceable)
msgid "BOXED"
msgstr ""

#: glib-genmarshal.xml:238(para)
msgid "for boxed (anonymous but reference counted) types (GBoxed*)"
msgstr ""

#: glib-genmarshal.xml:244(replaceable)
msgid "PARAM"
msgstr ""

#: glib-genmarshal.xml:245(para)
msgid "for GParamSpec or derived types (GParamSpec*)"
msgstr ""

#: glib-genmarshal.xml:251(replaceable)
msgid "POINTER"
msgstr ""

#: glib-genmarshal.xml:252(para)
msgid "for anonymous pointer types (gpointer)"
msgstr ""

#: glib-genmarshal.xml:258(replaceable)
msgid "OBJECT"
msgstr ""

#: glib-genmarshal.xml:259(para)
msgid "for GObject or derived types (GObject*)"
msgstr ""

#: glib-genmarshal.xml:265(replaceable)
msgid "VARIANT"
msgstr ""

#: glib-genmarshal.xml:266(para)
msgid "for GVariant types (GVariant*)"
msgstr ""

#: glib-genmarshal.xml:272(replaceable)
msgid "NONE"
msgstr ""

#: glib-genmarshal.xml:273(para)
msgid "deprecated alias for <replaceable>VOID</replaceable>"
msgstr ""

#: glib-genmarshal.xml:279(replaceable)
msgid "BOOL"
msgstr ""

#: glib-genmarshal.xml:280(para)
msgid "deprecated alias for <replaceable>BOOLEAN</replaceable>"
msgstr ""

#: glib-genmarshal.xml:288(title)
msgid "Example"
msgstr ""

#: glib-genmarshal.xml:289(para)
msgid "To generate marshallers for the following callback functions:"
msgstr ""

#: glib-genmarshal.xml:292(programlisting)
#, no-wrap
msgid ""
"\n"
"void   foo (gpointer data1,\n"
"            gpointer data2);\n"
"void   bar (gpointer data1,\n"
"            gint     param1,\n"
"            gpointer data2);\n"
"gfloat baz (gpointer data1,\n"
"            gboolean param1,\n"
"            guchar   param2,\n"
"            gpointer data2);\n"
msgstr ""

#: glib-genmarshal.xml:303(para)
msgid "The marshaller list has to look like this:"
msgstr ""

#: glib-genmarshal.xml:306(programlisting)
#, no-wrap
msgid ""
"\n"
"VOID:VOID\n"
"VOID:INT\n"
"FLOAT:BOOLEAN,UCHAR\n"
msgstr ""

#: glib-genmarshal.xml:311(para)
msgid ""
"The generated marshallers have the arguments encoded in their function name. "
"For this particular list, they are"
msgstr ""

#: glib-genmarshal.xml:315(programlisting)
#, no-wrap
msgid ""
"\n"
"g_cclosure_marshal_VOID__VOID(),\n"
"g_cclosure_marshal_VOID__INT(), \n"
"g_cclosure_marshal_FLOAT__BOOLEAN_UCHAR().\n"
msgstr ""

#: glib-genmarshal.xml:320(para)
msgid ""
"They can be used directly for GClosures or be passed in as the "
"GSignalCMarshaller c_marshaller; argument upon creation of signals:"
msgstr ""

#: glib-genmarshal.xml:324(programlisting)
#, no-wrap
msgid ""
"\n"
"GClosure *cc_foo, *cc_bar, *cc_baz;\n"
"\n"
"cc_foo = g_cclosure_new (NULL, foo, NULL);\n"
"g_closure_set_marshal (cc_foo, g_cclosure_marshal_VOID__VOID);\n"
"cc_bar = g_cclosure_new (NULL, bar, NULL);\n"
"g_closure_set_marshal (cc_bar, g_cclosure_marshal_VOID__INT);\n"
"cc_baz = g_cclosure_new (NULL, baz, NULL);\n"
"g_closure_set_marshal (cc_baz, g_cclosure_marshal_FLOAT__BOOLEAN_UCHAR);\n"
msgstr ""

#: glib-genmarshal.xml:335(title) glib-mkenums.xml:286(title)
msgid "See also"
msgstr ""

#: glib-genmarshal.xml:336(para)
msgid "<command>glib-mkenums</command>(1)"
msgstr ""

#: glib-genmarshal.xml:34(title) glib-mkenums.xml:31(title)
#: gobject-query.xml:34(title)
msgid "Invocation"
msgstr ""

#: glib-genmarshal.xml:340(title)
msgid "Bugs"
msgstr ""

#: glib-genmarshal.xml:341(para)
msgid "None known yet."
msgstr ""

#: glib-genmarshal.xml:345(title)
msgid "Author"
msgstr ""

#: glib-genmarshal.xml:346(para)
msgid ""
"<command>glib-genmarshal</command> has been written by Tim Janik "
"<email>timj@gtk.org</email>."
msgstr ""

#: glib-genmarshal.xml:349(para)
msgid "This manual page was provided by Tim Janik <email>timj@gtk.org</email>."
msgstr ""

#: glib-genmarshal.xml:35(para)
msgid ""
"<command>glib-genmarshal</command> takes a list of marshallers to generate "
"as input. The marshaller list is either read from standard input or from "
"files passed as additional arguments on the command line."
msgstr ""

#: glib-genmarshal.xml:40(title) glib-mkenums.xml:38(title)
#: gobject-query.xml:40(title)
msgid "Options"
msgstr ""

#: glib-genmarshal.xml:44(option)
msgid "--header"
msgstr ""

#: glib-genmarshal.xml:45(para)
msgid "Generate header file contents of the marshallers."
msgstr ""

#: glib-genmarshal.xml:5(manvolnum) glib-mkenums.xml:290(manvolnum)
#: glib-mkenums.xml:5(manvolnum) gobject-query.xml:5(manvolnum)
msgid "1"
msgstr ""

#: glib-genmarshal.xml:51(option)
msgid "--body"
msgstr ""

#: glib-genmarshal.xml:52(para)
msgid "Generate C code file contents of the marshallers."
msgstr ""

#: glib-genmarshal.xml:58(term)
msgid "<option>--prefix=string</option>, <option>--prefix string</option>"
msgstr ""

#: glib-genmarshal.xml:59(para)
msgid ""
"Specify marshaller prefix. The default prefix is "
"<literal>`g_cclosure_marshal'</literal>."
msgstr ""

#: glib-genmarshal.xml:6(refmiscinfo) glib-mkenums.xml:6(refmiscinfo)
#: gobject-query.xml:6(refmiscinfo)
msgid "User Commands"
msgstr ""

#: glib-genmarshal.xml:65(option)
msgid "--skip-source"
msgstr ""

#: glib-genmarshal.xml:66(para)
msgid "Skip source location remarks in generated comments."
msgstr ""

#: glib-genmarshal.xml:72(option)
msgid "--nostdinc"
msgstr ""

#: glib-genmarshal.xml:73(para)
msgid ""
"Do not use the standard marshallers of the GObject library, and skip "
"<filename>gmarshal.h</filename> include directive in generated header files."
msgstr ""

#: glib-genmarshal.xml:80(option)
msgid "--g-fatal-warnings"
msgstr ""

#: glib-genmarshal.xml:81(para)
msgid "Make warnings fatal, that is, exit immediately once a warning occurs."
msgstr ""

#: glib-genmarshal.xml:87(term) gobject-query.xml:94(term)
msgid "<option>-h</option>, <option>--help</option>"
msgstr ""

#: glib-genmarshal.xml:88(para) glib-mkenums.xml:122(para)
#: gobject-query.xml:95(para)
msgid "Print brief help and exit."
msgstr ""

#: glib-genmarshal.xml:94(term) gobject-query.xml:101(term)
msgid "<option>-v</option>, <option>--version</option>"
msgstr ""

#: glib-genmarshal.xml:95(para) glib-mkenums.xml:129(para)
#: gobject-query.xml:102(para)
msgid "Print version and exit."
msgstr ""

#: glib-mkenums.xml:10(refname) glib-mkenums.xml:16(command)
#: glib-mkenums.xml:4(refentrytitle)
msgid "glib-mkenums"
msgstr ""

#: glib-mkenums.xml:104(option)
msgid "--template"
msgstr ""

#: glib-mkenums.xml:104(replaceable)
msgid "file"
msgstr ""

#: glib-mkenums.xml:105(para)
msgid ""
"Read templates from the given file. The templates are enclosed in specially-"
"formatted C comments <placeholder-1/> where section may be <literal>file-"
"header</literal>, <literal>file-production</literal>, <literal>file-tail</"
"literal>, <literal>enumeration-production</literal>, <literal>value-header</"
"literal>, <literal>value-production</literal>, <literal>value-tail</literal> "
"or <literal>comment</literal>."
msgstr ""

#: glib-mkenums.xml:108(programlisting)
#, no-wrap
msgid ""
"\n"
"/*** BEGIN section ***/\n"
"/*** END section ***/\n"
msgstr ""

#: glib-mkenums.xml:11(refpurpose)
msgid "C language enum description generation utility"
msgstr ""

#: glib-mkenums.xml:121(option)
msgid "--help"
msgstr ""

#: glib-mkenums.xml:128(option)
msgid "--version"
msgstr ""

#: glib-mkenums.xml:137(title)
msgid "Production text substitutions"
msgstr ""

#: glib-mkenums.xml:138(para)
msgid ""
"Certain keywords enclosed in @ characters will be substituted in the emitted "
"text. For the substitution examples of the keywords below, the following "
"example enum definition is assumed: <placeholder-1/><placeholder-2/>"
msgstr ""

#: glib-mkenums.xml:142(programlisting)
#, no-wrap
msgid ""
"\n"
"typedef enum\n"
"{\n"
"  PREFIX_THE_XVALUE    = 1 &lt;&lt; 3,\n"
"  PREFIX_ANOTHER_VALUE = 1 &lt;&lt; 4\n"
"} PrefixTheXEnum;\n"
msgstr ""

#: glib-mkenums.xml:151(term)
msgid "@EnumName@"
msgstr ""

#: glib-mkenums.xml:152(para)
msgid ""
"The name of the enum currently being processed, enum names are assumed to be "
"properly namespaced and to use mixed capitalization to separate words (e.g. "
"PrefixTheXEnum)."
msgstr ""

#: glib-mkenums.xml:160(term)
msgid "@enum_name@"
msgstr ""

#: glib-mkenums.xml:161(para)
msgid ""
"The enum name with words lowercase and word-separated by underscores (e.g. "
"prefix_the_xenum)."
msgstr ""

#: glib-mkenums.xml:168(term)
msgid "@ENUMNAME@"
msgstr ""

#: glib-mkenums.xml:169(para)
msgid ""
"The enum name with words uppercase and word-separated by underscores (e.g. "
"PREFIX_THE_XENUM)."
msgstr ""

#: glib-mkenums.xml:176(term)
msgid "@ENUMSHORT@"
msgstr ""

#: glib-mkenums.xml:177(para)
msgid ""
"The enum name with words uppercase and word-separated by underscores, prefix "
"stripped (e.g. THE_XENUM)."
msgstr ""

#: glib-mkenums.xml:184(term)
msgid "@VALUENAME@"
msgstr ""

#: glib-mkenums.xml:185(para)
msgid ""
"The enum value name currently being processed with words uppercase and word-"
"separated by underscores, this is the assumed literal notation of enum "
"values in the C sources (e.g. PREFIX_THE_XVALUE)."
msgstr ""

#: glib-mkenums.xml:194(term)
msgid "@valuenick@"
msgstr ""

#: glib-mkenums.xml:195(para)
msgid ""
"A nick name for the enum value currently being processed, this is usually "
"generated by stripping common prefix words of all the enum values of the "
"current enum, the words are lowercase and underscores are substituted by a "
"minus (e.g. the-xvalue)."
msgstr ""

#: glib-mkenums.xml:204(term)
msgid "@valuenum@"
msgstr ""

#: glib-mkenums.xml:205(para)
msgid ""
"The integer value for the enum value currently being processed. This is "
"calculated by using <command>perl</command> to attempt to evaluate the "
"expression as it appears in the C source code. If evaluation fails then "
"<command>glib-mkenums</command> will exit with an error status, but this "
"only happens if <literal>@valuenum@</literal> appears in your value "
"production template. (Since: 2.26)"
msgstr ""

#: glib-mkenums.xml:216(term)
msgid "@type@"
msgstr ""

#: glib-mkenums.xml:217(para)
msgid ""
"This is substituted either by \"enum\" or \"flags\", depending on whether "
"the enum value definitions contained bit-shift operators or not (e.g. flags)."
msgstr ""

#: glib-mkenums.xml:224(term)
msgid "@Type@"
msgstr ""

#: glib-mkenums.xml:225(para)
msgid ""
"The same as <literal>@type@</literal> with the first letter capitalized (e."
"g. Flags)."
msgstr ""

#: glib-mkenums.xml:23(para)
msgid ""
"<command>glib-mkenums</command> is a small perl-script utility that parses C "
"code to extract enum definitions and produces enum descriptions based on "
"text templates specified by the user. Most frequently this script is used to "
"produce C code that contains enum values as strings so programs can provide "
"value name strings for introspection."
msgstr ""

#: glib-mkenums.xml:231(term)
msgid "@TYPE@"
msgstr ""

#: glib-mkenums.xml:232(para)
msgid ""
"The same as <literal>@type@</literal> with all letters uppercased (e.g. "
"FLAGS)."
msgstr ""

#: glib-mkenums.xml:238(term)
msgid "@filename@"
msgstr ""

#: glib-mkenums.xml:239(para)
msgid "The name of the input file currently being processed (e.g. foo.h)."
msgstr ""

#: glib-mkenums.xml:245(term)
msgid "@basename@"
msgstr ""

#: glib-mkenums.xml:246(para)
msgid ""
"The base name of the input file currently being processed (e.g. foo.h). "
"(Since: 2.22)"
msgstr ""

#: glib-mkenums.xml:253(title)
msgid "Trigraph extensions"
msgstr ""

#: glib-mkenums.xml:254(para)
msgid ""
"Some C comments are treated specially in the parsed enum definitions, such "
"comments start out with the trigraph sequence <literal>/*&lt;</literal> and "
"end with the trigraph sequence <literal>&gt;*/</literal>. Per enum "
"definition, the options \"skip\" and \"flags\" can be specified, to indicate "
"this enum definition to be skipped, or for it to be treated as a flags "
"definition, or to specify the common prefix to be stripped from all values "
"to generate value nicknames, respectively. The \"lowercase_name\" option can "
"be used to specify the word separation used in the *_get_type() function. "
"For instance, /*&lt; lowercase_name=gnome_vfs_uri_hide_options &gt;*/."
msgstr ""

#: glib-mkenums.xml:265(para)
msgid ""
"Per value definition, the options \"skip\" and \"nick\" are supported. The "
"former causes the value to be skipped, and the latter can be used to specify "
"the otherwise auto-generated nickname. Examples: <placeholder-1/>"
msgstr ""

#: glib-mkenums.xml:270(programlisting)
#, no-wrap
msgid ""
"\n"
"typedef enum /*&lt; skip &gt;*/\n"
"{\n"
"  PREFIX_FOO\n"
"} PrefixThisEnumWillBeSkipped;\n"
"typedef enum /*&lt; flags,prefix=PREFIX &gt;*/\n"
"{\n"
"  PREFIX_THE_ZEROTH_VALUE,\t/*&lt; skip &gt;*/\n"
"  PREFIX_THE_FIRST_VALUE,\n"
"  PREFIX_THE_SECOND_VALUE,\n"
"  PREFIX_THE_THIRD_VALUE,\t/*&lt; nick=the-last-value &gt;*/\n"
"} PrefixTheFlagsEnum;\n"
msgstr ""

#: glib-mkenums.xml:32(para)
msgid ""
"<command>glib-mkenums</command> takes a list of valid C code files as input. "
"The options specified control the text that is output, certain substitutions "
"are performed on the text templates for keywords enclosed in @ characters."
msgstr ""

#: glib-mkenums.xml:42(option)
msgid "--fhead"
msgstr ""

#: glib-mkenums.xml:42(replaceable) glib-mkenums.xml:49(replaceable)
#: glib-mkenums.xml:57(replaceable) glib-mkenums.xml:65(replaceable)
#: glib-mkenums.xml:73(replaceable) glib-mkenums.xml:81(replaceable)
#: glib-mkenums.xml:88(replaceable) glib-mkenums.xml:96(replaceable)
msgid "text"
msgstr ""

#: glib-mkenums.xml:43(para)
msgid ""
"Put out <replaceable>text</replaceable> prior to processing input files."
msgstr ""

#: glib-mkenums.xml:49(option)
msgid "--fprod"
msgstr ""

#: glib-mkenums.xml:50(para)
msgid ""
"Put out <replaceable>text</replaceable> everytime a new input file is being "
"processed."
msgstr ""

#: glib-mkenums.xml:57(option)
msgid "--ftail"
msgstr ""

#: glib-mkenums.xml:58(para)
msgid ""
"Put out <replaceable>text</replaceable> after all input files have been "
"processed."
msgstr ""

#: glib-mkenums.xml:65(option)
msgid "--eprod"
msgstr ""

#: glib-mkenums.xml:66(para)
msgid ""
"Put out <replaceable>text</replaceable> everytime an enum is encountered in "
"the input files."
msgstr ""

#: glib-mkenums.xml:73(option)
msgid "--vhead"
msgstr ""

#: glib-mkenums.xml:74(para)
msgid ""
"Put out <replaceable>text</replaceable> before iterating over the set of "
"values of an enum."
msgstr ""

#: glib-mkenums.xml:81(option)
msgid "--vprod"
msgstr ""

#: glib-mkenums.xml:82(para)
msgid "Put out <replaceable>text</replaceable> for every value of an enum."
msgstr ""

#: glib-mkenums.xml:88(option)
msgid "--vtail"
msgstr ""

#: glib-mkenums.xml:89(para)
msgid ""
"Put out <replaceable>text</replaceable> after iterating over all values of "
"an enum."
msgstr ""

#: glib-mkenums.xml:96(option)
msgid "--comments"
msgstr ""

#: glib-mkenums.xml:97(para)
msgid ""
"Template for auto-generated comments, the default (for C code generations) "
"is <literal>\"/* @comment@ */\"</literal>."
msgstr ""

#: gobject-docs.sgml:10(title)
msgid "GObject Reference Manual"
msgstr "GObject 参考手册"

#: gobject-docs.sgml:100(title)
msgid "Index"
msgstr "索引"

#: gobject-docs.sgml:104(title)
msgid "Index of deprecated symbols"
msgstr "已过时符号索引"

#: gobject-docs.sgml:108(title)
msgid "Index of new symbols in 2.2"
msgstr "2.2版本中的新符号索引"

#: gobject-docs.sgml:11(releaseinfo)
msgid ""
"for GObject 2.28.5 The latest version of this documentation can be found on-"
"line at <ulink role=\"online-location\" url=\"http://library.gnome.org/devel/"
"gobject/unstable/\">http://library.gnome.org/devel/gobject/unstable/</ulink>."
msgstr ""
"GObject 当前版本为2.28.5, 最新在线版本请浏览这里<ulink role=\"online-location"
"\" url=\"http://library.gnome.org/devel/gobject/unstable/\">http://library."
"gnome.org/devel/gobject/unstable/</ulink>."

#: gobject-docs.sgml:112(title)
msgid "Index of new symbols in 2.4"
msgstr "2.4版本中的新符号索引"

#: gobject-docs.sgml:116(title)
msgid "Index of new symbols in 2.6"
msgstr "2.6版本中的新符号索引"

#: gobject-docs.sgml:120(title)
msgid "Index of new symbols in 2.8"
msgstr "2.8版本中的新符号索引"

#: gobject-docs.sgml:124(title)
msgid "Index of new symbols in 2.10"
msgstr "2.10版本中的新符号索引"

#: gobject-docs.sgml:128(title)
msgid "Index of new symbols in 2.12"
msgstr "2.12版本中的新符号索引"

#: gobject-docs.sgml:132(title)
msgid "Index of new symbols in 2.14"
msgstr "2.14版本中的新符号索引"

#: gobject-docs.sgml:136(title)
msgid "Index of new symbols in 2.18"
msgstr "2.18版本中的新符号索引"

#: gobject-docs.sgml:140(title)
msgid "Index of new symbols in 2.22"
msgstr "2.22版本中的新符号索引"

#: gobject-docs.sgml:144(title)
msgid "Index of new symbols in 2.24"
msgstr "2.24版本中的新符号索引"

#: gobject-docs.sgml:148(title)
msgid "Index of new symbols in 2.26"
msgstr "2.26版本中的新符号索引"

#: gobject-docs.sgml:152(title)
msgid "Index of new symbols in 2.28"
msgstr "2.28版本中的新符号索引"

#: gobject-docs.sgml:19(title)
msgid "Introduction"
msgstr "前言"

#: gobject-docs.sgml:20(para)
msgid ""
"Most modern programming languages come with their own native object systems "
"and additional fundamental algorithmic language constructs. Just as GLib "
"serves as an implementation of such fundamental types and algorithms (linked "
"lists, hash tables and so forth), the GLib Object System provides the "
"required implementations of a flexible extensible and intentionally easy to "
"map (into other languages) object-oriented framework for C. The substantial "
"elements that are provided can be summarized as: <placeholder-1/>"
msgstr ""
"大多数现代的计算机语言都带有自己的类型和对象系统，并附带算法结构。正如GLib提"
"供的基本类型和算法结构（如链表、哈希表等）一样，GObject的对象系统提供了一种灵"
"活的、可扩展的、并容易映射（到其它语言）的面向对象的C语言框架。它的实质可以概"
"括为： <placeholder-1/>"

#: gobject-docs.sgml:30(para)
msgid ""
"A generic type system to register arbitrary single-inherited flat and deep "
"derived types as well as interfaces for structured types. It takes care of "
"creation, initialization and memory management of the assorted object and "
"class structures, maintains parent/child relationships and deals with "
"dynamic implementations of such types. That is, their type specific "
"implementations are relocatable/unloadable during runtime."
msgstr ""
"一个通用类型系统，用来注册任意的、轻便的、单根继承的、并能推导出任意深度的结"
"构类型的界面，它照顾组合对象的定制、初始化和内存管理，类结构，保持对象的父子"
"关系，处理这些类型的动态实现。也就是说，这些类型的实现是在运行时重置和卸载"
"的。"

#: gobject-docs.sgml:40(para)
msgid ""
"A collection of fundamental type implementations, such as integers, doubles, "
"enums and structured types, to name a few."
msgstr "一个基本类型的实现集，如整型，枚举型和结构型等。"

#: gobject-docs.sgml:44(para)
msgid ""
"A sample fundamental type implementation to base object hierarchies upon - "
"the GObject fundamental type."
msgstr "一个基本对象体系之上的基本对象类型的实现的例子－GObject 基本类型。"

#: gobject-docs.sgml:48(para)
msgid ""
"A signal system that allows very flexible user customization of virtual/"
"overridable object methods and can serve as a powerful notification "
"mechanism."
msgstr ""
"一个信号系统，允许用户非常灵活的自定义虚的或重载对象的方法，并且能充当非常有"
"效力的通知机制。"

#: gobject-docs.sgml:53(para)
msgid ""
"An extensible parameter/value system, supporting all the provided "
"fundamental types that can be used to generically handle object properties "
"or otherwise parameterized types."
msgstr ""
"一个可扩展的参数/变量体系，支持所有的能被用作处理对象属性或其它参数化类型的基"
"本的类型。"

#: gobject-docs.sgml:63(title)
msgid "Concepts"
msgstr "概念"

#: gobject-docs.sgml:71(title)
msgid "API Reference"
msgstr "API 参考"

#: gobject-docs.sgml:89(title)
msgid "Tools Reference"
msgstr "工具参考"

#: gobject-query.xml:10(refname) gobject-query.xml:16(command)
#: gobject-query.xml:21(command) gobject-query.xml:4(refentrytitle)
msgid "gobject-query"
msgstr ""

#: gobject-query.xml:11(refpurpose)
msgid "display a tree of types"
msgstr ""

#: gobject-query.xml:17(arg) gobject-query.xml:44(option)
msgid "froots"
msgstr ""

#: gobject-query.xml:22(arg) gobject-query.xml:51(option)
msgid "tree"
msgstr ""

#: gobject-query.xml:28(para)
msgid ""
"<command>gobject-query</command> is a small utility that draws a tree of "
"types."
msgstr ""

#: gobject-query.xml:35(para)
msgid ""
"<command>gobject-query</command> takes a mandatory argument that specifies "
"whether it should iterate over the fundamental types or print a type tree."
msgstr ""

#: gobject-query.xml:45(para)
msgid "iterate over fundamental roots"
msgstr ""

#: gobject-query.xml:52(para)
msgid "print type tree"
msgstr ""

#: gobject-query.xml:58(option)
msgid "-r"
msgstr ""

#: gobject-query.xml:58(replaceable)
msgid "type"
msgstr ""

#: gobject-query.xml:59(para)
msgid "specify the root type"
msgstr ""

#: gobject-query.xml:65(option)
msgid "-n"
msgstr ""

#: gobject-query.xml:66(para)
msgid "don't descend type tree"
msgstr ""

#: gobject-query.xml:72(option)
msgid "-b"
msgstr ""

#: gobject-query.xml:72(replaceable) gobject-query.xml:79(replaceable)
msgid "string"
msgstr ""

#: gobject-query.xml:73(para)
msgid "specify indent string"
msgstr ""

#: gobject-query.xml:79(option)
msgid "-i"
msgstr ""

#: gobject-query.xml:80(para)
msgid "specify incremental indent string"
msgstr ""

#: gobject-query.xml:87(option)
msgid "-s"
msgstr ""

#: gobject-query.xml:87(replaceable)
msgid "number"
msgstr ""

#: gobject-query.xml:88(para)
msgid "specify line spacing"
msgstr ""

#: tut_gobject.xml:124(programlisting)
#, no-wrap
msgid ""
"\n"
"MamanBar *bar = g_object_new (MAMAN_TYPE_BAR, NULL);\n"
msgstr ""

#: tut_gobject.xml:138(para)
msgid ""
"Once <function><link linkend=\"g-object-new\">g_object_new</link></function> "
"has obtained a reference to an initialized class structure, it invokes its "
"constructor method to create an instance of the new object. Since it has "
"just been overridden by <function>maman_bar_class_init</function> to "
"<function>maman_bar_constructor</function>, the latter is called and, "
"because it was implemented correctly, it chains up to its parent's "
"constructor. In order to find the parent class and chain up to the parent "
"class constructor, we can use the <literal>maman_bar_parent_class</literal> "
"pointer that has been set up for us by the <literal>G_DEFINE_TYPE</literal> "
"macro."
msgstr ""

#: tut_gobject.xml:14(para)
msgid ""
"<link linkend=\"GObject\"><type>GObject</type></link> is a fundamental "
"classed instantiable type. It implements: <placeholder-1/> All the GNOME "
"libraries which use the GLib type system (like GTK+ and GStreamer) inherit "
"from <link linkend=\"GObject\"><type>GObject</type></link> which is why it "
"is important to understand the details of how it works."
msgstr ""

#: tut_gobject.xml:150(para)
msgid ""
"Finally, at one point or another, <function>g_object_constructor</function> "
"is invoked by the last constructor in the chain. This function allocates the "
"object's instance' buffer through <function><link linkend=\"g-type-create-"
"instance\">g_type_create_instance</link></function> which means that the "
"instance_init function is invoked at this point if one was registered. After "
"instance_init returns, the object is fully initialized and should be ready "
"to answer any user-request. When <function><link linkend=\"g-type-create-"
"instance\">g_type_create_instance</link></function> returns, "
"<function>g_object_constructor</function> sets the construction properties "
"(i.e. the properties which were given to <function><link linkend=\"g-object-"
"new\">g_object_new</link></function>) and returns to the user's constructor "
"which is then allowed to do useful instance initialization..."
msgstr ""

#: tut_gobject.xml:162(para)
msgid ""
"The process described above might seem a bit complicated, but it can be "
"summarized easily by the table below which lists the functions invoked by "
"<function><link linkend=\"g-object-new\">g_object_new</link></function> and "
"their order of invocation:"
msgstr ""

#: tut_gobject.xml:17(para)
msgid "Memory management with reference counting"
msgstr ""

#: tut_gobject.xml:171(link) tut_gobject.xml:187(link)
#: tut_gobject.xml:219(link)
msgid "g_object_new"
msgstr ""

#: tut_gobject.xml:179(entry)
msgid "Invocation time"
msgstr ""

#: tut_gobject.xml:18(para)
msgid "Construction/Destruction of instances"
msgstr ""

#: tut_gobject.xml:180(entry)
msgid "Function Invoked"
msgstr ""

#: tut_gobject.xml:181(entry)
msgid "Function's parameters"
msgstr ""

#: tut_gobject.xml:182(entry)
msgid "Remark"
msgstr ""

#: tut_gobject.xml:187(entry)
msgid "First call to <function><placeholder-1/></function> for target type"
msgstr ""

#: tut_gobject.xml:188(entry)
msgid "target type's base_init function"
msgstr ""

#: tut_gobject.xml:189(entry)
msgid ""
"On the inheritance tree of classes from fundamental type to target type. "
"base_init is invoked once for each class structure."
msgstr ""

#: tut_gobject.xml:19(para)
msgid "Generic per-object properties with set/get function pairs"
msgstr ""

#: tut_gobject.xml:191(entry)
msgid ""
"I have no real idea on how this can be used. If you have a good real-life "
"example of how a class' base_init can be used, please, let me know."
msgstr ""

#. entry>First call to <function><link linkend="g-object-new">g_object_new</link></function> for target type</entry
#: tut_gobject.xml:198(entry)
msgid "target type's class_init function"
msgstr ""

#: tut_gobject.xml:199(entry)
msgid "On target type's class structure"
msgstr ""

#: tut_gobject.xml:20(para)
msgid "Easy use of signals"
msgstr ""

#: tut_gobject.xml:200(entry)
msgid ""
"Here, you should make sure to initialize or override class methods (that is, "
"assign to each class' method its function pointer) and create the signals "
"and the properties associated to your object."
msgstr ""

#. entry>First call to <function><link linkend="g-object-new">g_object_new</link></function> for target type</entry
#: tut_gobject.xml:208(entry)
msgid "interface' base_init function"
msgstr ""

#: tut_gobject.xml:209(entry) tut_gobject.xml:215(entry)
msgid "On interface' vtable"
msgstr ""

#. entry>First call to <function><link linkend="g-object-new">g_object_new</link></function> for target type</entry
#: tut_gobject.xml:214(entry)
msgid "interface' interface_init function"
msgstr ""

#: tut_gobject.xml:219(entry)
msgid "Each call to <function><placeholder-1/></function> for target type"
msgstr ""

#: tut_gobject.xml:220(entry)
msgid "target type's class constructor method: GObjectClass-&gt;constructor"
msgstr ""

#: tut_gobject.xml:221(entry)
msgid "On object's instance"
msgstr ""

#: tut_gobject.xml:222(entry)
msgid ""
"If you need to complete the object initialization after all the construction "
"properties are set, override the constructor method and make sure to chain "
"up to the object's parent class before doing your own initialization. In "
"doubt, do not override the constructor method."
msgstr ""

#. entry>Each call to <function><link linkend="g-object-new">g_object_new</link></function> for target type</entry
#: tut_gobject.xml:231(entry)
msgid "type's instance_init function"
msgstr ""

#: tut_gobject.xml:232(entry)
msgid ""
"On the inheritance tree of classes from fundamental type to target type. the "
"instance_init provided for each type is invoked once for each instance "
"structure."
msgstr ""

#: tut_gobject.xml:235(entry)
msgid ""
"Provide an instance_init function to initialize your object before its "
"construction properties are set. This is the preferred way to initialize a "
"GObject instance. This function is equivalent to C++ constructors."
msgstr ""

#: tut_gobject.xml:246(para)
msgid ""
"Readers should feel concerned about one little twist in the order in which "
"functions are invoked: while, technically, the class' constructor method is "
"called <emphasis>before</emphasis> the GType's instance_init function (since "
"<function><link linkend=\"g-type-create-instance\">g_type_create_instance</"
"link></function> which calls instance_init is called by "
"<function>g_object_constructor</function> which is the top-level class "
"constructor method and to which users are expected to chain to), the user's "
"code which runs in a user-provided constructor will always run "
"<emphasis>after</emphasis> GType's instance_init function since the user-"
"provided constructor <emphasis>must</emphasis> (you've been warned) chain up "
"<emphasis>before</emphasis> doing anything useful."
msgstr ""

#: tut_gobject.xml:261(title)
msgid "Object memory management"
msgstr ""

#: tut_gobject.xml:263(para)
msgid ""
"The memory-management API for GObjects is a bit complicated but the idea "
"behind it is pretty simple: the goal is to provide a flexible model based on "
"reference counting which can be integrated in applications which use or "
"require different memory management models (such as garbage collection, "
"aso...). The methods which are used to manipulate this reference count are "
"described below. <placeholder-1/>"
msgstr ""

#: tut_gobject.xml:269(programlisting)
#, no-wrap
msgid ""
"\n"
"/*\n"
"  Refcounting\n"
"*/\n"
"gpointer    g_object_ref                      (gpointer        object);\n"
"void        g_object_unref                    (gpointer        object);\n"
"\n"
"/*\n"
" * Weak References\n"
" */\n"
"typedef void (*GWeakNotify) (gpointer  data,\n"
"                             GObject  *where_the_object_was);\n"
"\n"
"void g_object_weak_ref            (GObject     *object,\n"
"                                   GWeakNotify  notify,\n"
"                                   gpointer     data);\n"
"void g_object_weak_unref          (GObject     *object,\n"
"                                   GWeakNotify  notify,\n"
"                                   gpointer     data);\n"
"void g_object_add_weak_pointer    (GObject     *object, \n"
"                                   gpointer    *weak_pointer_location);\n"
"void g_object_remove_weak_pointer (GObject     *object, \n"
"                                   gpointer    *weak_pointer_location);\n"
"/*\n"
" * Cycle handling\n"
" */\n"
"void g_object_run_dispose         (GObject     *object);\n"
msgstr ""

#: tut_gobject.xml:28(title)
msgid "Object instantiation"
msgstr ""

#: tut_gobject.xml:30(para)
msgid ""
"The <function><link linkend=\"g-object-new\">g_object_new</link></function> "
"family of functions can be used to instantiate any GType which inherits from "
"the GObject base type. All these functions make sure the class and instance "
"structures have been correctly initialized by GLib's type system and then "
"invoke at one point or another the constructor class method which is used "
"to: <placeholder-1/> Although one can expect all class and instance members "
"(except the fields pointing to the parents) to be set to zero, some consider "
"it good practice to explicitly set them."
msgstr ""

#: tut_gobject.xml:300(title)
msgid "Reference count"
msgstr ""

#: tut_gobject.xml:302(para)
msgid ""
"The functions <function><link linkend=\"g-object-ref\">g_object_ref</link></"
"function>/<function><link linkend=\"g-object-unref\">g_object_unref</link></"
"function> respectively increase and decrease the reference count.These "
"functions are thread-safe as of GLib 2.8. The reference count is, "
"unsurprisingly, initialized to one by <function><link linkend=\"g-object-new"
"\">g_object_new</link></function> which means that the caller is currently "
"the sole owner of the newly-created reference. When the reference count "
"reaches zero, that is, when <function><link linkend=\"g-object-unref"
"\">g_object_unref</link></function> is called by the last client holding a "
"reference to the object, the <emphasis>dispose</emphasis> and the "
"<emphasis>finalize</emphasis> class methods are invoked."
msgstr ""

#: tut_gobject.xml:313(para)
msgid ""
"Finally, after <emphasis>finalize</emphasis> is invoked, <function><link "
"linkend=\"g-type-free-instance\">g_type_free_instance</link></function> is "
"called to free the object instance. Depending on the memory allocation "
"policy decided when the type was registered (through one of the "
"<function>g_type_register_*</function> functions), the object's instance "
"memory will be freed or returned to the object pool for this type. Once the "
"object has been freed, if it was the last instance of the type, the type's "
"class will be destroyed as described in <xref linkend=\"gtype-instantiable-"
"classed\"/> and <xref linkend=\"gtype-non-instantiable-classed\"/>."
msgstr ""

#: tut_gobject.xml:324(para)
msgid ""
"The table below summarizes the destruction process of a GObject: <table id="
"\"gobject-destruction-table\"><placeholder-1/><tgroup cols=\"3\"><colspec "
"colwidth=\"*\" colnum=\"1\" align=\"left\"/><colspec colwidth=\"*\" colnum="
"\"2\" align=\"left\"/><colspec colwidth=\"8*\" colnum=\"3\" align=\"left\"/"
"><thead><row><entry>Invocation time</entry><entry>Function Invoked</"
"entry><entry>Function's parameters</entry><entry>Remark</entry></row></"
"thead><tbody><row><entry morerows=\"1\">Last call to <function><link linkend="
"\"g-object-unref\">g_object_unref</link></function> for an instance of "
"target type </entry><entry>target type's dispose class function</"
"entry><entry>GObject instance</entry><entry> When dispose ends, the object "
"should not hold any reference to any other member object. The object is also "
"expected to be able to answer client method invocations (with possibly an "
"error code but no memory violation) until finalize is executed. dispose can "
"be executed more than once. dispose should chain up to its parent "
"implementation just before returning to the caller. </entry></"
"row><row><entry>target type's finalize class function</entry><entry>GObject "
"instance</entry><entry> Finalize is expected to complete the destruction "
"process initiated by dispose. It should complete the object's destruction. "
"finalize will be executed only once. finalize should chain up to its parent "
"implementation just before returning to the caller. The reason why the "
"destruction process is split is two different phases is explained in <xref "
"linkend=\"gobject-memory-cycles\"/>. </entry></row><row><entry morerows="
"\"3\">Last call to <function><link linkend=\"g-object-unref"
"\">g_object_unref</link></function> for the last instance of target type </"
"entry><entry>interface' interface_finalize function</entry><entry>On "
"interface' vtable</entry><entry>Never used in practice. Unlikely you will "
"need it.</entry></row><row><entry>interface' base_finalize function</"
"entry><entry>On interface' vtable</entry><entry>Never used in practice. "
"Unlikely you will need it.</entry></row><row><entry>target type's "
"class_finalize function</entry><entry>On target type's class structure</"
"entry><entry>Never used in practice. Unlikely you will need it.</entry></"
"row><row><entry>type's base_finalize function</entry><entry>On the "
"inheritance tree of classes from fundamental type to target type. base_init "
"is invoked once for each class structure.</entry><entry>Never used in "
"practice. Unlikely you will need it.</entry></row></tbody></tgroup></table>"
msgstr ""

#: tut_gobject.xml:327(link)
msgid "g_object_unref"
msgstr ""

#: tut_gobject.xml:38(para)
msgid ""
"Allocate and clear memory through <function><link linkend=\"g-type-create-"
"instance\">g_type_create_instance</link></function>,"
msgstr ""

#: tut_gobject.xml:41(para)
msgid "Initialize the object's instance with the construction properties."
msgstr ""

#: tut_gobject.xml:414(title)
msgid "Weak References"
msgstr ""

#: tut_gobject.xml:416(para)
msgid ""
"Weak References are used to monitor object finalization: <function><link "
"linkend=\"g-object-weak-ref\">g_object_weak_ref</link></function> adds a "
"monitoring callback which does not hold a reference to the object but which "
"is invoked when the object runs its dispose method. As such, each weak ref "
"can be invoked more than once upon object finalization (since dispose can "
"run more than once during object finalization)."
msgstr ""

#: tut_gobject.xml:425(para)
msgid ""
"<function><link linkend=\"g-object-weak-unref\">g_object_weak_unref</link></"
"function> can be used to remove a monitoring callback from the object."
msgstr ""

#: tut_gobject.xml:430(para)
msgid ""
"Weak References are also used to implement <function><link linkend=\"g-"
"object-add-weak-pointer\">g_object_add_weak_pointer</link></function> and "
"<function><link linkend=\"g-object-remove-weak-pointer"
"\">g_object_remove_weak_pointer</link></function>. These functions add a "
"weak reference to the object they are applied to which makes sure to nullify "
"the pointer given by the user when object is finalized."
msgstr ""

#: tut_gobject.xml:440(title)
msgid "Reference counts and cycles"
msgstr ""

#: tut_gobject.xml:442(para)
msgid ""
"Note: the following section was inspired by James Henstridge. I guess this "
"means that all praise and all curses will be directly forwarded to him."
msgstr ""

#: tut_gobject.xml:447(para)
msgid ""
"GObject's memory management model was designed to be easily integrated in "
"existing code using garbage collection. This is why the destruction process "
"is split in two phases: the first phase, executed in the dispose handler is "
"supposed to release all references to other member objects. The second "
"phase, executed by the finalize handler is supposed to complete the object's "
"destruction process. Object methods should be able to run without program "
"error (that is, without segfault :) in-between the two phases."
msgstr ""

#: tut_gobject.xml:456(para)
msgid ""
"This two-step destruction process is very useful to break reference counting "
"cycles. While the detection of the cycles is up to the external code, once "
"the cycles have been detected, the external code can invoke <function><link "
"linkend=\"g-object-run-dispose\">g_object_run_dispose</link></function> "
"which will indeed break any existing cycles since it will run the dispose "
"handler associated to the object and thus release all references to other "
"objects."
msgstr ""

#: tut_gobject.xml:464(para)
msgid ""
"Attentive readers might now have understood one of the rules about the "
"dispose handler we stated a bit sooner: the dispose handler can be invoked "
"multiple times. Let's say we have a reference count cycle: object A "
"references B which itself references object A. Let's say we have detected "
"the cycle and we want to destroy the two objects. One way to do this would "
"be to invoke <function><link linkend=\"g-object-run-dispose"
"\">g_object_run_dispose</link></function> on one of the objects."
msgstr ""

#: tut_gobject.xml:473(para)
msgid ""
"If object A releases all its references to all objects, this means it "
"releases its reference to object B. If object B was not owned by anyone "
"else, this is its last reference count which means this last unref runs B's "
"dispose handler which, in turn, releases B's reference on object A. If this "
"is A's last reference count, this last unref runs A's dispose handler which "
"is running for the second time before A's finalize handler is invoked !"
msgstr ""

#: tut_gobject.xml:482(para)
msgid ""
"The above example, which might seem a bit contrived can really happen if "
"your GObject's are being handled by language bindings. I would thus suggest "
"the rules stated above for object destruction are closely followed. "
"Otherwise, <emphasis>Bad Bad Things</emphasis> will happen."
msgstr ""

#: tut_gobject.xml:492(title)
msgid "Object properties"
msgstr ""

#: tut_gobject.xml:494(para)
msgid ""
"One of GObject's nice features is its generic get/set mechanism for object "
"properties. When an object is instantiated, the object's class_init handler "
"should be used to register the object's properties with <function><link "
"linkend=\"g-object-class-install-property\">g_object_class_install_property</"
"link></function> (implemented in <filename>gobject.c</filename>)."
msgstr ""

#: tut_gobject.xml:50(para)
msgid ""
"Objects which inherit from GObject are allowed to override this constructor "
"class method: they should however chain to their parent constructor method "
"before doing so: <placeholder-1/>"
msgstr ""

#: tut_gobject.xml:502(para)
msgid ""
"The best way to understand how object properties work is by looking at a "
"real example on how it is used: <placeholder-1/> The client code just above "
"looks simple but a lot of things happen under the hood:"
msgstr ""

#: tut_gobject.xml:505(programlisting)
#, no-wrap
msgid ""
"\n"
"/************************************************/\n"
"/* Implementation                               */\n"
"/************************************************/\n"
"\n"
"enum\n"
"{\n"
"  PROP_0,\n"
"\n"
"  PROP_MAMAN_NAME,\n"
"  PROP_PAPA_NUMBER\n"
"};\n"
"\n"
"static void\n"
"maman_bar_set_property (GObject      *object,\n"
"                        guint         property_id,\n"
"                        const GValue *value,\n"
"                        GParamSpec   *pspec)\n"
"{\n"
"  MamanBar *self = MAMAN_BAR (object);\n"
"\n"
"  switch (property_id)\n"
"    {\n"
"    case PROP_MAMAN_NAME:\n"
"      g_free (self-&gt;priv-&gt;name);\n"
"      self-&gt;priv-&gt;name = g_value_dup_string (value);\n"
"      g_print (\"maman: %s\\n\", self-&gt;priv-&gt;name);\n"
"      break;\n"
"\n"
"    case PROP_PAPA_NUMBER:\n"
"      self-&gt;priv-&gt;papa_number = g_value_get_uchar (value);\n"
"      g_print (\"papa: &percnt;u\\n\", self-&gt;priv-&gt;papa_number);\n"
"      break;\n"
"\n"
"    default:\n"
"      /* We don't have any other property... */\n"
"      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);\n"
"      break;\n"
"    }\n"
"}\n"
"\n"
"static void\n"
"maman_bar_get_property (GObject    *object,\n"
"                        guint       property_id,\n"
"                        GValue     *value,\n"
"                        GParamSpec *pspec)\n"
"{\n"
"  MamanBar *self = MAMAN_BAR (object);\n"
"\n"
"  switch (property_id)\n"
"    {\n"
"    case PROP_MAMAN_NAME:\n"
"      g_value_set_string (value, self-&gt;priv-&gt;name);\n"
"      break;\n"
"\n"
"    case PROP_PAPA_NUMBER:\n"
"      g_value_set_uchar (value, self-&gt;priv-&gt;papa_number);\n"
"      break;\n"
"\n"
"    default:\n"
"      /* We don't have any other property... */\n"
"      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, property_id, pspec);\n"
"      break;\n"
"    }\n"
"}\n"
"\n"
"static void\n"
"maman_bar_class_init (MamanBarClass *klass)\n"
"{\n"
"  GObjectClass *gobject_class = G_OBJECT_CLASS (klass);\n"
"  GParamSpec *pspec;\n"
"\n"
"  gobject_class-&gt;set_property = maman_bar_set_property;\n"
"  gobject_class-&gt;get_property = maman_bar_get_property;\n"
"\n"
"  pspec = g_param_spec_string (\"maman-name\",\n"
"                               \"Maman construct prop\",\n"
"                               \"Set maman's name\",\n"
"                               \"no-name-set\" /* default value */,\n"
"                               G_PARAM_CONSTRUCT_ONLY | G_PARAM_READWRITE);\n"
"  g_object_class_install_property (gobject_class,\n"
"                                   PROP_MAMAN_NAME,\n"
"                                   pspec);\n"
"\n"
"  pspec = g_param_spec_uchar (\"papa-number\",\n"
"                              \"Number of current Papa\",\n"
"                              \"Set/Get papa's number\",\n"
"                              0  /* minimum value */,\n"
"                              10 /* maximum value */,\n"
"                              2  /* default value */,\n"
"                              G_PARAM_READWRITE);\n"
"  g_object_class_install_property (gobject_class,\n"
"                                   PROP_PAPA_NUMBER,\n"
"                                   pspec);\n"
"}\n"
"\n"
"/************************************************/\n"
"/* Use                                          */\n"
"/************************************************/\n"
"\n"
"GObject *bar;\n"
"GValue val = { 0, };\n"
"\n"
"bar = g_object_new (MAMAN_TYPE_SUBBAR, NULL);\n"
"\n"
"g_value_init (&amp;val, G_TYPE_CHAR);\n"
"g_value_set_char (&amp;val, 11);\n"
"\n"
"g_object_set_property (G_OBJECT (bar), \"papa-number\", &amp;val);\n"
"\n"
"g_value_unset (&amp;val);\n"
msgstr ""

#: tut_gobject.xml:54(programlisting)
#, no-wrap
msgid ""
"\n"
"  GObject *(* constructor) (GType                  gtype,\n"
"                            guint                  n_properties,\n"
"                            GObjectConstructParam *properties);\n"
msgstr ""

#: tut_gobject.xml:6(title)
msgid "The GObject base class"
msgstr ""

#: tut_gobject.xml:61(para)
msgid ""
"The example below shows how <type>MamanBar</type> overrides the parent's "
"constructor: <placeholder-1/> If the user instantiates an object "
"<type>MamanBar</type> with: <placeholder-2/> If this is the first "
"instantiation of such an object, the <function>maman_bar_class_init</"
"function> function will be invoked after any "
"<function>maman_bar_base_class_init</function> function. This will make sure "
"the class structure of this new object is correctly initialized. Here, "
"<function>maman_bar_class_init</function> is expected to override the "
"object's class methods and setup the class' own methods. In the example "
"above, the constructor method is the only overridden method: it is set to "
"<function>maman_bar_constructor</function>."
msgstr ""

#: tut_gobject.xml:620(para)
msgid ""
"<function><link linkend=\"g-object-set-property\">g_object_set_property</"
"link></function> first ensures a property with this name was registered in "
"bar's class_init handler. If so, it calls <function><link linkend=\"object-"
"set-property\">object_set_property</link></function> which first walks the "
"class hierarchy, from bottom, most derived type, to top, fundamental type to "
"find the class which registered that property. It then tries to convert the "
"user-provided GValue into a GValue whose type is that of the associated "
"property."
msgstr ""

#: tut_gobject.xml:629(para)
msgid ""
"If the user provides a signed char GValue, as is shown here, and if the "
"object's property was registered as an unsigned int, <function><link linkend="
"\"g-value-transform\">g_value_transform</link></function> will try to "
"transform the input signed char into an unsigned int. Of course, the success "
"of the transformation depends on the availability of the required transform "
"function. In practice, there will almost always be a transformation "
"<placeholder-1/> which matches and conversion will be carried out if needed."
msgstr ""

#: tut_gobject.xml:63(programlisting)
#, no-wrap
msgid ""
"\n"
"#define MAMAN_TYPE_BAR                  (maman_bar_get_type ())\n"
"#define MAMAN_BAR(obj)                  (G_TYPE_CHECK_INSTANCE_CAST ((obj), MAMAN_TYPE_BAR, MamanBar))\n"
"#define MAMAN_IS_BAR(obj)               (G_TYPE_CHECK_INSTANCE_TYPE ((obj), MAMAN_TYPE_BAR))\n"
"#define MAMAN_BAR_CLASS(klass)          (G_TYPE_CHECK_CLASS_CAST ((klass), MAMAN_TYPE_BAR, MamanBarClass))\n"
"#define MAMAN_IS_BAR_CLASS(klass)       (G_TYPE_CHECK_CLASS_TYPE ((klass), MAMAN_TYPE_BAR))\n"
"#define MAMAN_BAR_GET_CLASS(obj)        (G_TYPE_INSTANCE_GET_CLASS ((obj), MAMAN_TYPE_BAR, MamanBarClass))\n"
"\n"
"typedef struct _MamanBar        MamanBar;\n"
"typedef struct _MamanBarClass   MamanBarClass;\n"
"\n"
"struct _MamanBar\n"
"{\n"
"  GObject parent_instance;\n"
"\n"
"  /* instance members */\n"
"};\n"
"\n"
"struct _MamanBarClass\n"
"{\n"
"  GObjectClass parent_class;\n"
"\n"
"  /* class members */\n"
"};\n"
"\n"
"/* will create maman_bar_get_type and set maman_bar_parent_class */\n"
"G_DEFINE_TYPE (MamanBar, maman_bar, G_TYPE_OBJECT);\n"
"\n"
"static GObject *\n"
"maman_bar_constructor (GType                  gtype,\n"
"                       guint                  n_properties,\n"
"                       GObjectConstructParam *properties)\n"
"{\n"
"  GObject *obj;\n"
"\n"
"  {\n"
"    /* Always chain up to the parent constructor */\n"
"    obj = G_OBJECT_CLASS (maman_bar_parent_class)-&gt;constructor (gtype, n_properties, properties);\n"
"  }\n"
"  \n"
"  /* update the object state depending on constructor properties */\n"
"\n"
"  return obj;\n"
"}\n"
"\n"
"static void\n"
"maman_bar_class_init (MamanBarClass *klass)\n"
"{\n"
"  GObjectClass *gobject_class = G_OBJECT_CLASS (klass);\n"
"\n"
"  gobject_class-&gt;constructor = maman_bar_constructor;\n"
"}\n"
"\n"
"static void\n"
"maman_bar_init (MamanBar *self)\n"
"{\n"
"  /* initialize the object */\n"
"}\n"
"\n"
msgstr ""

#: tut_gobject.xml:636(para)
msgid ""
"Its behaviour might not be what you expect but it is up to you to actually "
"avoid relying on these transformations."
msgstr ""

#: tut_gobject.xml:643(para)
msgid ""
"After transformation, the <link linkend=\"GValue\"><type>GValue</type></"
"link> is validated by <function><link linkend=\"g-param-value-validate"
"\">g_param_value_validate</link></function> which makes sure the user's data "
"stored in the <link linkend=\"GValue\"><type>GValue</type></link> matches "
"the characteristics specified by the property's <link linkend=\"GParamSpec"
"\"><type>GParamSpec</type></link>. Here, the <link linkend=\"GParamSpec"
"\"><type>GParamSpec</type></link> we provided in class_init has a validation "
"function which makes sure that the GValue contains a value which respects "
"the minimum and maximum bounds of the <link linkend=\"GParamSpec"
"\"><type>GParamSpec</type></link>. In the example above, the client's GValue "
"does not respect these constraints (it is set to 11, while the maximum is "
"10). As such, the <function><link linkend=\"g-object-set-property"
"\">g_object_set_property</link></function> function will return with an "
"error."
msgstr ""

#: tut_gobject.xml:656(para)
msgid ""
"If the user's GValue had been set to a valid value, <function><link linkend="
"\"g-object-set-property\">g_object_set_property</link></function> would have "
"proceeded with calling the object's set_property class method. Here, since "
"our implementation of Foo did override this method, the code path would jump "
"to <function>foo_set_property</function> after having retrieved from the "
"<link linkend=\"GParamSpec\"><type>GParamSpec</type></link> the "
"<emphasis>param_id</emphasis><placeholder-1/> which had been stored by "
"<function><link linkend=\"g-object-class-install-property"
"\">g_object_class_install_property</link></function>."
msgstr ""

#: tut_gobject.xml:663(para)
msgid ""
"It should be noted that the param_id used here need only to uniquely "
"identify each <link linkend=\"GParamSpec\"><type>GParamSpec</type></link> "
"within the <link linkend=\"FooClass\"><type>FooClass</type></link> such that "
"the switch used in the set and get methods actually works. Of course, this "
"locally-unique integer is purely an optimization: it would have been "
"possible to use a set of <emphasis>if (strcmp (a, b) == 0) {} else if "
"(strcmp (a, b) == 0) {}</emphasis> statements."
msgstr ""

#: tut_gobject.xml:675(para)
msgid ""
"Once the property has been set by the object's set_property class method, "
"the code path returns to <function><link linkend=\"g-object-set-property"
"\">g_object_set_property</link></function> which calls <function><link "
"linkend=\"g-object-notify-queue-thaw\">g_object_notify_queue_thaw</link></"
"function>. This function makes sure that the \"notify\" signal is emitted on "
"the object's instance with the changed property as parameter unless "
"notifications were frozen by <function><link linkend=\"g-object-freeze-notify"
"\">g_object_freeze_notify</link></function>."
msgstr ""

#: tut_gobject.xml:683(para)
msgid ""
"<function><link linkend=\"g-object-thaw-notify\">g_object_thaw_notify</"
"link></function> can be used to re-enable notification of property "
"modifications through the \"notify\" signal. It is important to remember "
"that even if properties are changed while property change notification is "
"frozen, the \"notify\" signal will be emitted once for each of these changed "
"properties as soon as the property change notification is thawed: no "
"property change is lost for the \"notify\" signal. Signal can only be "
"delayed by the notification freezing mechanism."
msgstr ""

#: tut_gobject.xml:692(para)
msgid ""
"It sounds like a tedious task to set up GValues every time when one wants to "
"modify a property. In practice one will rarely do this. The functions "
"<function><link linkend=\"g-object-set-property\">g_object_set_property</"
"link></function> and <function><link linkend=\"g-object-get-property"
"\">g_object_get_property</link></function> are meant to be used by language "
"bindings. For application there is an easier way and that is described next."
msgstr ""

#: tut_gobject.xml:701(title)
msgid "Accessing multiple properties at once"
msgstr ""

#: tut_gobject.xml:703(para)
msgid ""
"It is interesting to note that the <function><link linkend=\"g-object-set"
"\">g_object_set</link></function> and <function><link linkend=\"g-object-set-"
"valist\">g_object_set_valist</link></function> (vararg version) functions "
"can be used to set multiple properties at once. The client code shown above "
"can then be re-written as: <placeholder-1/> This saves us from managing the "
"GValues that we were needing to handle when using <function><link linkend="
"\"g-object-set-property\">g_object_set_property</link></function>. The code "
"above will trigger one notify signal emission for each property modified."
msgstr ""

#: tut_gobject.xml:707(programlisting)
#, no-wrap
msgid ""
"\n"
"MamanBar *foo;\n"
"foo = /* */;\n"
"g_object_set (G_OBJECT (foo),\n"
"              \"papa-number\", 2, \n"
"              \"maman-name\", \"test\", \n"
"              NULL);\n"
msgstr ""

#: tut_gobject.xml:720(para)
msgid ""
"Of course, the _get versions are also available: <function><link linkend=\"g-"
"object-get\">g_object_get</link></function> and <function><link linkend=\"g-"
"object-get-valist\">g_object_get_valist</link></function> (vararg version) "
"can be used to get numerous properties at once."
msgstr ""

#: tut_gobject.xml:726(para)
msgid ""
"These high level functions have one drawback - they don't provide a return "
"result. One should pay attention to the argument types and ranges when using "
"them. A known source of errors is to e.g. pass a gfloat instead of a gdouble "
"and thus shifting all subsequent parameters by four bytes. Also forgetting "
"the terminating NULL will lead to unexpected behaviour."
msgstr ""

#: tut_gobject.xml:734(para)
msgid ""
"Really attentive readers now understand how <function><link linkend=\"g-"
"object-new\">g_object_new</link></function>, <function><link linkend=\"g-"
"object-newv\">g_object_newv</link></function> and <function><link linkend="
"\"g-object-new-valist\">g_object_new_valist</link></function> work: they "
"parse the user-provided variable number of parameters and invoke "
"<function><link linkend=\"g-object-set\">g_object_set</link></function> on "
"the parameters only after the object has been successfully constructed. Of "
"course, the \"notify\" signal will be emitted for each property set."
msgstr ""

#: tut_gobject.xml:8(para)
msgid ""
"The two previous chapters discussed the details of GLib's Dynamic Type "
"System and its signal control system. The GObject library also contains an "
"implementation for a base fundamental type named <link linkend=\"GObject"
"\"><type>GObject</type></link>."
msgstr ""

#: tut_gsignal.xml:102(para)
msgid ""
"<function><link linkend=\"g-cclosure-new-swap\">g_cclosure_new_swap</link></"
"function> will create a new closure which can invoke the user-provided "
"callback_func with the user-provided user_data as first parameter (instead "
"of being the last parameter as with <function><link linkend=\"g-cclosure-new"
"\">g_cclosure_new</link></function>). When the closure is finalized (second "
"stage of the destruction process), it will invoke the destroy_data function "
"if the user has supplied one."
msgstr ""

#: tut_gsignal.xml:11(para)
msgid ""
"Closures are central to the concept of asynchronous signal delivery which is "
"widely used throughout GTK+ and GNOME applications. A closure is an "
"abstraction, a generic representation of a callback. It is a small structure "
"which contains three objects: <placeholder-1/>"
msgstr ""

#: tut_gsignal.xml:112(title)
msgid "Non-C closures (for the fearless)"
msgstr ""

#: tut_gsignal.xml:114(para)
msgid ""
"As was explained above, closures hide the details of callback invocation. In "
"C, callback invocation is just like function invocation: it is a matter of "
"creating the correct stack frame for the called function and executing a "
"<emphasis>call</emphasis> assembly instruction."
msgstr ""

#: tut_gsignal.xml:121(para)
msgid ""
"C closure marshallers transform the array of GValues which represent the "
"parameters to the target function into a C-style function parameter list, "
"invoke the user-supplied C function with this new parameter list, get the "
"return value of the function, transform it into a GValue and return this "
"GValue to the marshaller caller."
msgstr ""

#: tut_gsignal.xml:128(para)
msgid ""
"The following code implements a simple marshaller in C for a C function "
"which takes an integer as first parameter and returns void. <placeholder-1/>"
msgstr ""

#: tut_gsignal.xml:131(programlisting)
#, no-wrap
msgid ""
"\n"
"g_cclosure_marshal_VOID__INT (GClosure     *closure,\n"
"                              GValue       *return_value,\n"
"                              guint         n_param_values,\n"
"                              const GValue *param_values,\n"
"                              gpointer      invocation_hint,\n"
"                              gpointer      marshal_data)\n"
"{\n"
"  typedef void (*GMarshalFunc_VOID__INT) (gpointer     data1,\n"
"                                          gint         arg_1,\n"
"                                          gpointer     data2);\n"
"  register GMarshalFunc_VOID__INT callback;\n"
"  register GCClosure *cc = (GCClosure*) closure;\n"
"  register gpointer data1, data2;\n"
"\n"
"  g_return_if_fail (n_param_values == 2);\n"
"\n"
"  data1 = g_value_peek_pointer (param_values + 0);\n"
"  data2 = closure-&gt;data;\n"
"\n"
"  callback = (GMarshalFunc_VOID__INT) (marshal_data ? marshal_data : cc-&gt;callback);\n"
"\n"
"  callback (data1,\n"
"            g_marshal_value_peek_int (param_values + 1),\n"
"            data2);\n"
"}\n"
msgstr ""

#: tut_gsignal.xml:160(para)
msgid ""
"Of course, there exist other kinds of marshallers. For example, James "
"Henstridge wrote a generic Python marshaller which is used by all Python "
"closures (a Python closure is used to have Python-based callback be invoked "
"by the closure invocation process). This Python marshaller transforms the "
"input GValue list representing the function parameters into a Python tuple "
"which is the equivalent structure in Python (you can look in "
"<function>pyg_closure_marshal</function> in <filename>pygtype.c</filename> "
"in the <emphasis>pygobject</emphasis> module in the GNOME source code "
"repository)."
msgstr ""

#: tut_gsignal.xml:17(para)
msgid ""
"a function pointer (the callback itself) whose prototype looks like: "
"<placeholder-1/>"
msgstr ""

#: tut_gsignal.xml:174(title)
msgid "Signals"
msgstr ""

#: tut_gsignal.xml:176(para)
msgid ""
"GObject's signals have nothing to do with standard UNIX signals: they "
"connect arbitrary application-specific events with any number of listeners. "
"For example, in GTK+, every user event (keystroke or mouse move) is received "
"from the X server and generates a GTK+ event under the form of a signal "
"emission on a given object instance."
msgstr ""

#: tut_gsignal.xml:18(programlisting)
#, no-wrap
msgid ""
"\n"
"return_type function_callback (... , gpointer user_data);\n"
msgstr ""

#: tut_gsignal.xml:184(para)
msgid ""
"Each signal is registered in the type system together with the type on which "
"it can be emitted: users of the type are said to <emphasis>connect</"
"emphasis> to the signal on a given type instance when they register a "
"closure to be invoked upon the signal emission. Users can also emit the "
"signal by themselves or stop the emission of the signal from within one of "
"the closures connected to the signal."
msgstr ""

#: tut_gsignal.xml:193(para)
msgid ""
"When a signal is emitted on a given type instance, all the closures "
"connected to this signal on this type instance will be invoked. All the "
"closures connected to such a signal represent callbacks whose signature "
"looks like: <placeholder-1/>"
msgstr ""

#: tut_gsignal.xml:197(programlisting)
#, no-wrap
msgid ""
"\n"
"return_type function_callback (gpointer instance, ... , gpointer user_data);\n"
msgstr ""

#: tut_gsignal.xml:203(title)
msgid "Signal registration"
msgstr ""

#: tut_gsignal.xml:205(para)
msgid ""
"To register a new signal on an existing type, we can use any of "
"<function><link linkend=\"g-signal-newv\">g_signal_newv</link></function>, "
"<function><link linkend=\"g-signal-new-valist\">g_signal_new_valist</link></"
"function> or <function><link linkend=\"g-signal-new\">g_signal_new</link></"
"function> functions: <placeholder-1/> The number of parameters to these "
"functions is a bit intimidating but they are relatively simple: "
"<placeholder-2/>"
msgstr ""

#: tut_gsignal.xml:208(programlisting)
#, no-wrap
msgid ""
"\n"
"guint g_signal_newv (const gchar        *signal_name,\n"
"                     GType               itype,\n"
"                     GSignalFlags        signal_flags,\n"
"                     GClosure           *class_closure,\n"
"                     GSignalAccumulator  accumulator,\n"
"                     gpointer            accu_data,\n"
"                     GSignalCMarshaller  c_marshaller,\n"
"                     GType               return_type,\n"
"                     guint               n_params,\n"
"                     GType              *param_types);\n"
msgstr ""

#: tut_gsignal.xml:22(para)
msgid ""
"the user_data pointer which is passed to the callback upon invocation of the "
"closure"
msgstr ""

#: tut_gsignal.xml:223(para)
msgid ""
"signal_name: is a string which can be used to uniquely identify a given "
"signal."
msgstr ""

#: tut_gsignal.xml:226(para)
msgid "itype: is the instance type on which this signal can be emitted."
msgstr ""

#: tut_gsignal.xml:229(para)
msgid ""
"signal_flags: partly defines the order in which closures which were "
"connected to the signal are invoked."
msgstr ""

#: tut_gsignal.xml:233(para)
msgid ""
"class_closure: this is the default closure for the signal: if it is not NULL "
"upon the signal emission, it will be invoked upon this emission of the "
"signal. The moment where this closure is invoked compared to other closures "
"connected to that signal depends partly on the signal_flags."
msgstr ""

#: tut_gsignal.xml:239(para)
msgid ""
"accumulator: this is a function pointer which is invoked after each closure "
"has been invoked. If it returns FALSE, signal emission is stopped. If it "
"returns TRUE, signal emission proceeds normally. It is also used to compute "
"the return value of the signal based on the return value of all the invoked "
"closures."
msgstr ""

#: tut_gsignal.xml:245(para)
msgid ""
"accumulator_data: this pointer will be passed down to each invocation of the "
"accumulator during emission."
msgstr ""

#: tut_gsignal.xml:249(para)
msgid ""
"c_marshaller: this is the default C marshaller for any closure which is "
"connected to this signal."
msgstr ""

#: tut_gsignal.xml:25(para)
msgid ""
"a function pointer which represents the destructor of the closure: whenever "
"the closure's refcount reaches zero, this function will be called before the "
"closure structure is freed."
msgstr ""

#: tut_gsignal.xml:253(para)
msgid "return_type: this is the type of the return value of the signal."
msgstr ""

#: tut_gsignal.xml:256(para)
msgid "n_params: this is the number of parameters this signal takes."
msgstr ""

#: tut_gsignal.xml:259(para)
msgid ""
"param_types: this is an array of GTypes which indicate the type of each "
"parameter of the signal. The length of this array is indicated by n_params."
msgstr ""

#: tut_gsignal.xml:266(para)
msgid ""
"As you can see from the above definition, a signal is basically a "
"description of the closures which can be connected to this signal and a "
"description of the order in which the closures connected to this signal will "
"be invoked."
msgstr ""

#: tut_gsignal.xml:275(title)
msgid "Signal connection"
msgstr ""

#: tut_gsignal.xml:277(para)
msgid ""
"If you want to connect to a signal with a closure, you have three "
"possibilities: <placeholder-1/> It is also possible to connect a different "
"kind of callback on a given signal: emission hooks are invoked whenever a "
"given signal is emitted whatever the instance on which it is emitted. "
"Emission hooks are used for example to get all mouse_clicked emissions in an "
"application to be able to emit the small mouse click sound. Emission hooks "
"are connected with <function><link linkend=\"g-signal-add-emission-hook"
"\">g_signal_add_emission_hook</link></function> and removed with "
"<function><link linkend=\"g-signal-remove-emission-hook"
"\">g_signal_remove_emission_hook</link></function>."
msgstr ""

#: tut_gsignal.xml:280(para)
msgid ""
"You can register a class closure at signal registration: this is a system-"
"wide operation. i.e.: the class_closure will be invoked during each emission "
"of a given signal on all the instances of the type which supports that "
"signal."
msgstr ""

#: tut_gsignal.xml:285(para)
msgid ""
"You can use <function><link linkend=\"g-signal-override-class-closure"
"\">g_signal_override_class_closure</link></function> which overrides the "
"class_closure of a given type. It is possible to call this function only on "
"a derived type of the type on which the signal was registered. This function "
"is of use only to language bindings."
msgstr ""

#: tut_gsignal.xml:291(para)
msgid ""
"You can register a closure with the <function><link linkend=\"g-signal-"
"connect\">g_signal_connect</link></function> family of functions. This is an "
"instance-specific operation: the closure will be invoked only during "
"emission of a given signal on a given instance."
msgstr ""

#: tut_gsignal.xml:308(title)
msgid "Signal emission"
msgstr ""

#: tut_gsignal.xml:310(para)
msgid ""
"Signal emission is done through the use of the <function><link linkend=\"g-"
"signal-emit\">g_signal_emit</link></function> family of functions. "
"<placeholder-1/><placeholder-2/>"
msgstr ""

#: tut_gsignal.xml:313(programlisting)
#, no-wrap
msgid ""
"\n"
"void g_signal_emitv (const GValue *instance_and_params,\n"
"                     guint         signal_id,\n"
"                     GQuark        detail,\n"
"                     GValue       *return_value);\n"
msgstr ""

#: tut_gsignal.xml:320(para)
msgid ""
"The instance_and_params array of GValues contains the list of input "
"parameters to the signal. The first element of the array is the instance "
"pointer on which to invoke the signal. The following elements of the array "
"contain the list of parameters to the signal."
msgstr ""

#: tut_gsignal.xml:326(para)
msgid "signal_id identifies the signal to invoke."
msgstr ""

#: tut_gsignal.xml:329(para)
msgid ""
"detail identifies the specific detail of the signal to invoke. A detail is a "
"kind of magic token/argument which is passed around during signal emission "
"and which is used by closures connected to the signal to filter out unwanted "
"signal emissions. In most cases, you can safely set this value to zero. See "
"<xref linkend=\"signal-detail\"/> for more details about this parameter."
msgstr ""

#: tut_gsignal.xml:33(para)
msgid ""
"The <link linkend=\"GClosure\"><type>GClosure</type></link> structure "
"represents the common functionality of all closure implementations: there "
"exists a different Closure implementation for each separate runtime which "
"wants to use the GObject type system. <placeholder-1/> The GObject library "
"provides a simple <link linkend=\"GCClosure\"><type>GCClosure</type></link> "
"type which is a specific implementation of closures to be used with C/C++ "
"callbacks."
msgstr ""

#: tut_gsignal.xml:336(para)
msgid ""
"return_value holds the return value of the last closure invoked during "
"emission if no accumulator was specified. If an accumulator was specified "
"during signal creation, this accumulator is used to calculate the "
"return_value as a function of the return values of all the closures invoked "
"during emission. <placeholder-1/> If no closure is invoked during emission, "
"the return_value is nonetheless initialized to zero/null."
msgstr ""

#: tut_gsignal.xml:341(para)
msgid ""
"James (again!!) gives a few non-trivial examples of accumulators: <quote> "
"For instance, you may have an accumulator that ignores NULL returns from "
"closures, and only accumulates the non-NULL ones. Another accumulator may "
"try to return the list of values returned by the closures. </quote>"
msgstr ""

#: tut_gsignal.xml:355(para)
msgid ""
"Internally, the GValue array is passed to the emission function proper, "
"<function>signal_emit_unlocked_R</function> (implemented in "
"<filename>gsignal.c</filename>). Signal emission can be decomposed in 5 "
"steps: <placeholder-1/>"
msgstr ""

#: tut_gsignal.xml:360(para)
msgid ""
"<emphasis>RUN_FIRST</emphasis>: if the G_SIGNAL_RUN_FIRST flag was used "
"during signal registration and if there exist a class_closure for this "
"signal, the class_closure is invoked. Jump to <emphasis>EMISSION_HOOK</"
"emphasis> state."
msgstr ""

#: tut_gsignal.xml:365(para)
msgid ""
"<emphasis>EMISSION_HOOK</emphasis>: if any emission hook was added to the "
"signal, they are invoked from first to last added. Accumulate return values "
"and jump to <emphasis>HANDLER_RUN_FIRST</emphasis> state."
msgstr ""

#: tut_gsignal.xml:37(para)
msgid ""
"In practice, closures sit at the boundary of language runtimes: if you are "
"writing Python code and one of your Python callbacks receives a signal from "
"a GTK+ widget, the C code in GTK+ needs to execute your Python code. The "
"closure invoked by the GTK+ object invokes the Python callback: it behaves "
"as a normal C object for GTK+ and as a normal Python object for Python code."
msgstr ""

#: tut_gsignal.xml:370(para)
msgid ""
"<emphasis>HANDLER_RUN_FIRST</emphasis>: if any closure were connected with "
"the <function><link linkend=\"g-signal-connect\">g_signal_connect</link></"
"function> family of functions, and if they are not blocked (with the "
"<function><link linkend=\"g-signal-handler-block\">g_signal_handler_block</"
"link></function> family of functions) they are run here, from first to last "
"connected. Jump to <emphasis>RUN_LAST</emphasis> state."
msgstr ""

#: tut_gsignal.xml:377(para)
msgid ""
"<emphasis>RUN_LAST</emphasis>: if the G_SIGNAL_RUN_LAST flag was set during "
"registration and if a class_closure was set, it is invoked here. Jump to "
"<emphasis>HANDLER_RUN_LAST</emphasis> state."
msgstr ""

#: tut_gsignal.xml:383(para)
msgid ""
"<emphasis>HANDLER_RUN_LAST</emphasis>: if any closure were connected with "
"the <function>g_signal_connect_after</function> family of functions, if they "
"were not invoked during HANDLER_RUN_FIRST and if they are not blocked, they "
"are run here, from first to last connected. Jump to <emphasis>RUN_CLEANUP</"
"emphasis> state."
msgstr ""

#: tut_gsignal.xml:390(para)
msgid ""
"<emphasis>RUN_CLEANUP</emphasis>: if the G_SIGNAL_RUN_CLEANUP flag was set "
"during registration and if a class_closure was set, it is invoked here. "
"Signal emission is completed here."
msgstr ""

#: tut_gsignal.xml:398(para)
msgid ""
"If, at any point during emission (except in RUN_CLEANUP state), one of the "
"closures or emission hook stops the signal emission with <function><link "
"linkend=\"g-signal-stop\">g_signal_stop</link></function>, emission jumps to "
"CLEANUP state."
msgstr ""

#: tut_gsignal.xml:404(para)
msgid ""
"If, at any point during emission, one of the closures or emission hook emits "
"the same signal on the same instance, emission is restarted from the "
"RUN_FIRST state."
msgstr ""

#: tut_gsignal.xml:410(para)
msgid ""
"The accumulator function is invoked in all states, after invocation of each "
"closure (except in EMISSION_HOOK and CLEANUP). It accumulates the closure "
"return value into the signal return value and returns TRUE or FALSE. If, at "
"any point, it does not return TRUE, emission jumps to CLEANUP state."
msgstr ""

#: tut_gsignal.xml:417(para)
msgid ""
"If no accumulator function was provided, the value returned by the last "
"handler run will be returned by <function><link linkend=\"g-signal-emit"
"\">g_signal_emit</link></function>."
msgstr ""

#: tut_gsignal.xml:426(title)
msgid "The <emphasis>detail</emphasis> argument"
msgstr ""

#: tut_gsignal.xml:428(para)
msgid ""
"All the functions related to signal emission or signal connection have a "
"parameter named the <emphasis>detail</emphasis>. Sometimes, this parameter "
"is hidden by the API but it is always there, under one form or another."
msgstr ""

#: tut_gsignal.xml:433(para)
msgid ""
"Of the three main connection functions, only one has an explicit detail "
"parameter as a <link linkend=\"GQuark\"><type>GQuark</type></"
"link><placeholder-1/>: <placeholder-2/> The two other functions hide the "
"detail parameter in the signal name identification: <placeholder-3/> Their "
"detailed_signal parameter is a string which identifies the name of the "
"signal to connect to. However, the format of this string is structured to "
"look like <emphasis>signal_name::detail_name</emphasis>. Connecting to the "
"signal named <emphasis>notify::cursor_position</emphasis> will actually "
"connect to the signal named <emphasis>notify</emphasis> with the "
"<emphasis>cursor_position</emphasis> name. Internally, the detail string is "
"transformed to a GQuark if it is present."
msgstr ""

#: tut_gsignal.xml:437(para)
msgid ""
"A GQuark is an integer which uniquely represents a string. It is possible to "
"transform back and forth between the integer and string representations with "
"the functions <function><link linkend=\"g-quark-from-string"
"\">g_quark_from_string</link></function> and <function><link linkend=\"g-"
"quark-to-string\">g_quark_to_string</link></function>."
msgstr ""

#: tut_gsignal.xml:442(programlisting)
#, no-wrap
msgid ""
"\n"
"gulong     g_signal_connect_closure_by_id          (gpointer          instance,\n"
"                           guint          signal_id,\n"
"                           GQuark          detail,\n"
"                           GClosure         *closure,\n"
"                           gboolean          after);\n"
msgstr ""

#: tut_gsignal.xml:450(programlisting)
#, no-wrap
msgid ""
"\n"
"gulong     g_signal_connect_closure          (gpointer          instance,\n"
"                           const gchar       *detailed_signal,\n"
"                           GClosure         *closure,\n"
"                           gboolean          after);\n"
"gulong     g_signal_connect_data              (gpointer          instance,\n"
"                           const gchar     *detailed_signal,\n"
"                           GCallback      c_handler,\n"
"                           gpointer          data,\n"
"                           GClosureNotify      destroy_data,\n"
"                           GConnectFlags      connect_flags);\n"
msgstr ""

#: tut_gsignal.xml:470(para)
msgid ""
"Of the four main signal emission functions, three have an explicit detail "
"parameter as a <link linkend=\"GQuark\"><type>GQuark</type></link> again: "
"<placeholder-1/> The fourth function hides it in its signal name parameter: "
"<placeholder-2/> The format of the detailed_signal parameter is exactly the "
"same as the format used by the <function><link linkend=\"g-signal-connect"
"\">g_signal_connect</link></function> functions: <emphasis>signal_name::"
"detail_name</emphasis>."
msgstr ""

#: tut_gsignal.xml:473(programlisting)
#, no-wrap
msgid ""
"\n"
"void                  g_signal_emitv        (const GValue       *instance_and_params,\n"
"                         guint               signal_id,\n"
"                         GQuark              detail,\n"
"                         GValue             *return_value);\n"
"void                  g_signal_emit_valist  (gpointer            instance,\n"
"                         guint               signal_id,\n"
"                         GQuark              detail,\n"
"                         va_list             var_args);\n"
"void                  g_signal_emit         (gpointer            instance,\n"
"                         guint               signal_id,\n"
"                         GQuark              detail,\n"
"                         ...);\n"
msgstr ""

#: tut_gsignal.xml:48(para)
msgid ""
"A <link linkend=\"GClosure\"><type>GClosure</type></link> provides simple "
"services: <placeholder-1/>"
msgstr ""

#: tut_gsignal.xml:488(programlisting)
#, no-wrap
msgid ""
"\n"
"void                  g_signal_emit_by_name (gpointer            instance,\n"
"                         const gchar        *detailed_signal,\n"
"                         ...);\n"
msgstr ""

#: tut_gsignal.xml:497(para)
msgid ""
"If a detail is provided by the user to the emission function, it is used "
"during emission to match against the closures which also provide a detail. "
"If the closures' detail does not match the detail provided by the user, they "
"will not be invoked (even though they are connected to a signal which is "
"being emitted)."
msgstr ""

#: tut_gsignal.xml:504(para)
msgid ""
"This completely optional filtering mechanism is mainly used as an "
"optimization for signals which are often emitted for many different reasons: "
"the clients can filter out which events they are interested in before the "
"closure's marshalling code runs. For example, this is used extensively by "
"the <emphasis>notify</emphasis> signal of GObject: whenever a property is "
"modified on a GObject, instead of just emitting the <emphasis>notify</"
"emphasis> signal, GObject associates as a detail to this signal emission the "
"name of the property modified. This allows clients who wish to be notified "
"of changes to only one property to filter most events before receiving them."
msgstr ""

#: tut_gsignal.xml:51(para)
msgid ""
"Invocation (<function><link linkend=\"g-closure-invoke\">g_closure_invoke</"
"link></function>): this is what closures were created for: they hide the "
"details of callback invocation from the callback invoker."
msgstr ""

#: tut_gsignal.xml:514(para)
msgid ""
"As a simple rule, users can and should set the detail parameter to zero: "
"this will disable completely this optional filtering."
msgstr ""

#: tut_gsignal.xml:56(para)
msgid ""
"Notification: the closure notifies listeners of certain events such as "
"closure invocation, closure invalidation and closure finalization. Listeners "
"can be registered with <function><link linkend=\"g-closure-add-finalize-"
"notifier\">g_closure_add_finalize_notifier</link></function> (finalization "
"notification), <function><link linkend=\"g-closure-add-invalidate-notifier"
"\">g_closure_add_invalidate_notifier</link></function> (invalidation "
"notification) and <function><link linkend=\"g-closure-add-marshal-guards"
"\">g_closure_add_marshal_guards</link></function> (invocation notification). "
"There exist symmetric deregistration functions for finalization and "
"invalidation events (<function><link linkend=\"g-closure-remove-finalize-"
"notifier\">g_closure_remove_finalize_notifier</link></function> and "
"<function><link linkend=\"g-closure-remove-invalidate-notifier"
"\">g_closure_remove_invalidate_notifier</link></function>) but not for the "
"invocation process. <placeholder-1/>"
msgstr ""

#: tut_gsignal.xml:6(title)
msgid "The GObject messaging system"
msgstr ""

#: tut_gsignal.xml:67(para)
msgid ""
"Closures are reference counted and notify listeners of their destruction in "
"a two-stage process: the invalidation notifiers are invoked before the "
"finalization notifiers."
msgstr ""

#: tut_gsignal.xml:76(title)
msgid "C Closures"
msgstr ""

#: tut_gsignal.xml:78(para)
msgid ""
"If you are using C or C++ to connect a callback to a given event, you will "
"either use simple <link linkend=\"GCClosure\"><type>GCClosure</type></link>s "
"which have a pretty minimal API or the even simpler <function><link linkend="
"\"g-signal-connect\">g_signal_connect</link></function> functions (which "
"will be presented a bit later :). <placeholder-1/>"
msgstr ""

#: tut_gsignal.xml:83(programlisting)
#, no-wrap
msgid ""
"\n"
"GClosure *g_cclosure_new             (GCallback      callback_func,\n"
"                                      gpointer       user_data,\n"
"                                      GClosureNotify destroy_data);\n"
"GClosure *g_cclosure_new_swap        (GCallback      callback_func,\n"
"                                      gpointer       user_data,\n"
"                                      GClosureNotify destroy_data);\n"
"GClosure *g_signal_type_cclosure_new (GType          itype,\n"
"                                      guint          struct_offset);\n"
msgstr ""

#: tut_gsignal.xml:9(title)
msgid "Closures"
msgstr ""

#: tut_gsignal.xml:95(para)
msgid ""
"<function><link linkend=\"g-cclosure-new\">g_cclosure_new</link></function> "
"will create a new closure which can invoke the user-provided callback_func "
"with the user-provided user_data as last parameter. When the closure is "
"finalized (second stage of the destruction process), it will invoke the "
"destroy_data function if the user has supplied one."
msgstr ""

#: tut_gtype.xml:102(para)
msgid ""
"type characteristic flags: <link linkend=\"GTypeFlags\"><type>GTypeFlags</"
"type></link>."
msgstr ""
"类的字符标志：<link linkend=\"GTypeFlags\"><type>GTypeFlags</type></link>。"

#: tut_gtype.xml:114(title)
msgid "Copy functions"
msgstr "复制函数"

#: tut_gtype.xml:116(para)
msgid ""
"The major common point between <emphasis>all</emphasis> GLib types "
"(fundamental and non-fundamental, classed and non-classed, instantiable and "
"non-instantiable) is that they can all be manipulated through a single API "
"to copy/assign them."
msgstr ""
"所有的 Glib 类型（基本和非基本，类化和非类化， 可实例化和不可实例化）的最大共"
"同点是都可以通过单一的 API 来复制或指定它们。"

#: tut_gtype.xml:12(programlisting)
#, no-wrap
msgid ""
"\n"
"typedef struct _GTypeInfo               GTypeInfo;\n"
"struct _GTypeInfo\n"
"{\n"
"  /* interface types, classed types, instantiated types */\n"
"  guint16                class_size;\n"
"  \n"
"  GBaseInitFunc          base_init;\n"
"  GBaseFinalizeFunc      base_finalize;\n"
"  \n"
"  /* classed types, instantiated types */\n"
"  GClassInitFunc         class_init;\n"
"  GClassFinalizeFunc     class_finalize;\n"
"  gconstpointer          class_data;\n"
"  \n"
"  /* instantiated types */\n"
"  guint16                instance_size;\n"
"  guint16                n_preallocs;\n"
"  GInstanceInitFunc      instance_init;\n"
"  \n"
"  /* value handling */\n"
"  const GTypeValueTable *value_table;\n"
"};\n"
"GType g_type_register_static (GType             parent_type,\n"
"                              const gchar      *type_name,\n"
"                              const GTypeInfo  *info,\n"
"                              GTypeFlags        flags);\n"
"GType g_type_register_fundamental (GType                       type_id,\n"
"                                   const gchar                *type_name,\n"
"                                   const GTypeInfo            *info,\n"
"                                   const GTypeFundamentalInfo *finfo,\n"
"                                   GTypeFlags                  flags);\n"
"        "
msgstr ""

#: tut_gtype.xml:122(para)
msgid ""
"The <link linkend=\"GValue\"><type>GValue</type></link> structure is used as "
"an abstract container for all of these types. Its simplistic API (defined in "
"<filename>gobject/gvalue.h</filename>) can be used to invoke the value_table "
"functions registered during type registration: for example <function><link "
"linkend=\"g-value-copy\">g_value_copy</link></function> copies the content "
"of a <link linkend=\"GValue\"><type>GValue</type></link> to another <link "
"linkend=\"GValue\"><type>GValue</type></link>. This is similar to a C++ "
"assignment which invokes the C++ copy operator to modify the default bit-by-"
"bit copy semantics of C++/C structures/classes."
msgstr ""
"<link linkend=\"GValue\"><type>GValue</type></link>结构被用作所有类型的抽象的"
"容器， 它的极度简化的 API（定义在 <filename>gobject/gvalue.h</filename>）可以"
"被使用请求 value_table 函数被注册当类型注册中： 举个例子，<function><link "
"linkend=\"g-value-copy\">g_value_copy</link></function> 复制了 <link linkend="
"\"GValue\"><type>GValue</type></link>的内容至另一个<link linkend=\"GValue"
"\"><type>GValue</type></link>。 这与 C++ 指派它的复制操作来修改默认的按位复"
"制 C++/C 结构是类似的。"

#: tut_gtype.xml:132(para)
msgid ""
"The following code shows how you can copy around a 64 bit integer, as well "
"as a <link linkend=\"GObject\"><type>GObject</type></link> instance pointer "
"(sample code for this is located in the source tarball for this document in "
"<filename>sample/gtype/test.c</filename>): <placeholder-1/> The important "
"point about the above code is that the exact semantics of the copy calls is "
"undefined since they depend on the implementation of the copy function. "
"Certain copy functions might decide to allocate a new chunk of memory and "
"then to copy the data from the source to the destination. Others might want "
"to simply increment the reference count of the instance and copy the "
"reference to the new GValue."
msgstr ""
"下面的代码向你展示了你是如何复制一个64位的整型，同样 <link linkend=\"GObject"
"\"><type>GObject</type></link> 的实例指针也是这样（代码在<filename>sample/"
"gtype/test.c</filename>中）： <placeholder-1/> 上面代码的重点是关于复制指令的"
"确切语义，并没有详细的定义复制是如何实现的。 复制函数的实现可能是决定请求一新"
"块的内存，并把数据从源复制到目的。 或者可能是简单的增加实例的引用数和复制引用"
"至新的 GValue。"

#: tut_gtype.xml:136(programlisting)
#, no-wrap
msgid ""
"\n"
"static void test_int (void)\n"
"{\n"
"  GValue a_value = {0, }; \n"
"  GValue b_value = {0, };\n"
"  guint64 a, b;\n"
"\n"
"  a = 0xdeadbeaf;\n"
"\n"
"  g_value_init (&amp;a_value, G_TYPE_UINT64);\n"
"  g_value_set_uint64 (&amp;a_value, a);\n"
"\n"
"  g_value_init (&amp;b_value, G_TYPE_UINT64);\n"
"  g_value_copy (&amp;a_value, &amp;b_value);\n"
"\n"
"  b = g_value_get_uint64 (&amp;b_value);\n"
"\n"
"  if (a == b) {\n"
"    g_print (\"Yay !! 10 lines of code to copy around a uint64.\\n\");\n"
"  } else {\n"
"    g_print (\"Are you sure this is not a Z80 ?\\n\");\n"
"  }\n"
"}\n"
"\n"
"static void test_object (void)\n"
"{\n"
"  GObject *obj;\n"
"  GValue obj_vala = {0, };\n"
"  GValue obj_valb = {0, };\n"
"  obj = g_object_new (MAMAN_TYPE_BAR, NULL);\n"
"\n"
"  g_value_init (&amp;obj_vala, MAMAN_TYPE_BAR);\n"
"  g_value_set_object (&amp;obj_vala, obj);\n"
"\n"
"  g_value_init (&amp;obj_valb, G_TYPE_OBJECT);\n"
"\n"
"  /* g_value_copy's semantics for G_TYPE_OBJECT types is to copy the reference.\n"
"     This function thus calls g_object_ref.\n"
"     It is interesting to note that the assignment works here because\n"
"     MAMAN_TYPE_BAR is a G_TYPE_OBJECT.\n"
"   */\n"
"  g_value_copy (&amp;obj_vala, &amp;obj_valb);\n"
"\n"
"  g_object_unref (G_OBJECT (obj));\n"
"  g_object_unref (G_OBJECT (obj));\n"
"}\n"
msgstr ""

#: tut_gtype.xml:190(para)
msgid ""
"The value_table used to specify these assignment functions is defined in "
"<filename>gtype.h</filename> and is thoroughly described in the API "
"documentation provided with GObject (for once ;-) which is why we will not "
"detail its exact semantics. <placeholder-1/> Interestingly, it is also very "
"unlikely you will ever need to specify a value_table during type "
"registration because these value_tables are inherited from the parent types "
"for non-fundamental types which means that unless you want to write a "
"fundamental type (not a great idea!), you will not need to provide a new "
"value_table since you will inherit the value_table structure from your "
"parent type."
msgstr ""
"value_table 用于详细说明这些定义在 <filename>gtype.h</filename> 的函数的使用"
"并彻底地描述在由 GObject 提供的API文档中，这是为什么我们不追究细节的原因。 "
"<placeholder-1/> 有趣的是，你同样不需要详细指定一个 value_table 在注册过程"
"中， 因为 value_tables 一般从非基本类型的父类中继承，这意味着除非你想写一个基"
"本类型， 否则你将不需要提供一个新的 value_table 因为它可以从父类继承 "
"value_table。"

#: tut_gtype.xml:195(programlisting)
#, no-wrap
msgid ""
"\n"
"typedef struct _GTypeValueTable         GTypeValueTable;\n"
"struct _GTypeValueTable\n"
"{\n"
"  void     (*value_init)         (GValue       *value);\n"
"  void     (*value_free)         (GValue       *value);\n"
"  void     (*value_copy)         (const GValue *src_value,\n"
"                                  GValue       *dest_value);\n"
"  /* varargs functionality (optional) */\n"
"  gpointer (*value_peek_pointer) (const GValue *value);\n"
"  gchar            *collect_format;\n"
"  gchar*   (*collect_value)      (GValue       *value,\n"
"                                  guint         n_collect_values,\n"
"                                  GTypeCValue  *collect_values,\n"
"                                  guint                collect_flags);\n"
"  gchar            *lcopy_format;\n"
"  gchar*   (*lcopy_value)        (const GValue *value,\n"
"                                  guint         n_collect_values,\n"
"                                  GTypeCValue  *collect_values,\n"
"                                  guint                collect_flags);\n"
"};\n"
"          "
msgstr ""

#: tut_gtype.xml:228(title)
msgid "Conventions"
msgstr "约定"

#: tut_gtype.xml:231(para)
msgid ""
"There are a number of conventions users are expected to follow when creating "
"new types which are to be exported in a header file: <placeholder-1/> The "
"implementation of these macros is pretty straightforward: a number of simple-"
"to-use macros are provided in <filename>gtype.h</filename>. For the example "
"we used above, we would write the following trivial code to declare the "
"macros: <placeholder-2/><placeholder-3/>"
msgstr ""
"当用户在头文件中创建新类型时，有一些规范用户需要注意： <placeholder-1/> 至于"
"这些宏的实现是非常直观的： 一些数量的简单使用的宏由<filename>gtype.h</"
"filename>提供。 针对上面我们兴趣的例子，我们写了下面的代码来声明这些宏： "
"<placeholder-2/><placeholder-3/>"

#: tut_gtype.xml:235(para)
msgid ""
"Use the <function>object_method</function> pattern for function names: to "
"invoke the method named foo on an instance of object type bar, call "
"<function>bar_foo</function>."
msgstr ""
"使用 <function>object_method</function>的形式来定义函数名称： 例如在一个 bar "
"类中定义一个名为 foo 的函数，则用 <function>bar_foo</function> 。"

#: tut_gtype.xml:240(para)
msgid ""
"Use prefixing to avoid namespace conflicts with other projects. If your "
"library (or application) is named <emphasis>Maman</emphasis>, <placeholder-1/"
"> prefix all your function names with <emphasis>maman_</emphasis>. For "
"example: <function>maman_object_method</function>."
msgstr ""
"使用前缀来避免与其他工程的命名空间冲突。 如果你的库（或应用程序）名为 "
"<emphasis>Maman</emphasis>， <placeholder-1/> 那么所有的函数名称前缀为"
"<emphasis>maman_</emphasis>。 举例: <function>maman_object_method</function>."

#: tut_gtype.xml:243(para)
msgid ""
"<emphasis>Maman</emphasis> is the French word for <emphasis>mum</emphasis> "
"or <emphasis>mother</emphasis> - nothing more and nothing less."
msgstr ""
"<emphasis>Maman</emphasis>在法语中是<emphasis>妈妈</emphasis> 或<emphasis>母"
"亲</emphasis>的意思 - 仅此而已。"

#: tut_gtype.xml:252(para)
msgid ""
"Create a macro named <function>PREFIX_TYPE_OBJECT</function> which always "
"returns the GType for the associated object type. For an object of type "
"<emphasis>Bar</emphasis> in a library prefixed by <emphasis>maman</"
"emphasis>, use: <function>MAMAN_TYPE_BAR</function>. It is common although "
"not a convention to implement this macro using either a global static "
"variable or a function named <function>prefix_object_get_type</function>. We "
"will follow the function pattern wherever possible in this document."
msgstr ""
"创建一个宏命为 <function>PREFIX_TYPE_OBJECT</function>用来返回 GType 关联的对"
"象类型。 比如，<emphasis>Bar</emphasis>这个类在一个以 <emphasis>maman</"
"emphasis>前缀的库中，则使用 <function>MAMAN_TYPE_BAR</function>。 另有一个不"
"成文的规定是，定义一个使用全局静态变或一个名为"
"<function>prefix_object_get_type</function> 的函数来实现这个宏。我们将在后面"
"的章节中讨论这个函数。"

#: tut_gtype.xml:260(para)
msgid ""
"Create a macro named <function>PREFIX_OBJECT (obj)</function> which returns "
"a pointer of type <type>PrefixObject</type>. This macro is used to enforce "
"static type safety by doing explicit casts wherever needed. It also enforces "
"dynamic type safety by doing runtime checks. It is possible to disable the "
"dynamic type checks in production builds (see <link linkend=\"glib-building"
"\">building glib</link>). For example, we would create <function>MAMAN_BAR "
"(obj)</function> to keep the previous example."
msgstr ""
"创建一个宏命名为 <function>PREFIX_OBJECT (obj)</function> 来返回一个指向"
"<type>PrefixObject</type> 类型的指针。 这个宏用于必要时安全地强制转换一个静态"
"类型。 运行环境检查时，同样也是安全地执行动态类型。 在编译glib时是可以禁止动"
"态类型检查的（参见：<link linkend=\"glib-building\">编译glib</link>）。 在处"
"理过程中禁用动态类型检查是可行的。 例如，我们可以创建 MAMAN_BAR(obj) 来保持先"
"前的例子。"

#: tut_gtype.xml:268(para)
msgid ""
"If the type is classed, create a macro named <function>PREFIX_OBJECT_CLASS "
"(klass)</function>. This macro is strictly equivalent to the previous "
"casting macro: it does static casting with dynamic type checking of class "
"structures. It is expected to return a pointer to a class structure of type "
"<type>PrefixObjectClass</type>. Again, an example is: "
"<function>MAMAN_BAR_CLASS</function>."
msgstr ""
"如果类型是类化的，那么创建一个命令为 <function>PREFIX_OBJECT_CLASS (klass)</"
"function>的宏。 这个宏与前面那个是非常相似的： 它以类结构的动态类型检查来进行"
"静态转换，并返回一个指向 <type>PrefixObjectClass</type> 这个类型的类结构的指"
"针。 同样，例子为：<function>MAMAN_BAR_CLASS</function>。"

#: tut_gtype.xml:275(para)
msgid ""
"Create a macro named <function>PREFIX_IS_BAR (obj)</function>: this macro is "
"expected to return a <type>gboolean</type> which indicates whether or not "
"the input object instance pointer of type BAR."
msgstr ""
"创建一个宏命名为<function>PREFIX_IS_BAR (obj)</function>： 这个宏的返回值是 "
"<type>gboolean</type> 类型的，用于判断输入的对象实例是否是 BAR类型的。"

#: tut_gtype.xml:279(para)
msgid ""
"If the type is classed, create a macro named "
"<function>PREFIX_IS_OBJECT_CLASS (klass)</function> which, as above, returns "
"a boolean if the input class pointer is a pointer to a class of type OBJECT."
msgstr ""
"如果类型是类化的，创建一个名为 <function>PREFIX_IS_OBJECT_CLASS (klass)</"
"function> 的宏，与上面的类似，返回输入的类型指针是否是 OBJECT 类型。"

#: tut_gtype.xml:283(para)
msgid ""
"If the type is classed, create a macro named "
"<function>PREFIX_OBJECT_GET_CLASS (obj)</function> which returns the class "
"pointer associated to an instance of a given type. This macro is used for "
"static and dynamic type safety purposes (just like the previous casting "
"macros)."
msgstr ""
"如果类型是类化的，创建一个名为<function>PREFIX_OBJECT_GET_CLASS (obj)</"
"function>，返回一个实例所属的类的类型指针。 这个宏因为安全的原因，被静态和动"
"态类型所使用，就像上面的转换宏一样。"

#: tut_gtype.xml:293(programlisting)
#, no-wrap
msgid ""
"\n"
"#define MAMAN_TYPE_BAR                  (maman_bar_get_type ())\n"
"#define MAMAN_BAR(obj)                  (G_TYPE_CHECK_INSTANCE_CAST ((obj), MAMAN_TYPE_BAR, MamanBar))\n"
"#define MAMAN_BAR_CLASS(klass)          (G_TYPE_CHECK_CLASS_CAST ((klass), MAMAN_TYPE_BAR, MamanBarClass))\n"
"#define MAMAN_IS_BAR(obj)          (G_TYPE_CHECK_INSTANCE_TYPE ((obj), MAMAN_TYPE_BAR))\n"
"#define MAMAN_IS_BAR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), MAMAN_TYPE_BAR))\n"
"#define MAMAN_BAR_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), MAMAN_TYPE_BAR, MamanBarClass))\n"
msgstr ""

#: tut_gtype.xml:301(simpara)
msgid ""
"Stick to the naming <varname>klass</varname> as <varname>class</varname> is "
"a registered c++ keyword."
msgstr ""
"这里使用<varname>klass</varname>这个名字，是因为 <varname>class</varname>已经"
"被注册为 c++ 的关键字了。"

#: tut_gtype.xml:304(para)
msgid ""
"The following code shows how to implement the <function>maman_bar_get_type</"
"function> function: <placeholder-1/>"
msgstr ""
"下面的代码实现了<function>maman_bar_get_type</function>这个函数： "
"<placeholder-1/>"

#: tut_gtype.xml:307(programlisting)
#, no-wrap
msgid ""
"\n"
"GType maman_bar_get_type (void)\n"
"{\n"
"  static GType type = 0;\n"
"  if (type == 0) {\n"
"    static const GTypeInfo info = {\n"
"      /* You fill this structure. */\n"
"    };\n"
"    type = g_type_register_static (G_TYPE_OBJECT,\n"
"                                   \"MamanBarType\",\n"
"                                   &amp;info, 0);\n"
"  }\n"
"  return type;\n"
"}\n"
msgstr ""

#: tut_gtype.xml:324(para)
msgid ""
"When having no special requirements you also can use the "
"<function>G_DEFINE_TYPE</function> macro: <placeholder-1/>"
msgstr ""
"如果没有特别需要，你也可以使用<function>G_DEFINE_TYPE</function> 宏： "
"<placeholder-1/>"

#: tut_gtype.xml:327(programlisting)
#, no-wrap
msgid ""
"\n"
"G_DEFINE_TYPE (MamanBar, maman_bar, G_TYPE_OBJECT)\n"
msgstr ""

#: tut_gtype.xml:335(title)
msgid "Non-instantiable non-classed fundamental types"
msgstr "不可实例化和不可类化的基础类型"

#: tut_gtype.xml:337(para)
msgid ""
"A lot of types are not instantiable by the type system and do not have a "
"class. Most of these types are fundamental trivial types such as "
"<emphasis>gchar</emphasis>, registered in <function>g_value_types_init</"
"function> (in <filename>gvaluetypes.c</filename>)."
msgstr ""
"在类型系统中，许多类型是不可实例化而且没有父类的。 大多数这些类型是最基础的基"
"本类型，如<emphasis>gchar</emphasis>，它由<function>g_value_types_init</"
"function>注册（在<filename>gvaluetypes.c</filename>中）。"

#: tut_gtype.xml:343(para)
msgid ""
"To register such a type in the type system, you just need to fill the <link "
"linkend=\"GTypeInfo\"><type>GTypeInfo</type></link> structure with zeros "
"since these types are also most of the time fundamental: <placeholder-1/>"
msgstr ""
"如果想在类型系统中注册这样一个类型，你仅仅需要用 0 来填充<link linkend="
"\"GTypeInfo\"><type>GTypeInfo</type></link>结构。 <placeholder-1/>"

#: tut_gtype.xml:347(programlisting)
#, no-wrap
msgid ""
"\n"
"  GTypeInfo info = {\n"
"    0,                                /* class_size */\n"
"    NULL,                        /* base_init */\n"
"    NULL,                        /* base_destroy */\n"
"    NULL,                        /* class_init */\n"
"    NULL,                        /* class_destroy */\n"
"    NULL,                        /* class_data */\n"
"    0,                                /* instance_size */\n"
"    0,                                /* n_preallocs */\n"
"    NULL,                        /* instance_init */\n"
"    NULL,                        /* value_table */\n"
"  };\n"
"  static const GTypeValueTable value_table = {\n"
"    value_init_long0,                /* value_init */\n"
"    NULL,                        /* value_free */\n"
"    value_copy_long0,                /* value_copy */\n"
"    NULL,                        /* value_peek_pointer */\n"
"    \"i\",                        /* collect_format */\n"
"    value_collect_int,        /* collect_value */\n"
"    \"p\",                        /* lcopy_format */\n"
"    value_lcopy_char,                /* lcopy_value */\n"
"  };\n"
"  info.value_table = &amp;value_table;\n"
"  type = g_type_register_fundamental (G_TYPE_CHAR, \"gchar\", &amp;info, &amp;finfo, 0);\n"
"          "
msgstr ""

#: tut_gtype.xml:376(para)
msgid ""
"Having non-instantiable types might seem a bit useless: what good is a type "
"if you cannot instantiate an instance of that type ? Most of these types are "
"used in conjunction with <link linkend=\"GValue\"><type>GValue</type></"
"link>s: a GValue is initialized with an integer or a string and it is passed "
"around by using the registered type's value_table. <link linkend=\"GValue"
"\"><type>GValue</type></link>s (and by extension these trivial fundamental "
"types) are most useful when used in conjunction with object properties and "
"signals."
msgstr ""
"使用不可实例的类型似乎是无用的： 定义一个不能实例化的类型有什么好处呢？ 大多"
"数这种类型与 <link linkend=\"GValue\"><type>GValue</type></link>用作一块： 一"
"个GValue由一个整型或一个字符串来初始化， 再被传递了一个已注册类型的 "
"value_table 。 <link linkend=\"GValue\"><type>GValue</type></link>（以基本类"
"型延伸）最有用的时候是在与对象的属性和信号用在一块时。"

#: tut_gtype.xml:388(title)
msgid "Instantiable classed types: objects"
msgstr "可实例化的类型：object"

#: tut_gtype.xml:390(para)
msgid ""
"Types which are registered with a class and are declared instantiable are "
"what most closely resembles an <emphasis>object</emphasis>. Although <link "
"linkend=\"GObject\"><type>GObject</type></link>s (detailed in <xref linkend="
"\"chapter-gobject\"/>) are the most well known type of instantiable classed "
"types, other kinds of similar objects used as the base of an inheritance "
"hierarchy have been externally developed and they are all built on the "
"fundamental features described below."
msgstr ""
"一个以类来注册，并声明为可实例化的类型常常称作<emphasis>object</emphasis>。 "
"<link linkend=\"GObject\"><type>GObject</type></link>（详见：<xref linkend="
"\"chapter-gobject\"/> 中）是最有名的一个可实例化的类了， 其他相似的类都继承于"
"这个基本类来进行开发，他们都基于下面所述的基本特征。"

#: tut_gtype.xml:400(para)
msgid ""
"For example, the code below shows how you could register such a fundamental "
"object type in the type system: <placeholder-1/> Upon the first call to "
"<function>maman_bar_get_type</function>, the type named <emphasis>BarType</"
"emphasis> will be registered in the type system as inheriting from the type "
"<emphasis>G_TYPE_OBJECT</emphasis>."
msgstr ""
"下面的例子告诉你怎样才可以在类型系统中注册这样一个基本的类: <placeholder-1/> "
"在调用<function>maman_bar_get_type</function>之前， 名为<emphasis>BarType</"
"emphasis>的继承于<emphasis>G_TYPE_OBJECT</emphasis>的类将在类型系统中被注册。"

#: tut_gtype.xml:403(programlisting)
#, no-wrap
msgid ""
"\n"
"typedef struct {\n"
"  GObject parent;\n"
"  /* instance members */\n"
"  int field_a;\n"
"} MamanBar;\n"
"\n"
"typedef struct {\n"
"  GObjectClass parent;\n"
"  /* class members */\n"
"  void (*do_action_public_virtual) (MamanBar *self, guint8 i);\n"
"\n"
"  void (*do_action_public_pure_virtual) (MamanBar *self, guint8 i);\n"
"} MamanBarClass;\n"
"\n"
"#define MAMAN_TYPE_BAR (maman_bar_get_type ())\n"
"\n"
"GType \n"
"maman_bar_get_type (void)\n"
"{\n"
"  static GType type = 0;\n"
"  if (type == 0) {\n"
"    static const GTypeInfo info = {\n"
"      sizeof (MamanBarClass),\n"
"      NULL,           /* base_init */\n"
"      NULL,           /* base_finalize */\n"
"      (GClassInitFunc) foo_class_init,\n"
"      NULL,           /* class_finalize */\n"
"      NULL,           /* class_data */\n"
"      sizeof (MamanBar),\n"
"      0,              /* n_preallocs */\n"
"      (GInstanceInitFunc) NULL /* instance_init */\n"
"    };\n"
"    type = g_type_register_static (G_TYPE_OBJECT,\n"
"                                   \"BarType\",\n"
"                                   &amp;info, 0);\n"
"  }\n"
"  return type;\n"
"}\n"
msgstr ""

#: tut_gtype.xml:448(para)
msgid ""
"Every object must define two structures: its class structure and its "
"instance structure. All class structures must contain as first member a "
"<link linkend=\"GTypeClass\"><type>GTypeClass</type></link> structure. All "
"instance structures must contain as first member a <link linkend="
"\"GTypeInstance\"><type>GTypeInstance</type></link> structure. The "
"declaration of these C types, coming from <filename>gtype.h</filename> is "
"shown below: <placeholder-1/> These constraints allow the type system to "
"make sure that every object instance (identified by a pointer to the "
"object's instance structure) contains in its first bytes a pointer to the "
"object's class structure."
msgstr ""
"每个对象必须定义为两个结构：它的类结构和它的实例结构。 所有的类结构的第一个成"
"员必须是一个<link linkend=\"GTypeClass\"><type>GTypeClass</type></link> 结"
"构。 所有的实例结构的第一个成员必须是 <link linkend=\"GTypeInstance"
"\"><type>GTypeInstance</type></link>结构。 下面显示了这些来自<filename>gtype."
"h</filename> 的 C 类型的声明： <placeholder-1/> 这些约束使得类型系统可以确保"
"每个对象的实例(由指向该对象的实例结构的指针所标识) 的首字节指向该对象的类结"
"构。"

#: tut_gtype.xml:454(programlisting)
#, no-wrap
msgid ""
"\n"
"struct _GTypeClass\n"
"{\n"
"  GType g_type;\n"
"};\n"
"struct _GTypeInstance\n"
"{\n"
"  GTypeClass *g_class;\n"
"};\n"
msgstr ""

#: tut_gtype.xml:468(para)
#, fuzzy
msgid ""
"This relationship is best explained by an example: let's take object B which "
"inherits from object A: <placeholder-1/> The C standard mandates that the "
"first field of a C structure is stored starting in the first byte of the "
"buffer used to hold the structure's fields in memory. This means that the "
"first field of an instance of an object B is A's first field which in turn "
"is GTypeInstance's first field which in turn is g_class, a pointer to B's "
"class structure."
msgstr ""
"这个关系可以由下面的例子来很好的解释：让我们来看看这个继承于对象A的对象B： "
"<placeholder-1/> 上述标准的C结构定义指示了这个C结构的第一个领域存储着类的结"
"构。"

#: tut_gtype.xml:47(para)
msgid ""
"<function><link linkend=\"g-type-register-static\">g_type_register_static</"
"link></function> and <function><link linkend=\"g-type-register-fundamental"
"\">g_type_register_fundamental</link></function> are the C functions, "
"defined in <filename>gtype.h</filename> and implemented in <filename>gtype."
"c</filename> which you should use to register a new <link linkend=\"GType"
"\"><type>GType</type></link> in the program's type system. It is not likely "
"you will ever need to use <function><link linkend=\"g-type-register-"
"fundamental\">g_type_register_fundamental</link></function> (you have to be "
"Tim Janik to do that) but in case you want to, the last chapter explains how "
"to create new fundamental types. <placeholder-1/>"
msgstr ""
"<function><link linkend=\"g-type-register-static\">g_type_register_static</"
"link></function> 和 <function><link linkend=\"g-type-register-fundamental"
"\">g_type_register_fundamental</link></function> 这两个C函数定义在"
"<filename>gtype.h</filename> 中，并在<filename>gtype.c</filename> 中具体实"
"现。 你可以用来在程序的类型系统中注册一个新的 <link linkend=\"GType"
"\"><type>GType</type></link>。 一般情况下你永远也不需要使用 <function><link "
"linkend=\"g-type-register-fundamental\">g_type_register_fundamental</link></"
"function> （除非你是Tim Janik才会这样做），但是这次你要做，在最后一章会向你解"
"释如何创建一个基本类型。 <placeholder-1/>"

#: tut_gtype.xml:471(programlisting)
#, no-wrap
msgid ""
"\n"
"/* A definitions */\n"
"typedef struct {\n"
"  GTypeInstance parent;\n"
"  int field_a;\n"
"  int field_b;\n"
"} A;\n"
"typedef struct {\n"
"  GTypeClass parent_class;\n"
"  void (*method_a) (void);\n"
"  void (*method_b) (void);\n"
"} AClass;\n"
"\n"
"/* B definitions. */\n"
"typedef struct {\n"
"  A parent;\n"
"  int field_c;\n"
"  int field_d;\n"
"} B;\n"
"typedef struct {\n"
"  AClass parent_class;\n"
"  void (*method_c) (void);\n"
"  void (*method_d) (void);\n"
"} BClass;\n"
msgstr ""

#: tut_gtype.xml:503(para)
msgid ""
"Thanks to these simple conditions, it is possible to detect the type of "
"every object instance by doing: <placeholder-1/> or, more quickly: "
"<placeholder-2/>"
msgstr ""
"多亏了这些简单的条件，所以按下面的方法来就可能取得每个对象实例的类型： "
"<placeholder-1/> 或者，更快的： <placeholder-2/>"

#: tut_gtype.xml:506(programlisting)
#, no-wrap
msgid ""
"\n"
"B *b;\n"
"b-&gt;parent.parent.g_class-&gt;g_type\n"
msgstr ""

#: tut_gtype.xml:511(programlisting)
#, no-wrap
msgid ""
"\n"
"B *b;\n"
"((GTypeInstance*)b)-&gt;g_class-&gt;g_type\n"
msgstr ""

#: tut_gtype.xml:518(title)
msgid "Initialization and Destruction"
msgstr "初始化和销毁"

#: tut_gtype.xml:520(para)
msgid ""
"instantiation of these types can be done with <function><link linkend=\"g-"
"type-create-instance\">g_type_create_instance</link></function>: "
"<placeholder-1/><function><link linkend=\"g-type-create-instance"
"\">g_type_create_instance</link></function> will look up the type "
"information structure associated to the type requested. Then, the instance "
"size and instantiation policy (if the n_preallocs field is set to a non-zero "
"value, the type system allocates the object's instance structures in chunks "
"rather than mallocing for every instance) declared by the user are used to "
"get a buffer to hold the object's instance structure."
msgstr ""
"实例化这些类型可以用 <function><link linkend=\"g-type-create-instance"
"\">g_type_create_instance</link></function>来完成： <placeholder-1/"
"><function><link linkend=\"g-type-create-instance\">g_type_create_instance</"
"link></function> 将查找请求的类型所关联的类型信息结构。 然后由用户声明的实例"
"的大小和实例化策略（如果 n_preallocs 设置为一个非零值， 类型系统将会把对象的"
"实例结构分配在内存块上，而不将依次分配每个实例） 将得到一个缓存来保存对象实例"
"的结构。"

#: tut_gtype.xml:523(programlisting)
#, no-wrap
msgid ""
"\n"
"GTypeInstance* g_type_create_instance (GType          type);\n"
"void           g_type_free_instance   (GTypeInstance *instance);\n"
msgstr ""

#: tut_gtype.xml:535(para)
msgid ""
"If this is the first instance of the object ever created, the type system "
"must create a class structure: it allocates a buffer to hold the object's "
"class structure and initializes it. It first copies the parent's class "
"structure over this structure (if there is no parent, it initializes it to "
"zero). It then invokes the base_class_initialization functions (<link "
"linkend=\"GBaseInitFunc\"><type>GBaseInitFunc</type></link>) from topmost "
"fundamental object to bottom-most most derived object. The object's "
"class_init (<link linkend=\"GClassInitFunc\"><type>GClassInitFunc</type></"
"link>) function is invoked afterwards to complete initialization of the "
"class structure. Finally, the object's interfaces are initialized (we will "
"discuss interface initialization in more detail later)."
msgstr ""
"If this is the first instance of the object ever created, the type system "
"must create 如果实例是这个对象第一次创建的，那么类型系统必须创建一个类结构： "
"它为其分配一个缓冲来保存这个对象的类结构并初始化它。 它先用父类的类结构覆盖"
"（如果没有父类，它将初始化为零）， 然后从最顶层的基本对象至最底层的对象调用 "
"base_class_initialization 函数（<link linkend=\"GBaseInitFunc"
"\"><type>GBaseInitFunc</type></link>）。 对象的类初始化函数（<link linkend="
"\"GClassInitFunc\"><type>GClassInitFunc</type></link>）被调用来完成类结构的初"
"始化。 最终，这个类的接口被初始化了（我们将在后面讨论接口初始化）。"

#: tut_gtype.xml:548(para)
msgid ""
"Once the type system has a pointer to an initialized class structure, it "
"sets the object's instance class pointer to the object's class structure and "
"invokes the object's instance_init (<link linkend=\"GInstanceInitFunc"
"\"><type>GInstanceInitFunc</type></link>)functions, from top-most "
"fundamental type to bottom-most most derived type."
msgstr ""
"一旦类型系统有一个指向初始化的类结构的指针， 它设置对象的实例类指针指向对象的"
"类结构并调用实例的初始化函数（<link linkend=\"GInstanceInitFunc"
"\"><type>GInstanceInitFunc</type></link>）， 同样是从顶到底的顺序。"

#: tut_gtype.xml:555(para)
msgid ""
"Object instance destruction through <function><link linkend=\"g-type-free-"
"instance\">g_type_free_instance</link></function> is very simple: the "
"instance structure is returned to the instance pool if there is one and if "
"this was the last living instance of the object, the class is destroyed."
msgstr ""
"对象的实例的销毁非常简单，通过<function><link linkend=\"g-type-free-instance"
"\">g_type_free_instance</link></function>即可： 实例结构被返回到实例池中，如"
"果这是对象的还有一个而且是最后一个存活的实例，那么这个类即被摧毁。"

#: tut_gtype.xml:562(para)
msgid ""
"Class destruction (the concept of destruction is sometimes partly referred "
"to as finalization in GType) is the symmetric process of the initialization: "
"interfaces are destroyed first. Then, the most derived class_finalize (<link "
"linkend=\"ClassFinalizeFunc\"><type>ClassFinalizeFunc</type></link>) "
"function is invoked. The base_class_finalize (<link linkend="
"\"GBaseFinalizeFunc\"><type>GBaseFinalizeFunc</type></link>) functions are "
"Finally invoked from bottom-most most-derived type to top-most fundamental "
"type and the class structure is freed."
msgstr ""
"类的销毁（关于这个销毁的另一概念是 GType 的终结）的过程与初始化的刚好对称： "
"接口先被销毁。 然后，调用类终结函数 class_finalize（<link linkend="
"\"ClassFinalizeFunc\"><type>ClassFinalizeFunc</type></link>）。 最终，将 "
"base_class_finalize（<link linkend=\"GBaseFinalizeFunc"
"\"><type>GBaseFinalizeFunc</type></link>） 从底至顶的调用，直到类结构被销毁。"

#: tut_gtype.xml:573(para)
msgid ""
"As many readers have now understood it, the base initialization/finalization "
"process is very similar to the C++ constructor/destructor paradigm. The "
"practical details are different though and it is important not to get "
"confused by superficial similarities. GTypes have no instance destruction "
"mechanism. It is the user's responsibility to implement correct destruction "
"semantics on top of the existing GType code. (this is what GObject does. See "
"<xref linkend=\"chapter-gobject\"/>) Furthermore, C++ code equivalent to the "
"base_init and class_init callbacks of GType is usually not needed because C+"
"+ cannot really create object types at runtime."
msgstr ""
"很多读者已经明白了，基本的初始化/终结化过程与C++的构造/析构函数非常相似。 实"
"际上细节是非常不同的，千万不要被表现的相似所迷惑。 特别是，大多数用户开始认识"
"到GType中并不存在类似于C++的构造器（这实际上是一个方法列表， 由对象实例来调用"
"所有有继承关系的方法），它必须建立在由GType 提供的特定的设施里。 同样的，"
"GType没有实例销毁机制。 这是用户的职责，在现存的GType代码的顶端来实现正确的销"
"毁（见：<xref linkend=\"chapter-gobject\"/>）。 举个例子，如果从A继承的对象B"
"被实例化了，GType将只调用对象B的instance_init回调函数， 而C++运行环境将先调用"
"对象A的构造器，接着再是对象B。 事实上，C++代码与GType的base_init和class_init"
"回调是等同的， 不过C++常常是不需要这些的，因为它并不能真的在运行时创建类型。"

#: tut_gtype.xml:58(para)
msgid ""
"Please note that there exists another registration function: the "
"<function><link linkend=\"g-type-register-dynamic\">g_type_register_dynamic</"
"link></function>. We will not discuss this function here since its use is "
"very similar to the <function>_static</function> version."
msgstr ""
"请注意，另外一个注册函数是 <function><link linkend=\"g-type-register-dynamic"
"\">g_type_register_dynamic</link></function>。 我们将不讨论这个函数，因为它"
"与 <function>_static</function> 版本非常相似。"

#: tut_gtype.xml:586(para)
#, fuzzy
msgid ""
"The instantiation/finalization process can be summarized as follows: <table "
"id=\"gtype-init-fini-table\"><placeholder-1/><tgroup cols=\"3\"><colspec "
"colwidth=\"*\" colnum=\"1\" align=\"left\"/><colspec colwidth=\"*\" colnum="
"\"2\" align=\"left\"/><colspec colwidth=\"8*\" colnum=\"3\" align=\"left\"/"
"><thead><row><entry>Invocation time</entry><entry>Function Invoked</"
"entry><entry>Function's parameters</entry></row></thead><tbody><row><entry "
"morerows=\"2\">First call to <function><link linkend=\"g-type-create-instance"
"\">g_type_create_instance</link></function> for target type</"
"entry><entry>type's base_init function</entry><entry>On the inheritance tree "
"of classes from fundamental type to target type. base_init is invoked once "
"for each class structure.</entry></row><row><entry>target type's class_init "
"function</entry><entry>On target type's class structure</entry></"
"row><row><entry>interface initialization, see <xref linkend=\"gtype-non-"
"instantiable-classed-init\"/></entry><entry/></row><row><entry>Each call to "
"<function><link linkend=\"g-type-create-instance\">g_type_create_instance</"
"link></function> for target type</entry><entry>target type's instance_init "
"function</entry><entry>On object's instance</entry></row><row><entry "
"morerows=\"2\">Last call to <function><link linkend=\"g-type-free-instance"
"\">g_type_free_instance</link></function> for target type</"
"entry><entry>interface destruction, see <xref linkend=\"gtype-non-"
"instantiable-classed-dest\"/></entry><entry/></row><row><entry>target type's "
"class_finalize function</entry><entry>On target type's class structure</"
"entry></row><row><entry>type's base_finalize function</entry><entry>On the "
"inheritance tree of classes from fundamental type to target type. "
"base_finalize is invoked once for each class structure.</entry></row></"
"tbody></tgroup></table>"
msgstr ""
"关于实例化和终结化的处理过程可以归纳如下： <table id=\"gtype-init-fini-table"
"\"><placeholder-1/><tgroup cols=\"3\"><colspec colwidth=\"*\" colnum=\"1\" "
"align=\"left\"/><colspec colwidth=\"*\" colnum=\"2\" align=\"left\"/"
"><colspec colwidth=\"8*\" colnum=\"3\" align=\"left\"/"
"><thead><row><entry>Invocation time</entry><entry>Function Invoked</"
"entry><entry>Function's parameters</entry></row></thead><tbody><row><entry "
"morerows=\"2\">First call to <function><link linkend=\"g-type-create-instance"
"\">g_type_create_instance</link></function> for target type</"
"entry><entry>type's base_init function</entry><entry>On the inheritance tree "
"of classes from fundamental type to target type. base_init is invoked once "
"for each class structure.</entry></row><row><entry>target type's class_init "
"function</entry><entry>On target type's class structure</entry></"
"row><row><entry>interface initialization, see <xref linkend=\"gtype-non-"
"instantiable-classed-init\"/></entry><entry/></row><row><entry>Each call to "
"<function><link linkend=\"g-type-create-instance\">g_type_create_instance</"
"link></function> for target type</entry><entry>target type's instance_init "
"function</entry><entry>On object's instance</entry></row><row><entry "
"morerows=\"2\">Last call to <function><link linkend=\"g-type-free-instance"
"\">g_type_free_instance</link></function> for target type</"
"entry><entry>interface destruction, see <xref linkend=\"gtype-non-"
"instantiable-classed-dest\"/></entry><entry/></row><row><entry>target type's "
"class_finalize function</entry><entry>On target type's class structure</"
"entry></row><row><entry>type's base_finalize function</entry><entry>On the "
"inheritance tree of classes from fundamental type to target type. "
"base_finalize is invoked once for each class structure.</entry></row></"
"tbody></tgroup></table>"

#: tut_gtype.xml:589(title)
msgid "GType Instantiation/Finalization"
msgstr ""

#: tut_gtype.xml:6(title)
msgid "The GLib Dynamic Type System"
msgstr "GLib动态类型系统"

#: tut_gtype.xml:652(title)
msgid "Non-instantiable classed types: interfaces"
msgstr "不可实例的类型：接口"

#: tut_gtype.xml:654(para)
msgid ""
"GType's interfaces are very similar to Java's interfaces. They allow to "
"describe a common API that several classes will adhere to. Imagine the play, "
"pause and stop buttons on hi-fi equipment - those can be seen as a playback "
"interface. Once you know what they do, you can control your CD player, MP3 "
"player or anything that uses these symbols. To declare an interface you have "
"to register a non-instantiable classed type which derives from <link linkend="
"\"GTypeInterface\"><type>GTypeInterface</type></link>. The following piece "
"of code declares such an interface. <placeholder-1/> The interface function, "
"<function>maman_ibaz_do_action</function> is implemented in a pretty simple "
"way: <placeholder-2/><function>maman_ibaz_get_type</function> registers a "
"type named <emphasis>MamanIBaz</emphasis> which inherits from "
"G_TYPE_INTERFACE. All interfaces must be children of G_TYPE_INTERFACE in the "
"inheritance tree."
msgstr ""
"GType's interfaces are very similar to Java's interfaces. They allow GType的"
"接口（Interface）与Java的接口非常类似。 它允许描述一个通用的API，使得多个类可"
"以粘合在一起。 想像一下，Hi-Fi音响设备中的暂停和播放按钮──这可以被视做一个回"
"放接口。 如果你知道你要做什么，你可以用来这个接口来控制你的CD机，MP3或其他使"
"用相同符号的东西。 要声明一个接口，你需要注册一个从<link linkend="
"\"GTypeInterface\"><type>GTypeInterface</type></link> 继承的不可实例的类型。 "
"下面的代码声明了这样的一个接口： <placeholder-1/> 这里用非常简单的方法来实现"
"<function>maman_ibaz_do_action</function>这个接口函数： <placeholder-2/"
"><function>maman_ibaz_get_type</function> 注册了一个从G_TYPE_INTERFACE继承的"
"名为<emphasis>MamanIBaz</emphasis>的类型。 在继承树中，所有的接口必须是"
"G_TYPE_INTERFACE的子类。"

#: tut_gtype.xml:663(programlisting)
#, no-wrap
msgid ""
"\n"
"#define MAMAN_TYPE_IBAZ                (maman_ibaz_get_type ())\n"
"#define MAMAN_IBAZ(obj)                (G_TYPE_CHECK_INSTANCE_CAST ((obj), MAMAN_TYPE_IBAZ, MamanIbaz))\n"
"#define MAMAN_IS_IBAZ(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), MAMAN_TYPE_IBAZ))\n"
"#define MAMAN_IBAZ_GET_INTERFACE(inst) (G_TYPE_INSTANCE_GET_INTERFACE ((inst), MAMAN_TYPE_IBAZ, MamanIbazInterface))\n"
"\n"
"typedef struct _MamanIbaz MamanIbaz; /* dummy object */\n"
"typedef struct _MamanIbazInterface MamanIbazInterface;\n"
"\n"
"struct _MamanIbazInterface {\n"
"  GTypeInterface parent;\n"
"\n"
"  void (*do_action) (MamanIbaz *self);\n"
"};\n"
"\n"
"GType maman_ibaz_get_type (void);\n"
"\n"
"void maman_ibaz_do_action (MamanIbaz *self);\n"
msgstr ""

#: tut_gtype.xml:67(para)
msgid ""
"Fundamental types are top-level types which do not derive from any other "
"type while other non-fundamental types derive from other types. Upon "
"initialization by <function><link linkend=\"g-type-init\">g_type_init</"
"link></function>, the type system not only initializes its internal data "
"structures but it also registers a number of core types: some of these are "
"fundamental types. Others are types derived from these fundamental types."
msgstr ""
"基本类型是不需要从任何其他类型取得的最顶级的类型，相对的， 其他非基本类型是继"
"承于其他类型的。 在由 <function><link linkend=\"g-type-init\">g_type_init</"
"link></function>初始化时，类型系统不仅仅初始化它的内部数据结构， 同时也注册一"
"些核心类型：其中一些是基本类型，其他则是从基本类型继承的。"

#: tut_gtype.xml:684(programlisting)
#, no-wrap
msgid ""
"\n"
"void maman_ibaz_do_action (MamanIbaz *self)\n"
"{\n"
"  MAMAN_IBAZ_GET_INTERFACE (self)-&gt;do_action (self);\n"
"}\n"
msgstr ""

#: tut_gtype.xml:695(para)
msgid ""
"An interface is defined by only one structure which must contain as first "
"member a <link linkend=\"GTypeInterface\"><type>GTypeInterface</type></link> "
"structure. The interface structure is expected to contain the function "
"pointers of the interface methods. It is good style to define helper "
"functions for each of the interface methods which simply call the interface' "
"method directly: <function>maman_ibaz_do_action</function> is one of these."
msgstr ""
"一个接口只有一个包含<link linkend=\"GTypeInterface\"><type>GTypeInterface</"
"type></link>的结构来定义。 接口的结构应该要包含一个函数指针指向这个接口的方"
"法。 用类似于<function>maman_ibaz_do_action</function>的方法在每个接口方法中"
"定义帮助函数， 可以使得我们直接调用接口方法，这是一个良好的风格。"

#: tut_gtype.xml:704(para)
msgid ""
"Once an interface type is registered, you must register implementations for "
"these interfaces. The function named <function>maman_baz_get_type</function> "
"registers a new GType named MamanBaz which inherits from <link linkend="
"\"GObject\"><type>GObject</type></link> and which implements the interface "
"<type>MamanIBaz</type>. <placeholder-1/>"
msgstr ""
"一旦一个接口的类型被注册后，你必须来实现这个接口。 其中，命名为"
"<function>maman_baz_get_type</function> 注册一个名为<type>MamanIBaz</type>的"
"由<link linkend=\"GObject\"><type>GObject</type></link>继承来的新的GType， 并"
"在接口Interface中实现。 <placeholder-1/>"

#: tut_gtype.xml:709(programlisting)
#, no-wrap
msgid ""
"\n"
"static void maman_baz_do_action (MamanIbaz *self)\n"
"{\n"
"  g_print (\"Baz implementation of IBaz interface Action.\\n\");\n"
"}\n"
"\n"
"\n"
"static void\n"
"baz_interface_init (gpointer         g_iface,\n"
"                    gpointer         iface_data)\n"
"{\n"
"  MamanIbazInterface *iface = (MamanIbazInterface *)g_iface;\n"
"  iface-&gt;do_action = maman_baz_do_action;\n"
"}\n"
"\n"
"GType \n"
"maman_baz_get_type (void)\n"
"{\n"
"  static GType type = 0;\n"
"  if (type == 0) {\n"
"    static const GTypeInfo info = {\n"
"      sizeof (MamanBazInterface),\n"
"      NULL,   /* base_init */\n"
"      NULL,   /* base_finalize */\n"
"      NULL,   /* class_init */\n"
"      NULL,   /* class_finalize */\n"
"      NULL,   /* class_data */\n"
"      sizeof (MamanBaz),\n"
"      0,      /* n_preallocs */\n"
"      NULL    /* instance_init */\n"
"    };\n"
"    static const GInterfaceInfo ibaz_info = {\n"
"      (GInterfaceInitFunc) baz_interface_init,    /* interface_init */\n"
"      NULL,               /* interface_finalize */\n"
"      NULL          /* interface_data */\n"
"    };\n"
"    type = g_type_register_static (G_TYPE_OBJECT,\n"
"                                   \"MamanBazType\",\n"
"                                   &amp;info, 0);\n"
"    g_type_add_interface_static (type,\n"
"                                 MAMAN_TYPE_IBAZ,\n"
"                                 &amp;ibaz_info);\n"
"  }\n"
"  return type;\n"
"}\n"
msgstr ""

#: tut_gtype.xml:757(para)
msgid ""
"<function><link linkend=\"g-type-add-interface-static"
"\">g_type_add_interface_static</link></function> records in the type system "
"that a given type implements also <type>FooInterface</type> "
"(<function>foo_interface_get_type</function> returns the type of "
"<type>FooInterface</type>). The <link linkend=\"GInterfaceInfo"
"\"><type>GInterfaceInfo</type></link> structure holds information about the "
"implementation of the interface: <placeholder-1/>"
msgstr ""
"<function><link linkend=\"g-type-add-interface-static"
"\">g_type_add_interface_static</link></function> 记录了在类型系统中如 "
"<type>FooInterface</type>来实现的接口（<function>foo_interface_get_type</"
"function>返回<type>FooInterface</type>的类型）， <link linkend="
"\"GInterfaceInfo\"><type>GInterfaceInfo</type></link>保存着关于接口实现的信"
"息： <placeholder-1/>"

#: tut_gtype.xml:76(para)
msgid ""
"Fundamental and non-fundamental types are defined by: <placeholder-1/> "
"Fundamental types are also defined by a set of <link linkend="
"\"GTypeFundamentalFlags\"><type>GTypeFundamentalFlags</type></link> which "
"are stored in a <link linkend=\"GTypeFundamentalInfo"
"\"><type>GTypeFundamentalInfo</type></link>. Non-fundamental types are "
"furthermore defined by the type of their parent which is passed as the "
"parent_type parameter to <function><link linkend=\"g-type-register-static"
"\">g_type_register_static</link></function> and <function><link linkend=\"g-"
"type-register-dynamic\">g_type_register_dynamic</link></function>."
msgstr ""
"不论是基本还是非基本类型，均由下面的定义步骤： <placeholder-1/> 基本类型同样"
"可以由 <link linkend=\"GTypeFundamentalFlags\"><type>GTypeFundamentalFlags</"
"type></link> 来定义，并保存在 <link linkend=\"GTypeFundamentalInfo"
"\"><type>GTypeFundamentalInfo</type></link> 中。非基本类型一般传递一个 "
"parent_type 至<function><link linkend=\"g-type-register-static"
"\">g_type_register_static</link></function> 和 <function><link linkend=\"g-"
"type-register-dynamic\">g_type_register_dynamic</link></function> 中，然后交"
"给父类来定义。"

#: tut_gtype.xml:764(programlisting)
#, no-wrap
msgid ""
"\n"
"struct _GInterfaceInfo\n"
"{\n"
"  GInterfaceInitFunc     interface_init;\n"
"  GInterfaceFinalizeFunc interface_finalize;\n"
"  gpointer               interface_data;\n"
"};\n"
msgstr ""

#: tut_gtype.xml:773(para)
msgid ""
"When having no special requirements you also can use the "
"<function>G_DEFINE_INTERFACE</function> macro: <placeholder-1/>"
msgstr ""
"如果没有特殊的需求，你可以直接使用<function>G_DEFINE_INTERFACE</function>这个"
"宏： <placeholder-1/>"

#: tut_gtype.xml:775(programlisting)
#, no-wrap
msgid ""
"\n"
"G_DEFINE_INTERFACE (MamanBaz, maman_baz, G_TYPE_OBJECT)\n"
msgstr ""

#: tut_gtype.xml:782(title) tut_gtype.xml:839(title)
msgid "Interface Initialization"
msgstr "接口初始化"

#: tut_gtype.xml:784(para)
msgid ""
"When an instantiable classed type which registered an interface "
"implementation is created for the first time, its class structure is "
"initialized following the process described in <xref linkend=\"gtype-"
"instantiable-classed\"/>. After that, the interface implementations "
"associated with the type are initialized."
msgstr ""

#: tut_gtype.xml:79(para)
msgid ""
"class size: the class_size field in <link linkend=\"GTypeInfo"
"\"><type>GTypeInfo</type></link>."
msgstr ""
"类的大小：<link linkend=\"GTypeInfo\"><type>GTypeInfo</type></link>的 "
"class_size。"

#: tut_gtype.xml:793(para)
msgid ""
"First a memory buffer is allocated to hold the interface structure. The "
"parent's interface structure is then copied over to the new interface "
"structure (the parent interface is already initialized at that point). If "
"there is no parent interface, the interface structure is initialized with "
"zeros. The g_type and the g_instance_type fields are then initialized: "
"g_type is set to the type of the most-derived interface and g_instance_type "
"is set to the type of the most derived type which implements this interface."
msgstr ""

#: tut_gtype.xml:8(para)
msgid ""
"A type, as manipulated by the GLib type system, is much more generic than "
"what is usually understood as an Object type. It is best explained by "
"looking at the structure and the functions used to register new types in the "
"type system. <placeholder-1/>"
msgstr ""
"由 Glib 类型系统操作的一个类型，比传统上所讲的 Object 类型更具一般化。 下面查"
"看类型系统中有关类结构和注册新类型的函数，是会对此最好的解释。 "
"<placeholder-1/>"

#: tut_gtype.xml:803(para)
msgid ""
"Finally, the interface' most-derived <function>base_init</function> function "
"and then the implementation's <function>interface_init</function> function "
"are invoked. It is important to understand that if there are multiple "
"implementations of an interface the <function>base_init</function> and "
"<function>interface_init</function> functions will be invoked once for each "
"implementation initialized."
msgstr ""

#: tut_gtype.xml:812(para)
msgid ""
"It is thus common for base_init functions to hold a local static boolean "
"variable which makes sure that the interface type is initialized only once "
"even if there are multiple implementations of the interface: <placeholder-1/>"
msgstr ""

#: tut_gtype.xml:816(programlisting)
#, no-wrap
msgid ""
"\n"
"static void\n"
"maman_ibaz_base_init (gpointer g_iface)\n"
"{\n"
"  static gboolean initialized = FALSE;\n"
"\n"
"  if (!initialized) {\n"
"    /* create interface signals here. */\n"
"    initialized = TRUE;\n"
"  }\n"
"}\n"
msgstr ""

#: tut_gtype.xml:82(para)
msgid ""
"class initialization functions (C++ constructor): the base_init and "
"class_init fields in <link linkend=\"GTypeInfo\"><type>GTypeInfo</type></"
"link>."
msgstr ""
"类的初始化函数（C++ 构造函数）：<link linkend=\"GTypeInfo\"><type>GTypeInfo</"
"type></link>的 base_init 和 class_init。"

#: tut_gtype.xml:830(para)
msgid ""
"If you have found the stuff about interface hairy, you are right: it is "
"hairy but there is not much I can do about it. What I can do is summarize "
"what you need to know about interfaces:"
msgstr ""

#: tut_gtype.xml:836(para)
msgid ""
"The above process can be summarized as follows: <table id=\"ginterface-init-"
"table\"><placeholder-1/><tgroup cols=\"3\"><colspec colwidth=\"*\" colnum="
"\"1\" align=\"left\"/><colspec colwidth=\"*\" colnum=\"2\" align=\"left\"/"
"><colspec colwidth=\"8*\" colnum=\"3\" align=\"left\"/"
"><thead><row><entry>Invocation time</entry><entry>Function Invoked</"
"entry><entry>Function's parameters</entry><entry>Remark</entry></row></"
"thead><tbody><row><entry morerows=\"1\">First call to <function><link "
"linkend=\"g-type-create-instance\">g_type_create_instance</link></function> "
"for type implementing interface </entry><entry>interface' base_init "
"function</entry><entry>On interface' vtable</entry><entry>Register "
"interface' signals here (use a local static boolean variable as described "
"above to make sure not to register them twice.).</entry></"
"row><row><entry>interface' interface_init function</entry><entry>On "
"interface' vtable</entry><entry> Initialize interface' implementation. That "
"is, initialize the interface method pointers in the interface structure to "
"the function's implementation. </entry></row></tbody></tgroup></table> It is "
"highly unlikely (i.e. I do not know of <emphasis>anyone</emphasis> who "
"actually used it) you will ever need other more fancy things such as the "
"ones described in the following section (<xref linkend=\"gtype-non-"
"instantiable-classed-dest\"/>)."
msgstr ""

#: tut_gtype.xml:86(para)
msgid ""
"class destruction functions (C++ destructor): the base_finalize and "
"class_finalize fields in <link linkend=\"GTypeInfo\"><type>GTypeInfo</type></"
"link>."
msgstr ""
"类的销毁函数（C++析构函数）：<link linkend=\"GTypeInfo\"><type>GTypeInfo</"
"type></link>的 base_finalize 和 class_finalize。"

#: tut_gtype.xml:886(title)
msgid "Interface Destruction"
msgstr ""

#: tut_gtype.xml:888(para)
msgid ""
"When the last instance of an instantiable type which registered an interface "
"implementation is destroyed, the interface's implementations associated to "
"the type are destroyed."
msgstr ""

#: tut_gtype.xml:894(para)
msgid ""
"To destroy an interface implementation, GType first calls the "
"implementation's <function>interface_finalize</function> function and then "
"the interface's most-derived <function>base_finalize</function> function."
msgstr ""

#: tut_gtype.xml:90(para)
msgid ""
"instance size (C++ parameter to new): the instance_size field in <link "
"linkend=\"GTypeInfo\"><type>GTypeInfo</type></link>."
msgstr ""
"实例的大小（C++参数new）：<link linkend=\"GTypeInfo\"><type>GTypeInfo</"
"type></link>中 的 instance_size。"

#: tut_gtype.xml:901(para)
msgid ""
"Again, it is important to understand, as in <xref linkend=\"gtype-non-"
"instantiable-classed-init\"/>, that both <function>interface_finalize</"
"function> and <function>base_finalize</function> are invoked exactly once "
"for the destruction of each implementation of an interface. Thus, if you "
"were to use one of these functions, you would need to use a static integer "
"variable which would hold the number of instances of implementations of an "
"interface such that the interface's class is destroyed only once (when the "
"integer variable reaches zero)."
msgstr ""

#: tut_gtype.xml:911(para)
msgid ""
"The above process can be summarized as follows: <table id=\"ginterface-fini-"
"table\"><placeholder-1/><tgroup cols=\"3\"><colspec colwidth=\"*\" colnum="
"\"1\" align=\"left\"/><colspec colwidth=\"*\" colnum=\"2\" align=\"left\"/"
"><colspec colwidth=\"8*\" colnum=\"3\" align=\"left\"/"
"><thead><row><entry>Invocation time</entry><entry>Function Invoked</"
"entry><entry>Function's parameters</entry></row></thead><tbody><row><entry "
"morerows=\"1\">Last call to <function><link linkend=\"g-type-free-instance"
"\">g_type_free_instance</link></function> for type implementing interface </"
"entry><entry>interface' interface_finalize function</entry><entry>On "
"interface' vtable</entry></row><row><entry>interface' base_finalize "
"function</entry><entry>On interface' vtable</entry></row></tbody></tgroup></"
"table>"
msgstr ""

#: tut_gtype.xml:914(title)
msgid "Interface Finalization"
msgstr ""

#: tut_gtype.xml:94(para)
msgid ""
"instantiation policy (C++ type of new operator): the n_preallocs field in "
"<link linkend=\"GTypeInfo\"><type>GTypeInfo</type></link>."
msgstr ""
"实例化策略（C++ 类的new operator）：<link linkend=\"GTypeInfo"
"\"><type>GTypeInfo</type></link>的n_preallocs。"

#: tut_gtype.xml:98(para)
msgid ""
"copy functions (C++ copy operators): the value_table field in <link linkend="
"\"GTypeInfo\"><type>GTypeInfo</type></link>."
msgstr ""
"复制函数（C++的复制操作）：<link linkend=\"GTypeInfo\"><type>GTypeInfo</"
"type></link>的 value_table。"

#: tut_howto.xml:1001(title)
msgid "Interface definition prerequisites"
msgstr ""

#: tut_howto.xml:1003(para)
msgid ""
"To specify that an interface requires the presence of other interfaces when "
"implemented, GObject introduces the concept of <emphasis>prerequisites</"
"emphasis>: it is possible to associate a list of prerequisite interfaces to "
"an interface. For example, if object A wishes to implement interface I1, and "
"if interface I1 has a prerequisite on interface I2, A has to implement both "
"I1 and I2."
msgstr ""

#: tut_howto.xml:1012(para)
msgid ""
"The mechanism described above is, in practice, very similar to Java's "
"interface I1 extends interface I2. The example below shows the GObject "
"equivalent: <placeholder-1/> The code shown above adds the MamanIbaz "
"interface to the list of prerequisites of MamanIbar while the code below "
"shows how an implementation can implement both interfaces and register their "
"implementations: <placeholder-2/> It is very important to notice that the "
"order in which interface implementations are added to the main object is not "
"random: <function><link linkend=\"g-type-add-interface-static"
"\">g_type_add_interface_static</link></function>, which is called by "
"<function>G_IMPLEMENT_INTERFACE</function>, must be invoked first on the "
"interfaces which have no prerequisites and then on the others."
msgstr ""

#: tut_howto.xml:1016(programlisting)
#, no-wrap
msgid ""
"\n"
"  /* inside the GType function of the MamanIbar interface */\n"
"  type = g_type_register_static (G_TYPE_INTERFACE, \"MamanIbar\", &amp;info, 0);\n"
"\n"
"  /* Make the MamanIbar interface require MamanIbaz interface. */\n"
"  g_type_interface_add_prerequisite (type, MAMAN_TYPE_IBAZ);\n"
msgstr ""

#: tut_howto.xml:1027(programlisting)
#, no-wrap
msgid ""
"\n"
"static void\n"
"maman_ibar_do_another_action (MamanIbar *ibar)\n"
"{\n"
"  MamanBar *self = MAMAN_BAR (ibar);\n"
"\n"
"  g_print (\"Bar implementation of IBar interface Another Action: 0x%x.\\n\",\n"
"           self-&gt;instance_member);\n"
"}\n"
"\n"
"static void\n"
"maman_ibar_interface_init (MamanIbarInterface *iface)\n"
"{\n"
"  iface-&gt;do_another_action = maman_ibar_do_another_action;\n"
"}\n"
"\n"
"static void\n"
"maman_ibaz_do_action (MamanIbaz *ibaz)\n"
"{\n"
"  MamanBar *self = MAMAN_BAR (ibaz);\n"
"\n"
"  g_print (\"Bar implementation of IBaz interface Action: 0x%x.\\n\",\n"
"           self-&gt;instance_member);\n"
"}\n"
"\n"
"static void\n"
"maman_ibaz_interface_init (MamanIbazInterface *iface)\n"
"{\n"
"  iface-&gt;do_action = maman_ibaz_do_action;\n"
"}\n"
"\n"
"static void\n"
"maman_bar_class_init (MamanBarClass *klass)\n"
"{\n"
"\n"
"}\n"
"\n"
"static void\n"
"maman_bar_init (MamanBar *self)\n"
"{\n"
"  self-&gt;instance_member = 0x666;\n"
"}\n"
"\n"
"G_DEFINE_TYPE_WITH_CODE (MamanBar, maman_bar, G_TYPE_OBJECT,\n"
"                         G_IMPLEMENT_INTERFACE (MAMAN_TYPE_IBAZ,\n"
"                                                maman_ibaz_interface_init)\n"
"                         G_IMPLEMENT_INTERFACE (MAMAN_TYPE_IBAR,\n"
"                                                maman_ibar_interface_init));\n"
msgstr ""

#: tut_howto.xml:1086(title)
msgid "Interface Properties"
msgstr ""

#: tut_howto.xml:1088(para)
msgid ""
"Starting from version 2.4 of GLib, GObject interfaces can also have "
"properties. Declaration of the interface properties is similar to declaring "
"the properties of ordinary GObject types as explained in <xref linkend="
"\"gobject-properties\"/>, except that <function><link linkend=\"g-object-"
"interface-install-property\">g_object_interface_install_property</link></"
"function> is used to declare the properties instead of <function><link "
"linkend=\"g-object-class-install-property\">g_object_class_install_property</"
"link></function>."
msgstr ""

#: tut_howto.xml:1097(para)
msgid ""
"To include a property named 'name' of type <type>string</type> in the "
"<type>maman_ibaz</type> interface example code above, we only need to add "
"one <placeholder-1/> line in the <function>maman_ibaz_base_init</"
"function><placeholder-2/> as shown below: <placeholder-3/>"
msgstr ""

#: tut_howto.xml:1102(para)
msgid "That really is one line extended to six for the sake of clarity"
msgstr ""

#: tut_howto.xml:1108(para)
msgid ""
"The <function><link linkend=\"g-object-interface-install-property"
"\">g_object_interface_install_property</link></function> can also be called "
"from <function>class_init</function> but it must not be called after that "
"point."
msgstr ""

#: tut_howto.xml:1115(programlisting)
#, no-wrap
msgid ""
"\n"
"static void\n"
"maman_ibaz_base_init (gpointer g_iface)\n"
"{\n"
"  static gboolean is_initialized = FALSE;\n"
"\n"
"  if (!is_initialized)\n"
"    {\n"
"      g_object_interface_install_property (g_iface,\n"
"                                           g_param_spec_string (\"name\",\n"
"                                                                \"Name\",\n"
"                                                                \"Name of the MamanIbaz\",\n"
"                                                                \"maman\",\n"
"                                                                G_PARAM_READWRITE));\n"
"      is_initialized = TRUE;\n"
"    }\n"
"}\n"
msgstr ""

#: tut_howto.xml:1135(para)
msgid ""
"One point worth noting is that the declared property wasn't assigned an "
"integer ID. The reason being that integer IDs of properties are used only "
"inside the get and set methods and since interfaces do not implement "
"properties, there is no need to assign integer IDs to interface properties."
msgstr ""

#: tut_howto.xml:1143(para)
msgid ""
"An implementation shall declare and define it's properties in the usual way "
"as explained in <xref linkend=\"gobject-properties\"/>, except for one small "
"change: it must declare the properties of the interface it implements using "
"<function><link linkend=\"g-object-class-override-property"
"\">g_object_class_override_property</link></function> instead of "
"<function><link linkend=\"g-object-class-install-property"
"\">g_object_class_install_property</link></function>. The following code "
"snippet shows the modifications needed in the <type>MamanBaz</type> "
"declaration and implementation above: <placeholder-1/>"
msgstr ""

#: tut_howto.xml:1151(programlisting)
#, no-wrap
msgid ""
"\n"
"\n"
"struct _MamanBaz\n"
"{\n"
"  GObject parent_instance;\n"
"\n"
"  gint instance_member;\n"
"  gchar *name;\n"
"};\n"
"\n"
"enum\n"
"{\n"
"  PROP_0,\n"
"\n"
"  PROP_NAME\n"
"};\n"
"\n"
"static void\n"
"maman_baz_set_property (GObject      *object,\n"
"                        guint         property_id,\n"
"                        const GValue *value,\n"
"                        GParamSpec   *pspec)\n"
"{\n"
"  MamanBaz *baz = MAMAN_BAZ (object);\n"
"  GObject *obj;\n"
"\n"
"  switch (prop_id)\n"
"    {\n"
"    case ARG_NAME:\n"
"      g_free (baz-&gt;name);\n"
"      baz-&gt;name = g_value_dup_string (value);\n"
"      break;\n"
"\n"
"    default:\n"
"      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);\n"
"      break;\n"
"    }\n"
"}\n"
"\n"
"static void\n"
"maman_baz_get_property (GObject    *object,\n"
"                        guint       prop_id,\n"
"                        GValue     *value,\n"
"                        GParamSpec *pspec)\n"
"{\n"
"  MamanBaz *baz = MAMAN_BAZ (object);\n"
"\n"
"  switch (prop_id)\n"
"    {\n"
"    case ARG_NAME:\n"
"      g_value_set_string (value, baz-&gt;name);\n"
"      break;\n"
"\n"
"    default:\n"
"      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);\n"
"      break;\n"
"    }\n"
"}\n"
"\n"
"static void\n"
"maman_baz_class_init (MamanBazClass *klass)\n"
"{\n"
"  GObjectClass *gobject_class = G_OBJECT_CLASS (klass);\n"
"\n"
"  gobject_class-&gt;set_property = maman_baz_set_property;\n"
"  gobject_class-&gt;get_property = maman_baz_get_property;\n"
"\n"
"  g_object_class_override_property (gobject_class, PROP_NAME, \"name\");\n"
"}\n"
"\n"
msgstr ""

#: tut_howto.xml:1229(title)
msgid "How to create and use signals"
msgstr ""

#: tut_howto.xml:1231(para)
msgid ""
"The signal system which was built in GType is pretty complex and flexible: "
"it is possible for its users to connect at runtime any number of callbacks "
"(implemented in any language for which a binding exists) <placeholder-1/> to "
"any signal and to stop the emission of any signal at any state of the signal "
"emission process. This flexibility makes it possible to use GSignal for much "
"more than just emit signals which can be received by numerous clients."
msgstr ""

#: tut_howto.xml:1237(para)
msgid ""
"A Python callback can be connected to any signal on any C-based GObject."
msgstr ""

#: tut_howto.xml:1248(title)
msgid "Simple use of signals"
msgstr ""

#: tut_howto.xml:1250(para)
msgid ""
"The most basic use of signals is to implement simple event notification: for "
"example, if we have a MamanFile object, and if this object has a write "
"method, we might wish to be notified whenever someone has changed something "
"via our MamanFile instance. The code below shows how the user can connect a "
"callback to the \"changed\" signal. <placeholder-1/>"
msgstr ""

#: tut_howto.xml:1257(programlisting)
#, no-wrap
msgid ""
"\n"
"file = g_object_new (MAMAN_FILE_TYPE, NULL);\n"
"\n"
"g_signal_connect (file, \"changed\", G_CALLBACK (changed_event), NULL);\n"
"\n"
"maman_file_write (file, buffer, strlen (buffer));\n"
msgstr ""

#: tut_howto.xml:1266(para)
msgid ""
"The <type>MamanFile</type> signal is registered in the class_init function: "
"<placeholder-1/> and the signal is emitted in <function>maman_file_write</"
"function>: <placeholder-2/> As shown above, you can safely set the details "
"parameter to zero if you do not know what it can be used for. For a "
"discussion of what you could used it for, see <xref linkend=\"signal-detail"
"\"/>"
msgstr ""

#: tut_howto.xml:1269(programlisting)
#, no-wrap
msgid ""
"\n"
"file_signals[CHANGED] = \n"
"  g_signal_newv (\"changed\",\n"
"                 G_TYPE_FROM_CLASS (gobject_class),\n"
"                 G_SIGNAL_RUN_LAST | G_SIGNAL_NO_RECURSE | G_SIGNAL_NO_HOOKS,\n"
"                 NULL /* closure */,\n"
"                 NULL /* accumulator */,\n"
"                 NULL /* accumulator data */,\n"
"                 g_cclosure_marshal_VOID__VOID,\n"
"                 G_TYPE_NONE /* return_type */,\n"
"                 0     /* n_params */,\n"
"                 NULL  /* param_types */);\n"
msgstr ""

#: tut_howto.xml:1283(programlisting)
#, no-wrap
msgid ""
"\n"
"void\n"
"maman_file_write (MamanFile    *self,\n"
"                  const guchar *buffer,\n"
"                  gssize        size)\n"
"{\n"
"  /* First write data. */\n"
"\n"
"  /* Then, notify user of data written. */\n"
"  g_signal_emit (self, file_signals[CHANGED], 0 /* details */);\n"
"}\n"
msgstr ""

#: tut_howto.xml:1300(para)
msgid ""
"The signature of the signal handler in the above example is defined as "
"<function>g_cclosure_marshal_VOID__VOID</function>. Its name follows a "
"simple convention which encodes the function parameter and return value "
"types in the function name. Specifically, the value in front of the double "
"underscore is the type of the return value, while the value(s) after the "
"double underscore denote the parameter types."
msgstr ""

#: tut_howto.xml:1309(para)
msgid ""
"The header <filename>gobject/gmarshal.h</filename> defines a set of commonly "
"needed closures that one can use. If you want to have complex marshallers "
"for your signals you should probably use glib-genmarshal to autogenerate "
"them from a file containing their return and parameter types."
msgstr ""

#: tut_howto.xml:136(para)
msgid ""
"Most GTK+ types declare their private fields in the public header with a /* "
"private */ comment, relying on their user's intelligence not to try to play "
"with these fields. Fields not marked private are considered public by "
"default. The /* protected */ comment (same semantics as those of C++) is "
"also used, mainly in the GType library, in code written by Tim Janik. "
"<placeholder-1/>"
msgstr ""

#: tut_howto.xml:143(programlisting)
#, no-wrap
msgid ""
"\n"
"struct _MamanBar\n"
"{\n"
"  GObject parent_instance;\n"
"\n"
"  /*&lt; private &gt;*/\n"
"  int hsize;\n"
"};\n"
msgstr ""

#: tut_howto.xml:153(para)
msgid ""
"All of Nautilus code and a lot of GNOME libraries use private indirection "
"members, as described by Herb Sutter in his Pimpl articles(see <ulink url="
"\"http://www.gotw.ca/gotw/024.htm\">Compilation Firewalls</ulink> and <ulink "
"url=\"http://www.gotw.ca/gotw/028.htm\">The Fast Pimpl Idiom</ulink>: he "
"summarizes the different issues better than I will). <placeholder-1/"
"><placeholder-2/> The private structure is then defined in the .c file, "
"using the g_type_class_add_private() function to notify the presence of a "
"private memory area for each instance and it can either be retrieved using "
"<function>G_TYPE_INSTANCE_GET_PRIVATE()</function> each time is needed, or "
"assigned to the <literal>priv</literal> member of the instance structure "
"inside the object's <function>init</function> function. <placeholder-3/>"
msgstr ""

#: tut_howto.xml:159(programlisting)
#, no-wrap
msgid ""
"\n"
"typedef struct _MamanBarPrivate MamanBarPrivate;\n"
"\n"
"struct _MamanBar\n"
"{\n"
"  GObject parent_instance;\n"
"    \n"
"  /*&lt; private &gt;*/\n"
"  MamanBarPrivate *priv;\n"
"};\n"
msgstr ""

#: tut_howto.xml:16(title)
msgid "How to define and implement a new GObject"
msgstr ""

#: tut_howto.xml:170(simpara)
msgid ""
"Do not call this <varname>private</varname>, as that is a registered c++ "
"keyword."
msgstr ""

#: tut_howto.xml:18(para)
msgid ""
"Clearly, this is one of the most common questions people ask: they just want "
"to crank code and implement a subclass of a GObject. Sometimes because they "
"want to create their own class hierarchy, sometimes because they want to "
"subclass one of GTK+'s widget. This chapter will focus on the implementation "
"of a subtype of GObject."
msgstr ""

#: tut_howto.xml:180(programlisting)
#, no-wrap
msgid ""
"\n"
"#define MAMAN_BAR_GET_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE ((obj), MAMAN_TYPE_BAR, MamanBarPrivate))\n"
"\n"
"struct _MamanBarPrivate\n"
"{\n"
"  int hsize;\n"
"}\n"
"\n"
"static void\n"
"maman_bar_class_init (MamanBarClass *klass)\n"
"{\n"
"  g_type_class_add_private (klass, sizeof (MamanBarPrivate));\n"
"}\n"
"\n"
"static void\n"
"maman_bar_init (MamanBar *self)\n"
"{\n"
"  MamanBarPrivate *priv;\n"
"\n"
"  self-&gt;priv = priv = MAMAN_BAR_GET_PRIVATE (self);\n"
"\n"
"  priv-&gt;hsize = 42;\n"
"}\n"
msgstr ""

#: tut_howto.xml:206(para)
msgid ""
"You don't need to free or allocate the private structure, only the objects "
"or pointers that it may contain. Another advantage of this to the previous "
"version is that is lessens memory fragmentation, as the public and private "
"parts of the instance memory are allocated at once."
msgstr ""

#: tut_howto.xml:216(para)
msgid ""
"Finally, there are different header include conventions. Again, pick one and "
"stick to it. I personally use indifferently any of the two, depending on the "
"codebase I work on: the rule, as always, is consistency. <placeholder-1/>"
msgstr ""

#: tut_howto.xml:221(para)
msgid ""
"Some people add at the top of their headers a number of #include directives "
"to pull in all the headers needed to compile client code. This allows client "
"code to simply #include \"maman-bar.h\"."
msgstr ""

#: tut_howto.xml:226(para)
msgid ""
"Other do not #include anything and expect the client to #include themselves "
"the headers they need before including your header. This speeds up "
"compilation because it minimizes the amount of pre-processor work. This can "
"be used in conjunction with the re-declaration of certain unused types in "
"the client code to minimize compile-time dependencies and thus speed up "
"compilation."
msgstr ""

#: tut_howto.xml:240(title)
msgid "Boilerplate code"
msgstr ""

#: tut_howto.xml:242(para)
msgid ""
"In your code, the first step is to #include the needed headers: depending on "
"your header include strategy, this can be as simple as <literal>#include "
"\"maman-bar.h\"</literal> or as complicated as tens of #include lines ending "
"with <literal>#include \"maman-bar.h\"</literal>: <placeholder-1/>"
msgstr ""

#: tut_howto.xml:247(programlisting)
#, no-wrap
msgid ""
"\n"
"/*\n"
" * Copyright information\n"
" */\n"
"\n"
"#include \"maman-bar.h\"\n"
"\n"
"/* If you use Pimpls, include the private structure \n"
" * definition here. Some people create a maman-bar-private.h header\n"
" * which is included by the maman-bar.c file and which contains the\n"
" * definition for this private structure.\n"
" */\n"
"struct _MamanBarPrivate {\n"
"  int member_1;\n"
"  /* stuff */\n"
"};\n"
"\n"
"/* \n"
" * forward definitions\n"
" */\n"
msgstr ""

#: tut_howto.xml:27(title)
msgid "Boilerplate header code"
msgstr ""

#: tut_howto.xml:270(para)
msgid ""
"Call the <function>G_DEFINE_TYPE</function> macro using the name of the "
"type, the prefix of the functions and the parent GType to reduce the amount "
"of boilerplate needed. This macro will: <placeholder-1/><placeholder-2/>"
msgstr ""

#: tut_howto.xml:276(simpara)
msgid "implement the <function>maman_bar_get_type</function> function"
msgstr ""

#: tut_howto.xml:278(simpara)
msgid "define a parent class pointer accessible from the whole .c file"
msgstr ""

#: tut_howto.xml:282(programlisting)
#, no-wrap
msgid ""
"\n"
"G_DEFINE_TYPE (MamanBar, maman_bar, G_TYPE_OBJECT);\n"
msgstr ""

#: tut_howto.xml:287(para)
msgid ""
"It is also possible to use the <function>G_DEFINE_TYPE_WITH_CODE</function> "
"macro to control the get_type function implementation - for instance, to add "
"a call to <function>G_IMPLEMENT_INTERFACE</function> macro which will call "
"the <function>g_type_implement_interface</function> function."
msgstr ""

#: tut_howto.xml:29(para)
msgid ""
"The first step before writing the code for your GObject is to write the "
"type's header which contains the needed type, function and macro "
"definitions. Each of these elements is nothing but a convention which is "
"followed not only by GTK+'s code but also by most users of GObject. If you "
"feel the need not to obey the rules stated below, think about it twice: "
"<placeholder-1/>"
msgstr ""

#: tut_howto.xml:297(title)
msgid "Object Construction"
msgstr ""

#: tut_howto.xml:299(para)
msgid ""
"People often get confused when trying to construct their GObjects because of "
"the sheer number of different ways to hook into the objects's construction "
"process: it is difficult to figure which is the <emphasis>correct</"
"emphasis>, recommended way."
msgstr ""

#: tut_howto.xml:305(para)
msgid ""
"<xref linkend=\"gobject-construction-table\"/> shows what user-provided "
"functions are invoked during object instantiation and in which order they "
"are invoked. A user looking for the equivalent of the simple C++ constructor "
"function should use the instance_init method. It will be invoked after all "
"the parent's instance_init functions have been invoked. It cannot take "
"arbitrary construction parameters (as in C++) but if your object needs "
"arbitrary parameters to complete initialization, you can use construction "
"properties."
msgstr ""

#: tut_howto.xml:315(para)
msgid ""
"Construction properties will be set only after all instance_init functions "
"have run. No object reference will be returned to the client of "
"<function><link linkend=\"g-object-new\">g_object_new</link></function> "
"until all the construction properties have been set."
msgstr ""

#: tut_howto.xml:321(para)
msgid ""
"As such, I would recommend writing the following code first: <placeholder-1/>"
msgstr ""

#: tut_howto.xml:323(programlisting)
#, no-wrap
msgid ""
"\n"
"static void\n"
"maman_bar_init (MamanBar *self)\n"
"{\n"
"  self-&gt;priv = MAMAN_BAR_GET_PRIVATE (self); \n"
"\n"
"  /* initialize all public and private members to reasonable default values. */\n"
"\n"
"  /* If you need specific construction properties to complete initialization,\n"
"   * delay initialization completion until the property is set. \n"
"   */\n"
"}\n"
msgstr ""

#: tut_howto.xml:338(para)
msgid ""
"Now, if you need special construction properties, install the properties in "
"the class_init function, override the set and get methods and implement the "
"get and set methods as described in <xref linkend=\"gobject-properties\"/>. "
"Make sure that these properties use a construct only <link linkend="
"\"GParamSpec\"><type>GParamSpec</type></link> by setting the param spec's "
"flag field to G_PARAM_CONSTRUCT_ONLY: this helps GType ensure that these "
"properties are not set again later by malicious user code. <placeholder-1/> "
"If you need this, make sure you can build and run code similar to the code "
"shown above. Make sure your construct properties can set correctly during "
"construction, make sure you cannot set them afterwards and make sure that if "
"your users do not call <function><link linkend=\"g-object-new"
"\">g_object_new</link></function> with the required construction properties, "
"these will be initialized with the default values."
msgstr ""

#: tut_howto.xml:344(programlisting)
#, no-wrap
msgid ""
"\n"
"static void\n"
"bar_class_init (MamanBarClass *klass)\n"
"{\n"
"  GObjectClass *gobject_class = G_OBJECT_CLASS (klass);\n"
"  GParamSpec *pspec;\n"
"\n"
"  gobject_class-&gt;set_property = bar_set_property;\n"
"  gobject_class-&gt;get_property = bar_get_property;\n"
"\n"
"  pspec = g_param_spec_string (\"maman\",\n"
"                                          \"Maman construct prop\",\n"
"                                          \"Set maman's name\",\n"
"                                          \"no-name-set\" /* default value */,\n"
"                                          G_PARAM_CONSTRUCT_ONLY | G_PARAM_READWRITE);\n"
"  g_object_class_install_property (gobject_class,\n"
"                                   PROP_MAMAN,\n"
"                                   pspec);\n"
"}\n"
msgstr ""

#: tut_howto.xml:37(para)
msgid ""
"If your users are a bit accustomed to GTK+ code or any GLib code, they will "
"be a bit surprised and getting used to the conventions you decided upon will "
"take time (money) and will make them grumpy (not a good thing)"
msgstr ""

#: tut_howto.xml:370(para)
msgid ""
"I consider good taste to halt program execution if a construction property "
"is set its default value. This allows you to catch client code which does "
"not give a reasonable value to the construction properties. Of course, you "
"are free to disagree but you should have a good reason to do so."
msgstr ""

#: tut_howto.xml:377(para)
msgid ""
"Some people sometimes need to construct their object but only after the "
"construction properties have been set. This is possible through the use of "
"the constructor class method as described in <xref linkend=\"gobject-"
"instantiation\"/> or, more simply, using the constructed class method "
"available since GLib 2.12."
msgstr ""

#: tut_howto.xml:387(title)
msgid "Object Destruction"
msgstr ""

#: tut_howto.xml:389(para)
msgid ""
"Again, it is often difficult to figure out which mechanism to use to hook "
"into the object's destruction process: when the last <function><link linkend="
"\"g-object-unref\">g_object_unref</link></function> function call is made, a "
"lot of things happen as described in <xref linkend=\"gobject-destruction-"
"table\"/>."
msgstr ""

#: tut_howto.xml:397(para)
msgid ""
"The destruction process of your object might be split in two different "
"phases: dispose and the finalize. <placeholder-1/>"
msgstr ""

#: tut_howto.xml:400(programlisting)
#, no-wrap
msgid ""
"\n"
"#define MAMAN_BAR_GET_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE ((obj), MAMAN_TYPE_BAR, MamanBarPrivate))\n"
"\n"
"struct _MamanBarPrivate\n"
"{\n"
"  GObject *an_object;\n"
"\n"
"  gchar *a_string;\n"
"};\n"
"\n"
"G_DEFINE_TYPE (MamanBar, maman_bar, G_TYPE_OBJECT);\n"
"\n"
"static void\n"
"maman_bar_dispose (GObject *gobject)\n"
"{\n"
"  MamanBar *self = MAMAN_BAR (gobject);\n"
"\n"
"  /* \n"
"   * In dispose, you are supposed to free all types referenced from this\n"
"   * object which might themselves hold a reference to self. Generally,\n"
"   * the most simple solution is to unref all members on which you own a \n"
"   * reference.\n"
"   */\n"
"\n"
"  /* dispose might be called multiple times, so we must guard against\n"
"   * calling g_object_unref() on an invalid GObject.\n"
"   */\n"
"  if (self-&gt;priv-&gt;an_object)\n"
"    {\n"
"      g_object_unref (self-&gt;priv-&gt;an_object);\n"
"\n"
"      self-&gt;priv-&gt;an_object = NULL;\n"
"    }\n"
"\n"
"  /* Chain up to the parent class */\n"
"  G_OBJECT_CLASS (maman_bar_parent_class)-&gt;dispose (gobject);\n"
"}\n"
"\n"
"static void\n"
"maman_bar_finalize (GObject *gobject)\n"
"{\n"
"  MamanBar *self = MAMAN_BAR (gobject);\n"
"\n"
"  g_free (self-&gt;priv-&gt;a_string);\n"
"\n"
"  /* Chain up to the parent class */\n"
"  G_OBJECT_CLASS (maman_bar_parent_class)-&gt;finalize (gobject);\n"
"}\n"
"\n"
"static void\n"
"maman_bar_class_init (MamanBarClass *klass)\n"
"{\n"
"  GObjectClass *gobject_class = G_OBJECT_CLASS (klass);\n"
"\n"
"  gobject_class-&gt;dispose = maman_bar_dispose;\n"
"  gobject_class-&gt;finalize = maman_bar_finalize;\n"
"\n"
"  g_type_class_add_private (klass, sizeof (MamanBarPrivate));\n"
"}\n"
"\n"
"static void\n"
"maman_bar_init (MamanBar *self);\n"
"{\n"
"  self-&gt;priv = MAMAN_BAR_GET_PRIVATE (self);\n"
"\n"
"  self-&gt;priv-&gt;an_object = g_object_new (MAMAN_TYPE_BAZ, NULL);\n"
"  self-&gt;priv-&gt;a_string = g_strdup (\"Maman\");\n"
"}\n"
msgstr ""

#: tut_howto.xml:41(para)
msgid ""
"You must assess the fact that these conventions might have been designed by "
"both smart and experienced people: maybe they were at least partly right. "
"Try to put your ego aside."
msgstr ""

#: tut_howto.xml:47(para)
msgid ""
"Pick a name convention for your headers and source code and stick to it: "
"<placeholder-1/> Some people like the first two solutions better: it makes "
"reading file names easier for those with poor eyesight."
msgstr ""

#: tut_howto.xml:471(para)
msgid ""
"Add similar code to your GObject, make sure the code still builds and runs: "
"dispose and finalize must be called during the last unref."
msgstr ""

#: tut_howto.xml:476(para)
msgid ""
"It is possible that object methods might be invoked after dispose is run and "
"before finalize runs. GObject does not consider this to be a program error: "
"you must gracefully detect this and neither crash nor warn the user."
msgstr ""

#: tut_howto.xml:485(title)
msgid "Object methods"
msgstr ""

#: tut_howto.xml:487(para)
msgid ""
"Just as with C++, there are many different ways to define object methods and "
"extend them: the following list and sections draw on C++ vocabulary. "
"(Readers are expected to know basic C++ buzzwords. Those who have not had to "
"write C++ code recently can refer to e.g. <ulink url=\"http://www.cplusplus."
"com/doc/tutorial/\"/> to refresh their memories.) <placeholder-1/>"
msgstr ""

#: tut_howto.xml:495(para)
msgid "non-virtual public methods,"
msgstr ""

#: tut_howto.xml:498(para)
msgid "virtual public methods and"
msgstr ""

#: tut_howto.xml:50(para)
msgid ""
"use a dash to separate the prefix from the typename: <filename>maman-bar.h</"
"filename> and <filename>maman-bar.c</filename> (this is the convention used "
"by Nautilus and most GNOME libraries)."
msgstr ""

#: tut_howto.xml:501(para)
msgid "virtual private methods"
msgstr ""

#: tut_howto.xml:508(title)
msgid "Non-virtual public methods"
msgstr ""

#: tut_howto.xml:510(para)
msgid ""
"These are the simplest: you want to provide a simple method which can act on "
"your object. All you need to do is to provide a function prototype in the "
"header and an implementation of that prototype in the source file. "
"<placeholder-1/>"
msgstr ""

#: tut_howto.xml:515(programlisting)
#, no-wrap
msgid ""
"\n"
"/* declaration in the header. */\n"
"void maman_bar_do_action (MamanBar *self, /* parameters */);\n"
"\n"
"/* implementation in the source file */\n"
"void\n"
"maman_bar_do_action (MamanBar *self, /* parameters */)\n"
"{\n"
"  g_return_if_fail (MAMAN_IS_BAR (self));\n"
"\n"
"  /* do stuff here. */\n"
"}\n"
msgstr ""

#: tut_howto.xml:53(para)
msgid ""
"use an underscore to separate the prefix from the typename: "
"<filename>maman_bar.h</filename> and <filename>maman_bar.c</filename>."
msgstr ""

#: tut_howto.xml:530(para)
msgid "There is really nothing scary about this."
msgstr ""

#: tut_howto.xml:534(title)
msgid "Virtual public methods"
msgstr ""

#: tut_howto.xml:536(para)
msgid ""
"This is the preferred way to create polymorphic GObjects. All you need to do "
"is to define the common method and its class function in the public header, "
"implement the common method in the source file and re-implement the class "
"function in each object which inherits from you. <placeholder-1/> The code "
"above simply redirects the do_action call to the relevant class function. "
"Some users, concerned about performance, do not provide the "
"<function>maman_bar_do_action</function> wrapper function and require users "
"to dereference the class pointer themselves. This is not such a great idea "
"in terms of encapsulation and makes it difficult to change the object's "
"implementation afterwards, should this be needed."
msgstr ""

#: tut_howto.xml:542(programlisting)
#, no-wrap
msgid ""
"\n"
"/* declaration in maman-bar.h. */\n"
"struct _MamanBarClass\n"
"{\n"
"  GObjectClass parent_class;\n"
"\n"
"  /* stuff */\n"
"  void (*do_action) (MamanBar *self, /* parameters */);\n"
"};\n"
"\n"
"void maman_bar_do_action (MamanBar *self, /* parameters */);\n"
"\n"
"/* implementation in maman-bar.c */\n"
"void\n"
"maman_bar_do_action (MamanBar *self, /* parameters */)\n"
"{\n"
"  g_return_if_fail (MAMAN_IS_BAR (self));\n"
"\n"
"  MAMAN_BAR_GET_CLASS (self)-&gt;do_action (self, /* parameters */);\n"
"}\n"
msgstr ""

#: tut_howto.xml:56(para)
msgid ""
"Do not separate the prefix from the typename: <filename>mamanbar.h</"
"filename> and <filename>mamanbar.c</filename>. (this is the convention used "
"by GTK+)"
msgstr ""

#: tut_howto.xml:572(para)
msgid ""
"Other users, also concerned by performance issues, declare the "
"<function>maman_bar_do_action</function> function inline in the header file. "
"This, however, makes it difficult to change the object's implementation "
"later (although easier than requiring users to directly dereference the "
"class function) and is often difficult to write in a portable way (the "
"<emphasis>inline</emphasis> keyword is part of the C99 standard but not "
"every compiler supports it)."
msgstr ""

#: tut_howto.xml:582(para)
msgid ""
"In doubt, unless a user shows you hard numbers about the performance cost of "
"the function call, just implement <function>maman_bar_do_action</function> "
"in the source file."
msgstr ""

#: tut_howto.xml:588(para)
msgid ""
"Please, note that it is possible for you to provide a default implementation "
"for this class method in the object's <function>class_init</function> "
"function: initialize the klass-&gt;do_action field to a pointer to the "
"actual implementation. You can also make this class method pure virtual by "
"initializing the klass-&gt;do_action field to NULL: <placeholder-1/>"
msgstr ""

#: tut_howto.xml:595(programlisting)
#, no-wrap
msgid ""
"\n"
"static void\n"
"maman_bar_real_do_action_two (MamanBar *self, /* parameters */)\n"
"{\n"
"  /* Default implementation for the virtual method. */\n"
"}\n"
"\n"
"static void\n"
"maman_bar_class_init (BarClass *klass)\n"
"{\n"
"  /* pure virtual method: mandates implementation in children. */\n"
"  klass-&gt;do_action_one = NULL;\n"
"\n"
"  /* merely virtual method. */\n"
"  klass-&gt;do_action_two = maman_bar_real_do_action_two;\n"
"}\n"
"\n"
"void\n"
"maman_bar_do_action_one (MamanBar *self, /* parameters */)\n"
"{\n"
"  g_return_if_fail (MAMAN_IS_BAR (self));\n"
"\n"
"  MAMAN_BAR_GET_CLASS (self)-&gt;do_action_one (self, /* parameters */);\n"
"}\n"
"\n"
"void\n"
"maman_bar_do_action_two (MamanBar *self, /* parameters */)\n"
"{\n"
"  g_return_if_fail (MAMAN_IS_BAR (self));\n"
"\n"
"  MAMAN_BAR_GET_CLASS (self)-&gt;do_action_two (self, /* parameters */);\n"
"}\n"
msgstr ""

#: tut_howto.xml:6(title)
msgid "Tutorial"
msgstr ""

#: tut_howto.xml:632(title)
msgid "Virtual private Methods"
msgstr ""

#: tut_howto.xml:634(para)
msgid ""
"These are very similar to Virtual Public methods. They just don't have a "
"public function to call the function directly. The header file contains only "
"a declaration of the class function: <placeholder-1/> These class functions "
"are often used to delegate part of the job to child classes: <placeholder-2/>"
msgstr ""

#: tut_howto.xml:638(programlisting)
#, no-wrap
msgid ""
"\n"
"/* declaration in maman-bar.h. */\n"
"struct _MamanBarClass\n"
"{\n"
"  GObjectClass parent;\n"
"\n"
"  /* stuff */\n"
"  void (* helper_do_specific_action) (MamanBar *self, /* parameters */);\n"
"};\n"
"\n"
"void maman_bar_do_any_action (MamanBar *self, /* parameters */);\n"
msgstr ""

#: tut_howto.xml:64(para)
msgid ""
"When you need some private (internal) declarations in several (sub)classes, "
"you can define them in a private header file which is often named by "
"appending the <emphasis>private</emphasis> keyword to the public header "
"name. For example, one could use <filename>maman-bar-private.h</filename>, "
"<filename>maman_bar_private.h</filename> or <filename>mamanbarprivate.h</"
"filename>. Typically, such private header files are not installed."
msgstr ""

#: tut_howto.xml:652(programlisting)
#, no-wrap
msgid ""
"\n"
"/* this accessor function is static: it is not exported outside of this file. */\n"
"static void \n"
"maman_bar_do_specific_action (MamanBar *self, /* parameters */)\n"
"{\n"
"  MAMAN_BAR_GET_CLASS (self)-&gt;do_specific_action (self, /* parameters */);\n"
"}\n"
"\n"
"void\n"
"maman_bar_do_any_action (MamanBar *self, /* parameters */)\n"
"{\n"
"  /* random code here */\n"
"\n"
"  /* \n"
"   * Try to execute the requested action. Maybe the requested action\n"
"   * cannot be implemented here. So, we delegate its implementation\n"
"   * to the child class:\n"
"   */\n"
"  maman_bar_do_specific_action (self, /* parameters */);\n"
"\n"
"  /* other random code here */\n"
"}\n"
msgstr ""

#: tut_howto.xml:677(para)
msgid ""
"Again, it is possible to provide a default implementation for this private "
"virtual class function: <placeholder-1/>"
msgstr ""

#: tut_howto.xml:680(programlisting)
#, no-wrap
msgid ""
"\n"
"static void\n"
"maman_bar_class_init (MamanBarClass *klass)\n"
"{\n"
"  /* pure virtual method: mandates implementation in children. */\n"
"  klass-&gt;do_specific_action_one = NULL;\n"
"\n"
"  /* merely virtual method. */\n"
"  klass-&gt;do_specific_action_two = maman_bar_real_do_specific_action_two;\n"
"}\n"
msgstr ""

#: tut_howto.xml:693(para)
msgid ""
"Children can then implement the subclass with code such as: <placeholder-1/>"
msgstr ""

#: tut_howto.xml:695(programlisting)
#, no-wrap
msgid ""
"\n"
"static void\n"
"maman_bar_subtype_class_init (MamanBarSubTypeClass *klass)\n"
"{\n"
"  MamanBarClass *bar_class = MAMAN_BAR_CLASS (klass);\n"
"\n"
"  /* implement pure virtual class function. */\n"
"  bar_class-&gt;do_specific_action_one = maman_bar_subtype_do_specific_action_one;\n"
"}\n"
msgstr ""

#: tut_howto.xml:710(title)
msgid "Chaining up"
msgstr ""

#: tut_howto.xml:712(para)
msgid ""
"Chaining up is often loosely defined by the following set of conditions: "
"<placeholder-1/> There are many uses to this idiom: <placeholder-2/> I am "
"personally not really convinced any of the last two uses are really a good "
"idea but since this programming idiom is often used, this section attempts "
"to explain how to implement it."
msgstr ""

#: tut_howto.xml:715(para)
msgid ""
"Parent class A defines a public virtual method named <function>foo</"
"function> and provides a default implementation."
msgstr ""

#: tut_howto.xml:717(para)
msgid "Child class B re-implements method <function>foo</function>."
msgstr ""

#: tut_howto.xml:718(para)
msgid ""
"In the method B::foo, the child class B calls its parent class method A::foo."
msgstr ""

#: tut_howto.xml:722(para)
msgid ""
"You need to change the behaviour of a class without modifying its code. You "
"create a subclass to inherit its implementation, re-implement a public "
"virtual method to modify the behaviour slightly and chain up to ensure that "
"the previous behaviour is not really modified, just extended."
msgstr ""

#: tut_howto.xml:726(para)
msgid ""
"You are lazy, you have access to the source code of the parent class but you "
"don't want to modify it to add method calls to new specialized method calls: "
"it is faster to hack the child class to chain up than to modify the parent "
"to call down."
msgstr ""

#: tut_howto.xml:729(para)
msgid ""
"You need to implement the Chain Of Responsibility pattern: each object of "
"the inheritance tree chains up to its parent (typically, at the beginning or "
"the end of the method) to ensure that they each handler is run in turn."
msgstr ""

#: tut_howto.xml:737(para)
msgid ""
"To explicitly chain up to the implementation of the virtual method in the "
"parent class, you first need a handle to the original parent class "
"structure. This pointer can then be used to access the original class "
"function pointer and invoke it directly. <placeholder-1/>"
msgstr ""

#: tut_howto.xml:742(para)
msgid ""
"The <emphasis>original</emphasis> adjective used in this sentence is not "
"innocuous. To fully understand its meaning, you need to recall how class "
"structures are initialized: for each object type, the class structure "
"associated to this object is created by first copying the class structure of "
"its parent type (a simple <function>memcpy</function>) and then by invoking "
"the class_init callback on the resulting class structure. Since the "
"class_init callback is responsible for overwriting the class structure with "
"the user re-implementations of the class methods, we cannot merely use the "
"modified copy of the parent class structure stored in our derived instance. "
"We want to get a copy of the class structure of an instance of the parent "
"class."
msgstr ""

#: tut_howto.xml:75(para)
msgid ""
"The basic conventions for any header which exposes a GType are described in "
"<xref linkend=\"gtype-conventions\"/>. Most GObject-based code also obeys "
"one of of the following conventions: pick one and stick to it. "
"<placeholder-1/>"
msgstr ""

#: tut_howto.xml:755(para)
msgid ""
"The function <function><link linkend=\"g-type-class-peek-parent"
"\">g_type_class_peek_parent</link></function> is used to access the original "
"parent class structure. Its input is a pointer to the class of the derived "
"object and it returns a pointer to the original parent class structure. The "
"code below shows how you could use it: <placeholder-1/>"
msgstr ""

#: tut_howto.xml:758(programlisting)
#, no-wrap
msgid ""
"\n"
"static void\n"
"b_method_to_call (B *obj, int a)\n"
"{\n"
"  BClass *klass;\n"
"  AClass *parent_class;\n"
"\n"
"  klass = B_GET_CLASS (obj);\n"
"  parent_class = g_type_class_peek_parent (klass);\n"
"\n"
"  /* do stuff before chain up */\n"
"\n"
"  parent_class-&gt;method_to_call (obj, a);\n"
"\n"
"  /* do stuff after chain up */\n"
"}\n"
msgstr ""

#: tut_howto.xml:783(title)
msgid "How to define and implement interfaces"
msgstr ""

#: tut_howto.xml:786(title)
msgid "How to define interfaces"
msgstr ""

#: tut_howto.xml:788(para)
msgid ""
"The bulk of interface definition has already been shown in <xref linkend="
"\"gtype-non-instantiable-classed\"/> but I feel it is needed to show exactly "
"how to create an interface."
msgstr ""

#: tut_howto.xml:793(para)
msgid ""
"As above, the first step is to get the header right: <placeholder-1/> This "
"code is the same as the code for a normal <link linkend=\"GType"
"\"><type>GType</type></link> which derives from a <link linkend=\"GObject"
"\"><type>GObject</type></link> except for a few details: <placeholder-2/>"
msgstr ""

#: tut_howto.xml:795(programlisting)
#, no-wrap
msgid ""
"\n"
"#ifndef __MAMAN_IBAZ_H__\n"
"#define __MAMAN_IBAZ_H__\n"
"\n"
"#include &lt;glib-object.h&gt;\n"
"\n"
"#define MAMAN_TYPE_IBAZ                 (maman_ibaz_get_type ())\n"
"#define MAMAN_IBAZ(obj)                 (G_TYPE_CHECK_INSTANCE_CAST ((obj), MAMAN_TYPE_IBAZ, MamanIbaz))\n"
"#define MAMAN_IS_IBAZ(obj)              (G_TYPE_CHECK_INSTANCE_TYPE ((obj), MAMAN_TYPE_IBAZ))\n"
"#define MAMAN_IBAZ_GET_INTERFACE(inst)  (G_TYPE_INSTANCE_GET_INTERFACE ((inst), MAMAN_TYPE_IBAZ, MamanIbazInterface))\n"
"\n"
"\n"
"typedef struct _MamanIbaz               MamanIbaz; /* dummy object */\n"
"typedef struct _MamanIbazInterface      MamanIbazInterface;\n"
"\n"
"struct _MamanIbazInterface\n"
"{\n"
"  GTypeInterface parent_iface;\n"
"\n"
"  void (*do_action) (MamanIbaz *self);\n"
"};\n"
"\n"
"GType maman_ibaz_get_type (void);\n"
"\n"
"void maman_ibaz_do_action (MamanIbaz *self);\n"
"\n"
"#endif /* __MAMAN_IBAZ_H__ */\n"
msgstr ""

#: tut_howto.xml:8(para)
msgid ""
"This chapter tries to answer the real-life questions of users and presents "
"the most common scenario use cases I could come up with. The use cases are "
"presented from most likely to less likely."
msgstr ""

#: tut_howto.xml:80(para)
msgid ""
"If you want to declare a type named bar with prefix maman, name the type "
"instance <function>MamanBar</function> and its class "
"<function>MamanBarClass</function> (name is case-sensitive). It is customary "
"to declare them with code similar to the following: <placeholder-1/>"
msgstr ""

#: tut_howto.xml:826(para)
msgid ""
"The <function>_GET_CLASS</function> macro is called "
"<function>_GET_INTERFACE</function> and not implemented with <function><link "
"linkend=\"G_TYPE_INSTANCE_GET_CLASS\">G_TYPE_INSTANCE_GET_CLASS</link></"
"function> but with <function><link linkend=\"G_TYPE_INSTANCE_GET_INTERFACE"
"\">G_TYPE_INSTANCE_GET_INTERFACE</link></function>."
msgstr ""

#: tut_howto.xml:831(para)
msgid ""
"The instance type, <type>MamanIbaz</type> is not fully defined: it is used "
"merely as an abstract type which represents an instance of whatever object "
"which implements the interface."
msgstr ""

#: tut_howto.xml:836(para)
msgid ""
"The parent of the <type>MamanIbazInterface</type> is not <type>GObjectClass</"
"type> but <type>GTypeInterface</type>."
msgstr ""

#: tut_howto.xml:843(para)
msgid ""
"The implementation of the <type>MamanIbaz</type> type itself is trivial: "
"<placeholder-1/><placeholder-2/>"
msgstr ""

#: tut_howto.xml:846(para)
msgid ""
"<function>maman_ibaz_get_type</function> registers the type in the type "
"system."
msgstr ""

#: tut_howto.xml:849(para)
msgid ""
"<function>maman_ibaz_base_init</function> is expected to register the "
"interface's signals if there are any (we will see a bit (later how to use "
"them). Make sure to use a static local boolean variable to make sure not to "
"run the initialization code twice (as described in <xref linkend=\"gtype-non-"
"instantiable-classed-init\"/>, <function>base_init</function> is run once "
"for each interface implementation instantiation)"
msgstr ""

#: tut_howto.xml:85(programlisting)
#, no-wrap
msgid ""
"\n"
"/*\n"
" * Copyright/Licensing information.\n"
" */\n"
"\n"
"/* inclusion guard */\n"
"#ifndef __MAMAN_BAR_H__\n"
"#define __MAMAN_BAR_H__\n"
"\n"
"#include &lt;glib-object.h&gt;\n"
"/*\n"
" * Potentially, include other headers on which this header depends.\n"
" */\n"
"\n"
"/*\n"
" * Type macros.\n"
" */\n"
"#define MAMAN_TYPE_BAR                  (maman_bar_get_type ())\n"
"#define MAMAN_BAR(obj)                  (G_TYPE_CHECK_INSTANCE_CAST ((obj), MAMAN_TYPE_BAR, MamanBar))\n"
"#define MAMAN_IS_BAR(obj)               (G_TYPE_CHECK_INSTANCE_TYPE ((obj), MAMAN_TYPE_BAR))\n"
"#define MAMAN_BAR_CLASS(klass)          (G_TYPE_CHECK_CLASS_CAST ((klass), MAMAN_TYPE_BAR, MamanBarClass))\n"
"#define MAMAN_IS_BAR_CLASS(klass)       (G_TYPE_CHECK_CLASS_TYPE ((klass), MAMAN_TYPE_BAR))\n"
"#define MAMAN_BAR_GET_CLASS(obj)        (G_TYPE_INSTANCE_GET_CLASS ((obj), MAMAN_TYPE_BAR, MamanBarClass))\n"
"\n"
"typedef struct _MamanBar        MamanBar;\n"
"typedef struct _MamanBarClass   MamanBarClass;\n"
"\n"
"struct _MamanBar\n"
"{\n"
"  GObject parent_instance;\n"
"\n"
"  /* instance members */\n"
"};\n"
"\n"
"struct _MamanBarClass\n"
"{\n"
"  GObjectClass parent_class;\n"
"\n"
"  /* class members */\n"
"};\n"
"\n"
"/* used by MAMAN_TYPE_BAR */\n"
"GType maman_bar_get_type (void);\n"
"\n"
"/*\n"
" * Method definitions.\n"
" */\n"
"\n"
"#endif /* __MAMAN_BAR_H__ */\n"
msgstr ""

#: tut_howto.xml:856(para)
msgid ""
"<function>maman_ibaz_do_action</function> dereferences the class structure "
"to access its associated class function and calls it."
msgstr ""

#: tut_howto.xml:860(programlisting)
#, no-wrap
msgid ""
"\n"
"static void\n"
"maman_ibaz_base_init (gpointer g_class)\n"
"{\n"
"  static gboolean is_initialized = FALSE;\n"
"\n"
"  if (!is_initialized)\n"
"    {\n"
"      /* add properties and signals to the interface here */\n"
"\n"
"      is_initialized = TRUE;\n"
"    }\n"
"}\n"
"\n"
"GType\n"
"maman_ibaz_get_type (void)\n"
"{\n"
"  static GType iface_type = 0;\n"
"  if (iface_type == 0)\n"
"    {\n"
"      static const GTypeInfo info = {\n"
"        sizeof (MamanIbazInterface),\n"
"        maman_ibaz_base_init,   /* base_init */\n"
"        NULL,   /* base_finalize */\n"
"      };\n"
"\n"
"      iface_type = g_type_register_static (G_TYPE_INTERFACE, \"MamanIbaz\",\n"
"                                           &amp;info, 0);\n"
"    }\n"
"\n"
"  return iface_type;\n"
"}\n"
"\n"
"void\n"
"maman_ibaz_do_action (MamanIbaz *self)\n"
"{\n"
"  g_return_if_fail (MAMAN_IS_IBAZ (self));\n"
"\n"
"  MAMAN_IBAZ_GET_INTERFACE (self)-&gt;do_action (self);\n"
"}\n"
msgstr ""

#: tut_howto.xml:905(title)
msgid "How To define implement an Interface?"
msgstr ""

#: tut_howto.xml:907(para)
msgid "Once the interface is defined, implementing it is rather trivial."
msgstr ""

#: tut_howto.xml:911(para)
msgid ""
"The first step is to define a normal GObject class, like: <placeholder-1/> "
"There is clearly nothing specifically weird or scary about this header: it "
"does not define any weird API or derives from a weird type."
msgstr ""

#: tut_howto.xml:913(programlisting)
#, no-wrap
msgid ""
"\n"
"#ifndef __MAMAN_BAZ_H__\n"
"#define __MAMAN_BAZ_H__\n"
"\n"
"#include &lt;glib-object.h&gt;\n"
"\n"
"#define MAMAN_TYPE_BAZ             (maman_baz_get_type ())\n"
"#define MAMAN_BAZ(obj)             (G_TYPE_CHECK_INSTANCE_CAST ((obj), MAMAN_TYPE_BAZ, Mamanbaz))\n"
"#define MAMAN_IS_BAZ(obj)          (G_TYPE_CHECK_INSTANCE_TYPE ((obj), MAMAN_TYPE_BAZ))\n"
"#define MAMAN_BAZ_CLASS(klass)     (G_TYPE_CHECK_CLASS_CAST ((klass), MAMAN_TYPE_BAZ, MamanbazClass))\n"
"#define MAMAN_IS_BAZ_CLASS(klass)  (G_TYPE_CHECK_CLASS_TYPE ((klass), MAMAN_TYPE_BAZ))\n"
"#define MAMAN_BAZ_GET_CLASS(obj)   (G_TYPE_INSTANCE_GET_CLASS ((obj), MAMAN_TYPE_BAZ, MamanbazClass))\n"
"\n"
"\n"
"typedef struct _MamanBaz        MamanBaz;\n"
"typedef struct _MamanBazClass   MamanBazClass;\n"
"\n"
"struct _MamanBaz\n"
"{\n"
"  GObject parent_instance;\n"
"\n"
"  int instance_member;\n"
"};\n"
"\n"
"struct _MamanBazClass\n"
"{\n"
"  GObjectClass parent_class;\n"
"};\n"
"\n"
"GType maman_baz_get_type (void);\n"
"\n"
"#endif /* __MAMAN_BAZ_H__ */\n"
msgstr ""

#: tut_howto.xml:950(para)
msgid ""
"The second step is to implement <type>MamanBaz</type> by defining its GType. "
"Instead of using <function>G_DEFINE_TYPE</function> we use "
"<function>G_DEFINE_TYPE_WITH_CODE</function> and the "
"<function>G_IMPLEMENT_INTERFACE</function> macros. <placeholder-1/> This "
"definition is very much like all the similar functions we looked at "
"previously. The only interface-specific code present here is the call to "
"<function>G_IMPLEMENT_INTERFACE</function>."
msgstr ""

#: tut_howto.xml:955(programlisting)
#, no-wrap
msgid ""
"\n"
"static void maman_ibaz_interface_init (MamanIbazInterface *iface);\n"
"\n"
"G_DEFINE_TYPE_WITH_CODE (MamanBar, maman_bar, G_TYPE_OBJECT,\n"
"                         G_IMPLEMENT_INTERFACE (MAMAN_TYPE_IBAZ,\n"
"                                                maman_ibaz_interface_init));\n"
msgstr ""

#: tut_howto.xml:967(para)
msgid ""
"Classes can implement multiple interfaces by using multiple calls to "
"<function>G_IMPLEMENT_INTERFACE</function> inside the call to "
"<function>G_DEFINE_TYPE_WITH_CODE</function>."
msgstr ""

#: tut_howto.xml:971(para)
msgid ""
"<function>maman_baz_interface_init</function>, the interface initialization "
"function: inside it every virtual method of the interface must be assigned "
"to its implementation: <placeholder-1/>"
msgstr ""

#: tut_howto.xml:975(programlisting)
#, no-wrap
msgid ""
"\n"
"static void\n"
"maman_baz_do_action (MamanBaz *self)\n"
"{\n"
"  g_print (\"Baz implementation of IBaz interface Action: 0x%x.\\n\",\n"
"           self-&gt;instance_member);\n"
"}\n"
"\n"
"static void\n"
"maman_ibaz_interface_init (MamanIbazInterface *iface)\n"
"{\n"
"  iface-&gt;do_action = baz_do_action;\n"
"}\n"
"\n"
"static void\n"
"maman_baz_init (MamanBaz *self)\n"
"{\n"
"  MamanBaz *self = MAMAN_BAZ (instance);\n"
"  self-&gt;instance_member = 0xdeadbeaf;\n"
"}\n"
msgstr ""

#: tut_intro.xml:112(para)
msgid ""
"Now, let's say we want to call the C function <function>function_foo</"
"function> from a Python program. To do this, the Python interpreter needs "
"to: <placeholder-1/>"
msgstr ""

#: tut_intro.xml:116(para)
msgid ""
"Find where the function is located. This probably means finding the binary "
"generated by the C compiler which exports this function."
msgstr ""

#: tut_intro.xml:118(para)
msgid "Load the code of the function in executable memory."
msgstr ""

#: tut_intro.xml:119(para)
msgid ""
"Convert the Python parameters to C-compatible parameters before calling the "
"function."
msgstr ""

#: tut_intro.xml:12(para)
msgid "object-oriented C-based APIs and"
msgstr ""

#: tut_intro.xml:121(para)
msgid "Call the function with the right calling convention."
msgstr ""

#: tut_intro.xml:122(para)
msgid ""
"Convert the return values of the C function to Python-compatible variables "
"to return them to the Python code."
msgstr ""

#: tut_intro.xml:127(para)
msgid ""
"The process described above is pretty complex and there are a lot of ways to "
"make it entirely automatic and transparent to C and Python programmers: "
"<placeholder-1/> The greatest advantage of the solution implemented by GType "
"is that the glue code sitting at the runtime domain boundaries is written "
"once: the figure below states this more clearly. <placeholder-2/> Currently, "
"there exist at least Python and Perl generic glue code which makes it "
"possible to use C objects written with GType directly in Python or Perl, "
"with a minimum amount of work: there is no need to generate huge amounts of "
"glue code either automatically or by hand."
msgstr ""

#: tut_intro.xml:13(para)
msgid ""
"automatic transparent API bindings to other compiled or interpreted "
"languages."
msgstr ""

#: tut_intro.xml:131(para)
msgid ""
"The first solution is to write by hand a lot of glue code, once for each "
"function exported or imported, which does the Python-to-C parameter "
"conversion and the C-to-Python return value conversion. This glue code is "
"then linked with the interpreter which allows Python programs to call Python "
"functions which delegate work to C functions."
msgstr ""

#: tut_intro.xml:135(para)
msgid ""
"Another, nicer solution is to automatically generate the glue code, once for "
"each function exported or imported, with a special compiler which reads the "
"original function signature."
msgstr ""

#: tut_intro.xml:138(para)
msgid ""
"The solution used by GLib is to use the GType library which holds at runtime "
"a description of all the objects manipulated by the programmer. This so-"
"called <emphasis>dynamic type</emphasis><placeholder-1/> library is then "
"used by special generic glue code to automatically convert function "
"parameters and function calling conventions between different runtime "
"domains."
msgstr ""

#: tut_intro.xml:141(para)
msgid ""
"There are numerous different implementations of dynamic type systems: all C+"
"+ compilers have one, Java and .NET have one too. A dynamic type system "
"allows you to get information about every instantiated object at runtime. It "
"can be implemented by a process-specific database: every new object created "
"registers the characteristics of its associated type in the type system. It "
"can also be implemented by introspection interfaces. The common point "
"between all these different type systems and implementations is that they "
"all allow you to query for object metadata at runtime."
msgstr ""

#. When image changes, this message will be marked fuzzy or untranslated for you.
#. It doesn't matter what you translate it to: it's not used at all.
#: tut_intro.xml:159(None)
msgid "@@image: 'glue.png'; md5=THIS FILE DOESN'T EXIST"
msgstr ""

#. When image changes, this message will be marked fuzzy or untranslated for you.
#. It doesn't matter what you translate it to: it's not used at all.
#: tut_intro.xml:162(None)
msgid "@@image: 'glue.jpg'; md5=THIS FILE DOESN'T EXIST"
msgstr ""

#: tut_intro.xml:172(para)
msgid ""
"Although that goal was arguably laudable, its pursuit has had a major "
"influence on the whole GType/GObject library. C programmers are likely to be "
"puzzled at the complexity of the features exposed in the following chapters "
"if they forget that the GType/GObject library was not only designed to offer "
"OO-like features to C programmers but also transparent cross-language "
"interoperability."
msgstr ""

#: tut_intro.xml:18(para)
msgid ""
"A lot of programmers are used to working with compiled-only or dynamically "
"interpreted-only languages and do not understand the challenges associated "
"with cross-language interoperability. This introduction tries to provide an "
"insight into these challenges and briefly describes the solution chosen by "
"GLib."
msgstr ""

#: tut_intro.xml:25(para)
msgid ""
"The following chapters go into greater detail into how GType and GObject "
"work and how you can use them as a C programmer. It is useful to keep in "
"mind that allowing access to C objects from other interpreted languages was "
"one of the major design goals: this can often explain the sometimes rather "
"convoluted APIs and features present in this library."
msgstr ""

#: tut_intro.xml:34(title)
msgid "Data types and programming"
msgstr ""

#: tut_intro.xml:36(para)
msgid ""
"One could say (I have seen such definitions used in some textbooks on "
"programming language theory) that a programming language is merely a way to "
"create data types and manipulate them. Most languages provide a number of "
"language-native types and a few primitives to create more complex types "
"based on these primitive types."
msgstr ""

#: tut_intro.xml:43(para)
msgid ""
"In C, the language provides types such as <emphasis>char</emphasis>, "
"<emphasis>long</emphasis>, <emphasis>pointer</emphasis>. During compilation "
"of C code, the compiler maps these language types to the compiler's target "
"architecture machine types. If you are using a C interpreter (I have never "
"seen one myself but it is possible :), the interpreter (the program which "
"interprets the source code and executes it) maps the language types to the "
"machine types of the target machine at runtime, during the program execution "
"(or just before execution if it uses a Just In Time compiler engine)."
msgstr ""

#: tut_intro.xml:52(para)
msgid ""
"Perl and Python are interpreted languages which do not really provide type "
"definitions similar to those used by C. Perl and Python programmers "
"manipulate variables and the type of the variables is decided only upon the "
"first assignment or upon the first use which forces a type on the variable. "
"The interpreter also often provides a lot of automatic conversions from one "
"type to the other. For example, in Perl, a variable which holds an integer "
"can be automatically converted to a string given the required context: "
"<placeholder-1/> Of course, it is also often possible to explicitly specify "
"conversions when the default conversions provided by the language are not "
"intuitive."
msgstr ""

#: tut_intro.xml:59(programlisting)
#, no-wrap
msgid ""
"\n"
"my $tmp = 10;\n"
"print \"this is an integer converted to a string:\" . $tmp . \"\\n\";\n"
msgstr ""

#: tut_intro.xml:6(title)
msgid "Background"
msgstr "背景"

#: tut_intro.xml:70(title)
msgid "Exporting a C API"
msgstr ""

#: tut_intro.xml:72(para)
msgid ""
"C APIs are defined by a set of functions and global variables which are "
"usually exported from a binary. C functions have an arbitrary number of "
"arguments and one return value. Each function is thus uniquely identified by "
"the function name and the set of C types which describe the function "
"arguments and return value. The global variables exported by the API are "
"similarly identified by their name and their type."
msgstr ""

#: tut_intro.xml:8(para)
msgid ""
"GObject, and its lower-level type system, GType, are used by GTK+ and most "
"GNOME libraries to provide: <placeholder-1/>"
msgstr ""

#: tut_intro.xml:80(para)
msgid ""
"A C API is thus merely defined by a set of names to which a set of types are "
"associated. If you know the function calling convention and the mapping of "
"the C types to the machine types used by the platform you are on, you can "
"resolve the name of each function to find where the code associated to this "
"function is located in memory, and then construct a valid argument list for "
"the function. Finally, all you have to do is trigger a call to the target C "
"function with the argument list."
msgstr ""

#: tut_intro.xml:88(para)
msgid ""
"For the sake of discussion, here is a sample C function and the associated "
"32 bit x86 assembly code generated by GCC on my Linux box: <placeholder-1/> "
"The assembly code shown above is pretty straightforward: the first "
"instruction pushes the hexadecimal value 0xa (decimal value 10) as a 32-bit "
"integer on the stack and calls <function>function_foo</function>. As you can "
"see, C function calls are implemented by gcc by native function calls (this "
"is probably the fastest implementation possible)."
msgstr ""

#: tut_intro.xml:91(programlisting)
#, no-wrap
msgid ""
"\n"
"static void function_foo (int foo)\n"
"{}\n"
"\n"
"int main (int argc, char *argv[])\n"
"{\n"
"\n"
"        function_foo (10);\n"
"\n"
"        return 0;\n"
"}\n"
"\n"
"push   $0xa\n"
"call   0x80482f4 &lt;function_foo&gt;\n"
msgstr ""

#: tut_tools.xml:100(para)
msgid ""
"The API documentation for most of the GLib, GObject, GTK+ and GNOME "
"libraries is built with a combination of complex tools. Typically, the part "
"of the documentation which describes the behavior of each function is "
"extracted from the specially-formatted source code comments by a tool named "
"gtk-doc which generates DocBook XML and merges this DocBook XML with a set "
"of master XML DocBook files. These XML DocBook files are finally processed "
"with xsltproc (a small program part of the libxslt library) to generate the "
"final HTML output. Other tools can be used to generate PDF output from the "
"source XML. The following code excerpt shows what these comments look like. "
"<placeholder-1/>"
msgstr ""

#: tut_tools.xml:109(programlisting)
#, no-wrap
msgid ""
"\n"
"/**\n"
" * gtk_widget_freeze_child_notify:\n"
" * @widget: a #GtkWidget\n"
" * \n"
" * Stops emission of \"child-notify\" signals on @widget. The signals are\n"
" * queued until gtk_widget_thaw_child_notify() is called on @widget. \n"
" *\n"
" * This is the analogue of g_object_freeze_notify() for child properties.\n"
" **/\n"
"void\n"
"gtk_widget_freeze_child_notify (GtkWidget *widget)\n"
"{\n"
"...\n"
"      "
msgstr ""

#: tut_tools.xml:125(para)
msgid ""
"Thorough <ulink url=\"http://library.gnome.org/devel/gtk-doc-manual/stable/"
"\">documentation</ulink> on how to set up and use gtk-doc in your project is "
"provided on the <ulink url=\"http://library.gnome.org/devel/\">GNOME "
"developer website</ulink>."
msgstr ""

#: tut_tools.xml:15(para)
msgid ""
"For example, writing GObjects is often seen as a tedious task. It requires a "
"lot of typing and just doing a copy/paste requires a great deal of care. A "
"lot of projects and scripts have been written to generate GObject skeleton "
"form boilerplate code, or even translating higher-level language into plain "
"C."
msgstr ""

#: tut_tools.xml:25(title)
msgid "Vala"
msgstr ""

#: tut_tools.xml:26(para)
msgid ""
"From the <ulink url=\"http://live.gnome.org/Vala\">Vala homepage</ulink> "
"itself: <quote>Vala is a new programming language that aims to bring modern "
"programming language features to GNOME developers without imposing any "
"additional runtime requirements and without using a different ABI compared "
"to applications and libraries written in C.</quote>"
msgstr ""

#: tut_tools.xml:35(para)
msgid ""
"The syntax of Vala is similar to C#. The available compiler translates Vala "
"into GObject C code. It can also compile non-GObject C, using plain C API."
msgstr ""

#: tut_tools.xml:43(title)
msgid "GObject builder"
msgstr ""

#: tut_tools.xml:45(para)
msgid ""
"In order to help a GObject class developper, one obvious idea is to use some "
"sort of templates for the skeletons. and then run them through a special "
"tool to generate the real C files. <ulink url=\"http://www.5z.com/jirka/gob."
"html\">GOB</ulink> (or GOB2) is such a tool. It is a preprocessor which can "
"be used to build GObjects with inline C code so that there is no need to "
"edit the generated C code. The syntax is inspired by Java and Yacc or Lex. "
"The implementation is intentionally kept simple: the inline C code provided "
"by the user is not parsed."
msgstr ""

#: tut_tools.xml:59(title)
msgid "Graphical inspection of GObjects"
msgstr ""

#: tut_tools.xml:6(title)
msgid "Related Tools"
msgstr ""

#: tut_tools.xml:61(para)
msgid ""
"Yet another tool that you may find helpful when working with GObjects is "
"<ulink url=\"http://sourceforge.net/projects/g-inspector\">G-Inspector</"
"ulink>. It is able to display GLib/GTK+ objects and their properties."
msgstr ""

#: tut_tools.xml:70(title)
msgid "Debugging reference count problems"
msgstr ""

#: tut_tools.xml:72(para)
msgid ""
"The reference counting scheme used by GObject does solve quite a few memory "
"management problems but also introduces new sources of bugs. In large "
"applications, finding the exact spot where the reference count of an Object "
"is not properly handled can be very difficult. Hopefully, there exist a tool "
"named <ulink url=\"http://refdbg.sf.net/\">refdbg</ulink> which can be used "
"to automate the task of tracking down the location of invalid code with "
"regard to reference counting. This application intercepts the reference "
"counting calls and tries to detect invalid behavior. It supports a filter-"
"rule mechanism to let you trace only the objects you are interested in and "
"it can be used together with GDB."
msgstr ""

#: tut_tools.xml:84(para)
msgid ""
"<indexterm><primary>g_trap_object_ref</primary></indexterm> Note that if "
"GObject has been compiled with <option>--enable-debug=yes</option>, it "
"exports a trap variable <placeholder-1/> If set to a non-NULL value, <link "
"linkend=\"g-object-ref\">g_object_ref</link>() and <link linkend=\"g-object-"
"unref\">g_object_unref</link>() will be intercepted when called with that "
"value."
msgstr ""

#: tut_tools.xml:88(programlisting)
#, no-wrap
msgid ""
"\n"
"static volatile GObject *g_trap_object_ref;\n"
"      "
msgstr ""

#: tut_tools.xml:9(para)
msgid ""
"Several useful developer tools have been build around GObject technology. "
"The next sections briefly introduce them and link to the respective project "
"pages."
msgstr ""

#: tut_tools.xml:98(title)
msgid "Writing API docs"
msgstr ""
