<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Client-side GObject bindings</title>
<meta name="generator" content="DocBook XSL Stylesheets V1.76.1">
<link rel="home" href="index.html" title="GIO 参考手册">
<link rel="up" href="ch29.html" title="Migrating to GDBus">
<link rel="prev" href="ch29s04.html" title="Creating proxies for well-known names">
<link rel="next" href="ch29s06.html" title="Exporting objects">
<meta name="generator" content="GTK-Doc V1.17 (XML mode)">
<link rel="stylesheet" href="style.css" type="text/css">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<table class="navigation" id="top" width="100%" summary="Navigation header" cellpadding="2" cellspacing="2"><tr valign="middle">
<td><a accesskey="p" href="ch29s04.html"><img src="left.png" width="24" height="24" border="0" alt="Prev"></a></td>
<td><a accesskey="u" href="ch29.html"><img src="up.png" width="24" height="24" border="0" alt="Up"></a></td>
<td><a accesskey="h" href="index.html"><img src="home.png" width="24" height="24" border="0" alt="Home"></a></td>
<th width="100%" align="center">GIO 参考手册</th>
<td><a accesskey="n" href="ch29s06.html"><img src="right.png" width="24" height="24" border="0" alt="Next"></a></td>
</tr></table>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="id3155871"></a>Client-side GObject bindings</h2></div></div></div>
<p>
      dbus-glib comes with <span class="command"><strong>dbus-binding-tool</strong></span>, which
      can produce somewhat nice client-side wrappers for a D-Bus interface.
      GDBus does not have code-generation at this point, but <a class="link" href="gio-GDBusProxy.html#GDBusProxy" title="GDBusProxy"><span class="type">GDBusProxy</span></a>
      is designed to allow the creating of client-side wrappers by
      subclassing <a class="link" href="gio-GDBusProxy.html#GDBusProxy" title="GDBusProxy"><span class="type">GDBusProxy</span></a>.
    </p>
<p>
      For an example of a <span class="type">GDBusProxy-derived</span> class that wraps a D-Bus
      interface in a type-safe way, see <a class="xref" href="ch29s05.html#gdbus-example-proxy-subclass" title="Example 19. GDBusProxy subclass example">Example 19, “GDBusProxy subclass example”</a>. The comparison is as
      follows:
      </p>
<div class="table">
<a name="gdbus-example-type-safe-proxy"></a><p class="title"><b>Table 8. Wrapping the org.freedesktop.Accounts.User D-Bus interface in the AccountUser GObject type</b></p>
<div class="table-contents"><table summary="Wrapping the org.freedesktop.Accounts.User D-Bus interface in the AccountUser GObject type" border="1">
<colgroup>
<col>
<col>
</colgroup>
<thead><tr>
<th>D-Bus concept</th>
<th>GObject concept</th>
</tr></thead>
<tbody>
<tr>
<td>AutomaticLogin property</td>
<td>
                <p><code class="literal">AccountsUser:automatic-login</code> GObject property</p>
                <p>C getter: <code class="function">accounts_user_get_automatic_login()</code></p>
                <p>Watch changes via the <code class="literal">notify::automatic-login</code> signal</p>
              </td>
</tr>
<tr>
<td>RealName property</td>
<td>
                <p><code class="literal">AccountsUser:real-name</code> GObject property</p>
                <p>C getter: <code class="function">accounts_user_get_real_name()</code></p>
                <p>Watch changes via the <code class="literal">notify::real-name signal</code></p>
              </td>
</tr>
<tr>
<td>UserName property</td>
<td>
                <p><code class="literal">AccountsUser:user-name</code> GObject property</p>
                <p>C getter: <code class="function">accounts_user_get_user_name()</code></p>
                <p>Watch changes via the <code class="literal">notify::user-name</code> signal</p>
              </td>
</tr>
<tr>
<td>Changed signal</td>
<td>
                <p><code class="literal">AccountsUser::changed</code> GObject signal</p>
                <p>Watch via e.g. <a href="../gobject/gobject-Signals.html#g-signal-connect"><code class="function">g_signal_connect()</code></a></p>
              </td>
</tr>
<tr>
<td>Frobnicate method</td>
<td>
                <p>Use <code class="function">accounts_user_frobnicate()</code> + <code class="function">accounts_user_frobnicate_finish()</code> or <code class="function">accounts_user_frobnicate_sync()</code> to invoke</p>
              </td>
</tr>
</tbody>
</table></div>
</div>
<p><br class="table-break">
    </p>
<div class="example">
<a name="gdbus-example-proxy-subclass"></a><p class="title"><b>Example 19. GDBusProxy subclass example</b></p>
<div class="example-contents"><pre class="programlisting">
#include &lt;gio/gio.h&gt;

/* ---------------------------------------------------------------------------------------------------- */
/* The D-Bus interface definition we want to create a GDBusProxy-derived type for: */
/* ---------------------------------------------------------------------------------------------------- */

static const gchar introspection_xml[] =
  "&lt;node&gt;"
  "  &lt;interface name='org.freedesktop.Accounts.User'&gt;"
  "    &lt;method name='Frobnicate'&gt;"
  "      &lt;arg name='flux' type='s' direction='in'/&gt;"
  "      &lt;arg name='baz' type='s' direction='in'/&gt;"
  "      &lt;arg name='result' type='s' direction='out'/&gt;"
  "    &lt;/method&gt;"
  "    &lt;signal name='Changed'/&gt;"
  "    &lt;property name='AutomaticLogin' type='b' access='readwrite'/&gt;"
  "    &lt;property name='RealName' type='s' access='read'/&gt;"
  "    &lt;property name='UserName' type='s' access='read'/&gt;"
  "  &lt;/interface&gt;"
  "&lt;/node&gt;";

/* ---------------------------------------------------------------------------------------------------- */
/* Definition of the AccountsUser type */
/* ---------------------------------------------------------------------------------------------------- */

#define ACCOUNTS_TYPE_USER         (accounts_user_get_type ())
#define ACCOUNTS_USER(o)           (G_TYPE_CHECK_INSTANCE_CAST ((o), ACCOUNTS_TYPE_USER, AccountsUser))
#define ACCOUNTS_USER_CLASS(k)     (G_TYPE_CHECK_CLASS_CAST((k), ACCOUNTS_TYPE_USER, AccountsUserClass))
#define ACCOUNTS_USER_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), ACCOUNTS_TYPE_USER, AccountsUserClass))
#define ACCOUNTS_IS_USER(o)        (G_TYPE_CHECK_INSTANCE_TYPE ((o), ACCOUNTS_TYPE_USER))
#define ACCOUNTS_IS_USER_CLASS(k)  (G_TYPE_CHECK_CLASS_TYPE ((k), ACCOUNTS_TYPE_USER))

typedef struct _AccountsUser        AccountsUser;
typedef struct _AccountsUserClass   AccountsUserClass;
typedef struct _AccountsUserPrivate AccountsUserPrivate;

struct _AccountsUser
{
  /*&lt; private &gt;*/
  GDBusProxy parent_instance;
  AccountsUserPrivate *priv;
};

struct _AccountsUserClass
{
  /*&lt; private &gt;*/
  GDBusProxyClass parent_class;
  void (*changed) (AccountsUser *user);
};

GType        accounts_user_get_type            (void) G_GNUC_CONST;

const gchar *accounts_user_get_user_name       (AccountsUser        *user);
const gchar *accounts_user_get_real_name       (AccountsUser        *user);
gboolean     accounts_user_get_automatic_login (AccountsUser        *user);

void         accounts_user_frobnicate          (AccountsUser        *user,
                                                const gchar         *flux,
                                                gint                 baz,
                                                GCancellable        *cancellable,
                                                GAsyncReadyCallback  callback,
                                                gpointer             user_data);
gchar       *accounts_user_frobnicate_finish   (AccountsUser        *user,
                                                GAsyncResult        *res,
                                                GError             **error);
gchar       *accounts_user_frobnicate_sync     (AccountsUser        *user,
                                                const gchar         *flux,
                                                gint                 baz,
                                                GCancellable        *cancellable,
                                                GError             **error);

/* ---------------------------------------------------------------------------------------------------- */
/* Implementation of the AccountsUser type */
/* ---------------------------------------------------------------------------------------------------- */

/* A more efficient approach than parsing XML is to use const static
 * GDBusInterfaceInfo, GDBusMethodInfo, ... structures
 */
static GDBusInterfaceInfo *
accounts_user_get_interface_info (void)
{
  static gsize has_info = 0;
  static GDBusInterfaceInfo *info = NULL;
  if (g_once_init_enter (&amp;has_info))
    {
      GDBusNodeInfo *introspection_data;
      introspection_data = g_dbus_node_info_new_for_xml (introspection_xml, NULL);
      info = introspection_data-&gt;interfaces[0];
      g_once_init_leave (&amp;has_info, 1);
    }
  return info;
}

enum
{
  PROP_0,
  PROP_USER_NAME,
  PROP_REAL_NAME,
  PROP_AUTOMATIC_LOGIN,
};

enum
{
  CHANGED_SIGNAL,
  LAST_SIGNAL
};

static guint signals[LAST_SIGNAL] = {0};

G_DEFINE_TYPE (AccountsUser, accounts_user, G_TYPE_DBUS_PROXY);

static void
accounts_user_finalize (GObject *object)
{
  G_GNUC_UNUSED AccountsUser *user = ACCOUNTS_USER (object);

  if (G_OBJECT_CLASS (accounts_user_parent_class)-&gt;finalize != NULL)
    G_OBJECT_CLASS (accounts_user_parent_class)-&gt;finalize (object);
}

static void
accounts_user_init (AccountsUser *user)
{
  /* Sets the expected interface */
  g_dbus_proxy_set_interface_info (G_DBUS_PROXY (user), accounts_user_get_interface_info ());
}

static void
accounts_user_get_property (GObject    *object,
                            guint       prop_id,
                            GValue     *value,
                            GParamSpec *pspec)
{
  AccountsUser *user = ACCOUNTS_USER (object);

  switch (prop_id)
    {
    case PROP_USER_NAME:
      g_value_set_string (value, accounts_user_get_user_name (user));
      break;

    case PROP_REAL_NAME:
      g_value_set_string (value, accounts_user_get_real_name (user));
      break;

    case PROP_AUTOMATIC_LOGIN:
      g_value_set_boolean (value, accounts_user_get_automatic_login (user));
      break;

    default:
      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
      break;
    }
}

const gchar *
accounts_user_get_user_name (AccountsUser *user)
{
  GVariant *value;
  const gchar *ret;
  g_return_val_if_fail (ACCOUNTS_IS_USER (user), NULL);
  value = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (user), "UserName");
  ret = g_variant_get_string (value, NULL);
  g_variant_unref (value);
  return ret;
}

const gchar *
accounts_user_get_real_name (AccountsUser *user)
{
  GVariant *value;
  const gchar *ret;
  g_return_val_if_fail (ACCOUNTS_IS_USER (user), NULL);
  value = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (user), "RealName");
  ret = g_variant_get_string (value, NULL);
  g_variant_unref (value);
  return ret;
}

gboolean
accounts_user_get_automatic_login (AccountsUser *user)
{
  GVariant *value;
  gboolean ret;
  g_return_val_if_fail (ACCOUNTS_IS_USER (user), FALSE);
  value = g_dbus_proxy_get_cached_property (G_DBUS_PROXY (user), "AutomaticLogin");
  ret = g_variant_get_boolean (value);
  g_variant_unref (value);
  return ret;
}

static void
accounts_user_g_signal (GDBusProxy   *proxy,
                        const gchar  *sender_name,
                        const gchar  *signal_name,
                        GVariant     *parameters)
{
  AccountsUser *user = ACCOUNTS_USER (proxy);
  if (g_strcmp0 (signal_name, "Changed") == 0)
    g_signal_emit (user, signals[CHANGED_SIGNAL], 0);
}

static void
accounts_user_g_properties_changed (GDBusProxy          *proxy,
                                    GVariant            *changed_properties,
                                    const gchar* const  *invalidated_properties)
{
  AccountsUser *user = ACCOUNTS_USER (proxy);
  GVariantIter *iter;
  const gchar *key;

  if (changed_properties != NULL)
    {
      g_variant_get (changed_properties, "a{sv}", &amp;iter);
      while (g_variant_iter_next (iter, "{&amp;sv}", &amp;key, NULL))
        {
          if (g_strcmp0 (key, "AutomaticLogin") == 0)
            g_object_notify (G_OBJECT (user), "automatic-login");
          else if (g_strcmp0 (key, "RealName") == 0)
            g_object_notify (G_OBJECT (user), "real-name");
          else if (g_strcmp0 (key, "UserName") == 0)
            g_object_notify (G_OBJECT (user), "user-name");
        }
      g_variant_iter_free (iter);
    }
}

static void
accounts_user_class_init (AccountsUserClass *klass)
{
  GObjectClass *gobject_class;
  GDBusProxyClass *proxy_class;

  gobject_class = G_OBJECT_CLASS (klass);
  gobject_class-&gt;get_property = accounts_user_get_property;
  gobject_class-&gt;finalize = accounts_user_finalize;

  proxy_class = G_DBUS_PROXY_CLASS (klass);
  proxy_class-&gt;g_signal             = accounts_user_g_signal;
  proxy_class-&gt;g_properties_changed = accounts_user_g_properties_changed;

  g_object_class_install_property (gobject_class,
                                   PROP_USER_NAME,
                                   g_param_spec_string ("user-name",
                                                        "User Name",
                                                        "The user name of the user",
                                                        NULL,
                                                        G_PARAM_READABLE |
                                                        G_PARAM_STATIC_STRINGS));

  g_object_class_install_property (gobject_class,
                                   PROP_REAL_NAME,
                                   g_param_spec_string ("real-name",
                                                        "Real Name",
                                                        "The real name of the user",
                                                        NULL,
                                                        G_PARAM_READABLE |
                                                        G_PARAM_STATIC_STRINGS));

  g_object_class_install_property (gobject_class,
                                   PROP_AUTOMATIC_LOGIN,
                                   g_param_spec_boolean ("automatic-login",
                                                         "Automatic Login",
                                                         "Whether the user is automatically logged in",
                                                         FALSE,
                                                         G_PARAM_READABLE |
                                                         G_PARAM_STATIC_STRINGS));

  signals[CHANGED_SIGNAL] = g_signal_new ("changed",
                                          ACCOUNTS_TYPE_USER,
                                          G_SIGNAL_RUN_LAST,
                                          G_STRUCT_OFFSET (AccountsUserClass, changed),
                                          NULL,
                                          NULL,
                                          g_cclosure_marshal_VOID__VOID,
                                          G_TYPE_NONE,
                                          0);
}

gchar *
accounts_user_frobnicate_sync (AccountsUser        *user,
                               const gchar         *flux,
                               gint                 baz,
                               GCancellable        *cancellable,
                               GError             **error)
{
  gchar *ret;
  GVariant *value;

  g_return_val_if_fail (ACCOUNTS_IS_USER (user), NULL);

  ret = NULL;

  value = g_dbus_proxy_call_sync (G_DBUS_PROXY (user),
                                  "Frobnicate",
                                  g_variant_new ("(si)",
                                                 flux,
                                                 baz),
                                  G_DBUS_CALL_FLAGS_NONE,
                                  -1,
                                  cancellable,
                                  error);
  if (value != NULL)
    {
      g_variant_get (value, "(s)", &amp;ret);
      g_variant_unref (value);
    }
  return ret;
}

void
accounts_user_frobnicate (AccountsUser        *user,
                          const gchar         *flux,
                          gint                 baz,
                          GCancellable        *cancellable,
                          GAsyncReadyCallback  callback,
                          gpointer             user_data)
{
  g_return_if_fail (ACCOUNTS_IS_USER (user));
  g_dbus_proxy_call (G_DBUS_PROXY (user),
                     "Frobnicate",
                     g_variant_new ("(si)",
                                    flux,
                                    baz),
                     G_DBUS_CALL_FLAGS_NONE,
                     -1,
                     cancellable,
                     callback,
                     user_data);
}


gchar *
accounts_user_frobnicate_finish (AccountsUser        *user,
                                 GAsyncResult        *res,
                                 GError             **error)
{
  gchar *ret;
  GVariant *value;

  ret = NULL;
  value = g_dbus_proxy_call_finish (G_DBUS_PROXY (user), res, error);
  if (value != NULL)
    {
      g_variant_get (value, "(s)", &amp;ret);
      g_variant_unref (value);
    }
  return ret;
}

/* ---------------------------------------------------------------------------------------------------- */

gint
main (gint argc, gchar *argv[])
{
  return 0;
}
</pre></div>
</div>
<br class="example-break">
</div>
<div class="footer">
<hr>
          Generated by GTK-Doc V1.17</div>
</body>
</html>