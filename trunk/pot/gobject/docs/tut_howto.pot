msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2011-04-18 23:25+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. Put one translator per line, in the form of NAME <EMAIL>, YEAR1, YEAR2
#: tut_howto.xml:0(None)
msgid "translator-credits"
msgstr ""

#: tut_howto.xml:1001(title)
msgid "Interface definition prerequisites"
msgstr ""

#: tut_howto.xml:1003(para)
msgid ""
"To specify that an interface requires the presence of other interfaces when "
"implemented, GObject introduces the concept of <emphasis>prerequisites</"
"emphasis>: it is possible to associate a list of prerequisite interfaces to "
"an interface. For example, if object A wishes to implement interface I1, and "
"if interface I1 has a prerequisite on interface I2, A has to implement both "
"I1 and I2."
msgstr ""

#: tut_howto.xml:1012(para)
msgid ""
"The mechanism described above is, in practice, very similar to Java's "
"interface I1 extends interface I2. The example below shows the GObject "
"equivalent: <placeholder-1/> The code shown above adds the MamanIbaz "
"interface to the list of prerequisites of MamanIbar while the code below "
"shows how an implementation can implement both interfaces and register their "
"implementations: <placeholder-2/> It is very important to notice that the "
"order in which interface implementations are added to the main object is not "
"random: <function><link linkend=\"g-type-add-interface-static"
"\">g_type_add_interface_static</link></function>, which is called by "
"<function>G_IMPLEMENT_INTERFACE</function>, must be invoked first on the "
"interfaces which have no prerequisites and then on the others."
msgstr ""

#: tut_howto.xml:1016(programlisting)
#, no-wrap
msgid ""
"\n"
"  /* inside the GType function of the MamanIbar interface */\n"
"  type = g_type_register_static (G_TYPE_INTERFACE, \"MamanIbar\", &amp;info, 0);\n"
"\n"
"  /* Make the MamanIbar interface require MamanIbaz interface. */\n"
"  g_type_interface_add_prerequisite (type, MAMAN_TYPE_IBAZ);\n"
msgstr ""

#: tut_howto.xml:1027(programlisting)
#, no-wrap
msgid ""
"\n"
"static void\n"
"maman_ibar_do_another_action (MamanIbar *ibar)\n"
"{\n"
"  MamanBar *self = MAMAN_BAR (ibar);\n"
"\n"
"  g_print (\"Bar implementation of IBar interface Another Action: 0x%x.\\n\",\n"
"           self-&gt;instance_member);\n"
"}\n"
"\n"
"static void\n"
"maman_ibar_interface_init (MamanIbarInterface *iface)\n"
"{\n"
"  iface-&gt;do_another_action = maman_ibar_do_another_action;\n"
"}\n"
"\n"
"static void\n"
"maman_ibaz_do_action (MamanIbaz *ibaz)\n"
"{\n"
"  MamanBar *self = MAMAN_BAR (ibaz);\n"
"\n"
"  g_print (\"Bar implementation of IBaz interface Action: 0x%x.\\n\",\n"
"           self-&gt;instance_member);\n"
"}\n"
"\n"
"static void\n"
"maman_ibaz_interface_init (MamanIbazInterface *iface)\n"
"{\n"
"  iface-&gt;do_action = maman_ibaz_do_action;\n"
"}\n"
"\n"
"static void\n"
"maman_bar_class_init (MamanBarClass *klass)\n"
"{\n"
"\n"
"}\n"
"\n"
"static void\n"
"maman_bar_init (MamanBar *self)\n"
"{\n"
"  self-&gt;instance_member = 0x666;\n"
"}\n"
"\n"
"G_DEFINE_TYPE_WITH_CODE (MamanBar, maman_bar, G_TYPE_OBJECT,\n"
"                         G_IMPLEMENT_INTERFACE (MAMAN_TYPE_IBAZ,\n"
"                                                maman_ibaz_interface_init)\n"
"                         G_IMPLEMENT_INTERFACE (MAMAN_TYPE_IBAR,\n"
"                                                maman_ibar_interface_init));\n"
msgstr ""

#: tut_howto.xml:1086(title)
msgid "Interface Properties"
msgstr ""

#: tut_howto.xml:1088(para)
msgid ""
"Starting from version 2.4 of GLib, GObject interfaces can also have "
"properties. Declaration of the interface properties is similar to declaring "
"the properties of ordinary GObject types as explained in <xref linkend="
"\"gobject-properties\"/>, except that <function><link linkend=\"g-object-"
"interface-install-property\">g_object_interface_install_property</link></"
"function> is used to declare the properties instead of <function><link "
"linkend=\"g-object-class-install-property\">g_object_class_install_property</"
"link></function>."
msgstr ""

#: tut_howto.xml:1097(para)
msgid ""
"To include a property named 'name' of type <type>string</type> in the "
"<type>maman_ibaz</type> interface example code above, we only need to add "
"one <placeholder-1/> line in the <function>maman_ibaz_base_init</"
"function><placeholder-2/> as shown below: <placeholder-3/>"
msgstr ""

#: tut_howto.xml:1102(para)
msgid "That really is one line extended to six for the sake of clarity"
msgstr ""

#: tut_howto.xml:1108(para)
msgid ""
"The <function><link linkend=\"g-object-interface-install-property"
"\">g_object_interface_install_property</link></function> can also be called "
"from <function>class_init</function> but it must not be called after that "
"point."
msgstr ""

#: tut_howto.xml:1115(programlisting)
#, no-wrap
msgid ""
"\n"
"static void\n"
"maman_ibaz_base_init (gpointer g_iface)\n"
"{\n"
"  static gboolean is_initialized = FALSE;\n"
"\n"
"  if (!is_initialized)\n"
"    {\n"
"      g_object_interface_install_property (g_iface,\n"
"                                           g_param_spec_string (\"name\",\n"
"                                                                \"Name\",\n"
"                                                                \"Name of the MamanIbaz\",\n"
"                                                                \"maman\",\n"
"                                                                G_PARAM_READWRITE));\n"
"      is_initialized = TRUE;\n"
"    }\n"
"}\n"
msgstr ""

#: tut_howto.xml:1135(para)
msgid ""
"One point worth noting is that the declared property wasn't assigned an "
"integer ID. The reason being that integer IDs of properties are used only "
"inside the get and set methods and since interfaces do not implement "
"properties, there is no need to assign integer IDs to interface properties."
msgstr ""

#: tut_howto.xml:1143(para)
msgid ""
"An implementation shall declare and define it's properties in the usual way "
"as explained in <xref linkend=\"gobject-properties\"/>, except for one small "
"change: it must declare the properties of the interface it implements using "
"<function><link linkend=\"g-object-class-override-property"
"\">g_object_class_override_property</link></function> instead of "
"<function><link linkend=\"g-object-class-install-property"
"\">g_object_class_install_property</link></function>. The following code "
"snippet shows the modifications needed in the <type>MamanBaz</type> "
"declaration and implementation above: <placeholder-1/>"
msgstr ""

#: tut_howto.xml:1151(programlisting)
#, no-wrap
msgid ""
"\n"
"\n"
"struct _MamanBaz\n"
"{\n"
"  GObject parent_instance;\n"
"\n"
"  gint instance_member;\n"
"  gchar *name;\n"
"};\n"
"\n"
"enum\n"
"{\n"
"  PROP_0,\n"
"\n"
"  PROP_NAME\n"
"};\n"
"\n"
"static void\n"
"maman_baz_set_property (GObject      *object,\n"
"                        guint         property_id,\n"
"                        const GValue *value,\n"
"                        GParamSpec   *pspec)\n"
"{\n"
"  MamanBaz *baz = MAMAN_BAZ (object);\n"
"  GObject *obj;\n"
"\n"
"  switch (prop_id)\n"
"    {\n"
"    case ARG_NAME:\n"
"      g_free (baz-&gt;name);\n"
"      baz-&gt;name = g_value_dup_string (value);\n"
"      break;\n"
"\n"
"    default:\n"
"      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);\n"
"      break;\n"
"    }\n"
"}\n"
"\n"
"static void\n"
"maman_baz_get_property (GObject    *object,\n"
"                        guint       prop_id,\n"
"                        GValue     *value,\n"
"                        GParamSpec *pspec)\n"
"{\n"
"  MamanBaz *baz = MAMAN_BAZ (object);\n"
"\n"
"  switch (prop_id)\n"
"    {\n"
"    case ARG_NAME:\n"
"      g_value_set_string (value, baz-&gt;name);\n"
"      break;\n"
"\n"
"    default:\n"
"      G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);\n"
"      break;\n"
"    }\n"
"}\n"
"\n"
"static void\n"
"maman_baz_class_init (MamanBazClass *klass)\n"
"{\n"
"  GObjectClass *gobject_class = G_OBJECT_CLASS (klass);\n"
"\n"
"  gobject_class-&gt;set_property = maman_baz_set_property;\n"
"  gobject_class-&gt;get_property = maman_baz_get_property;\n"
"\n"
"  g_object_class_override_property (gobject_class, PROP_NAME, \"name\");\n"
"}\n"
"\n"
msgstr ""

#: tut_howto.xml:1229(title)
msgid "How to create and use signals"
msgstr ""

#: tut_howto.xml:1231(para)
msgid ""
"The signal system which was built in GType is pretty complex and flexible: "
"it is possible for its users to connect at runtime any number of callbacks "
"(implemented in any language for which a binding exists) <placeholder-1/> to "
"any signal and to stop the emission of any signal at any state of the signal "
"emission process. This flexibility makes it possible to use GSignal for much "
"more than just emit signals which can be received by numerous clients."
msgstr ""

#: tut_howto.xml:1237(para)
msgid ""
"A Python callback can be connected to any signal on any C-based GObject."
msgstr ""

#: tut_howto.xml:1248(title)
msgid "Simple use of signals"
msgstr ""

#: tut_howto.xml:1250(para)
msgid ""
"The most basic use of signals is to implement simple event notification: for "
"example, if we have a MamanFile object, and if this object has a write "
"method, we might wish to be notified whenever someone has changed something "
"via our MamanFile instance. The code below shows how the user can connect a "
"callback to the \"changed\" signal. <placeholder-1/>"
msgstr ""

#: tut_howto.xml:1257(programlisting)
#, no-wrap
msgid ""
"\n"
"file = g_object_new (MAMAN_FILE_TYPE, NULL);\n"
"\n"
"g_signal_connect (file, \"changed\", G_CALLBACK (changed_event), NULL);\n"
"\n"
"maman_file_write (file, buffer, strlen (buffer));\n"
msgstr ""

#: tut_howto.xml:1266(para)
msgid ""
"The <type>MamanFile</type> signal is registered in the class_init function: "
"<placeholder-1/> and the signal is emitted in <function>maman_file_write</"
"function>: <placeholder-2/> As shown above, you can safely set the details "
"parameter to zero if you do not know what it can be used for. For a "
"discussion of what you could used it for, see <xref linkend=\"signal-detail"
"\"/>"
msgstr ""

#: tut_howto.xml:1269(programlisting)
#, no-wrap
msgid ""
"\n"
"file_signals[CHANGED] = \n"
"  g_signal_newv (\"changed\",\n"
"                 G_TYPE_FROM_CLASS (gobject_class),\n"
"                 G_SIGNAL_RUN_LAST | G_SIGNAL_NO_RECURSE | G_SIGNAL_NO_HOOKS,\n"
"                 NULL /* closure */,\n"
"                 NULL /* accumulator */,\n"
"                 NULL /* accumulator data */,\n"
"                 g_cclosure_marshal_VOID__VOID,\n"
"                 G_TYPE_NONE /* return_type */,\n"
"                 0     /* n_params */,\n"
"                 NULL  /* param_types */);\n"
msgstr ""

#: tut_howto.xml:1283(programlisting)
#, no-wrap
msgid ""
"\n"
"void\n"
"maman_file_write (MamanFile    *self,\n"
"                  const guchar *buffer,\n"
"                  gssize        size)\n"
"{\n"
"  /* First write data. */\n"
"\n"
"  /* Then, notify user of data written. */\n"
"  g_signal_emit (self, file_signals[CHANGED], 0 /* details */);\n"
"}\n"
msgstr ""

#: tut_howto.xml:1300(para)
msgid ""
"The signature of the signal handler in the above example is defined as "
"<function>g_cclosure_marshal_VOID__VOID</function>. Its name follows a "
"simple convention which encodes the function parameter and return value "
"types in the function name. Specifically, the value in front of the double "
"underscore is the type of the return value, while the value(s) after the "
"double underscore denote the parameter types."
msgstr ""

#: tut_howto.xml:1309(para)
msgid ""
"The header <filename>gobject/gmarshal.h</filename> defines a set of commonly "
"needed closures that one can use. If you want to have complex marshallers "
"for your signals you should probably use glib-genmarshal to autogenerate "
"them from a file containing their return and parameter types."
msgstr ""

#: tut_howto.xml:136(para)
msgid ""
"Most GTK+ types declare their private fields in the public header with a /* "
"private */ comment, relying on their user's intelligence not to try to play "
"with these fields. Fields not marked private are considered public by "
"default. The /* protected */ comment (same semantics as those of C++) is "
"also used, mainly in the GType library, in code written by Tim Janik. "
"<placeholder-1/>"
msgstr ""

#: tut_howto.xml:143(programlisting)
#, no-wrap
msgid ""
"\n"
"struct _MamanBar\n"
"{\n"
"  GObject parent_instance;\n"
"\n"
"  /*&lt; private &gt;*/\n"
"  int hsize;\n"
"};\n"
msgstr ""

#: tut_howto.xml:153(para)
msgid ""
"All of Nautilus code and a lot of GNOME libraries use private indirection "
"members, as described by Herb Sutter in his Pimpl articles(see <ulink url="
"\"http://www.gotw.ca/gotw/024.htm\">Compilation Firewalls</ulink> and <ulink "
"url=\"http://www.gotw.ca/gotw/028.htm\">The Fast Pimpl Idiom</ulink>: he "
"summarizes the different issues better than I will). <placeholder-1/"
"><placeholder-2/> The private structure is then defined in the .c file, "
"using the g_type_class_add_private() function to notify the presence of a "
"private memory area for each instance and it can either be retrieved using "
"<function>G_TYPE_INSTANCE_GET_PRIVATE()</function> each time is needed, or "
"assigned to the <literal>priv</literal> member of the instance structure "
"inside the object's <function>init</function> function. <placeholder-3/>"
msgstr ""

#: tut_howto.xml:159(programlisting)
#, no-wrap
msgid ""
"\n"
"typedef struct _MamanBarPrivate MamanBarPrivate;\n"
"\n"
"struct _MamanBar\n"
"{\n"
"  GObject parent_instance;\n"
"    \n"
"  /*&lt; private &gt;*/\n"
"  MamanBarPrivate *priv;\n"
"};\n"
msgstr ""

#: tut_howto.xml:16(title)
msgid "How to define and implement a new GObject"
msgstr ""

#: tut_howto.xml:170(simpara)
msgid ""
"Do not call this <varname>private</varname>, as that is a registered c++ "
"keyword."
msgstr ""

#: tut_howto.xml:18(para)
msgid ""
"Clearly, this is one of the most common questions people ask: they just want "
"to crank code and implement a subclass of a GObject. Sometimes because they "
"want to create their own class hierarchy, sometimes because they want to "
"subclass one of GTK+'s widget. This chapter will focus on the implementation "
"of a subtype of GObject."
msgstr ""

#: tut_howto.xml:180(programlisting)
#, no-wrap
msgid ""
"\n"
"#define MAMAN_BAR_GET_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE ((obj), MAMAN_TYPE_BAR, MamanBarPrivate))\n"
"\n"
"struct _MamanBarPrivate\n"
"{\n"
"  int hsize;\n"
"}\n"
"\n"
"static void\n"
"maman_bar_class_init (MamanBarClass *klass)\n"
"{\n"
"  g_type_class_add_private (klass, sizeof (MamanBarPrivate));\n"
"}\n"
"\n"
"static void\n"
"maman_bar_init (MamanBar *self)\n"
"{\n"
"  MamanBarPrivate *priv;\n"
"\n"
"  self-&gt;priv = priv = MAMAN_BAR_GET_PRIVATE (self);\n"
"\n"
"  priv-&gt;hsize = 42;\n"
"}\n"
msgstr ""

#: tut_howto.xml:206(para)
msgid ""
"You don't need to free or allocate the private structure, only the objects "
"or pointers that it may contain. Another advantage of this to the previous "
"version is that is lessens memory fragmentation, as the public and private "
"parts of the instance memory are allocated at once."
msgstr ""

#: tut_howto.xml:216(para)
msgid ""
"Finally, there are different header include conventions. Again, pick one and "
"stick to it. I personally use indifferently any of the two, depending on the "
"codebase I work on: the rule, as always, is consistency. <placeholder-1/>"
msgstr ""

#: tut_howto.xml:221(para)
msgid ""
"Some people add at the top of their headers a number of #include directives "
"to pull in all the headers needed to compile client code. This allows client "
"code to simply #include \"maman-bar.h\"."
msgstr ""

#: tut_howto.xml:226(para)
msgid ""
"Other do not #include anything and expect the client to #include themselves "
"the headers they need before including your header. This speeds up "
"compilation because it minimizes the amount of pre-processor work. This can "
"be used in conjunction with the re-declaration of certain unused types in "
"the client code to minimize compile-time dependencies and thus speed up "
"compilation."
msgstr ""

#: tut_howto.xml:240(title)
msgid "Boilerplate code"
msgstr ""

#: tut_howto.xml:242(para)
msgid ""
"In your code, the first step is to #include the needed headers: depending on "
"your header include strategy, this can be as simple as <literal>#include "
"\"maman-bar.h\"</literal> or as complicated as tens of #include lines ending "
"with <literal>#include \"maman-bar.h\"</literal>: <placeholder-1/>"
msgstr ""

#: tut_howto.xml:247(programlisting)
#, no-wrap
msgid ""
"\n"
"/*\n"
" * Copyright information\n"
" */\n"
"\n"
"#include \"maman-bar.h\"\n"
"\n"
"/* If you use Pimpls, include the private structure \n"
" * definition here. Some people create a maman-bar-private.h header\n"
" * which is included by the maman-bar.c file and which contains the\n"
" * definition for this private structure.\n"
" */\n"
"struct _MamanBarPrivate {\n"
"  int member_1;\n"
"  /* stuff */\n"
"};\n"
"\n"
"/* \n"
" * forward definitions\n"
" */\n"
msgstr ""

#: tut_howto.xml:27(title)
msgid "Boilerplate header code"
msgstr ""

#: tut_howto.xml:270(para)
msgid ""
"Call the <function>G_DEFINE_TYPE</function> macro using the name of the "
"type, the prefix of the functions and the parent GType to reduce the amount "
"of boilerplate needed. This macro will: <placeholder-1/><placeholder-2/>"
msgstr ""

#: tut_howto.xml:276(simpara)
msgid "implement the <function>maman_bar_get_type</function> function"
msgstr ""

#: tut_howto.xml:278(simpara)
msgid "define a parent class pointer accessible from the whole .c file"
msgstr ""

#: tut_howto.xml:282(programlisting)
#, no-wrap
msgid ""
"\n"
"G_DEFINE_TYPE (MamanBar, maman_bar, G_TYPE_OBJECT);\n"
msgstr ""

#: tut_howto.xml:287(para)
msgid ""
"It is also possible to use the <function>G_DEFINE_TYPE_WITH_CODE</function> "
"macro to control the get_type function implementation - for instance, to add "
"a call to <function>G_IMPLEMENT_INTERFACE</function> macro which will call "
"the <function>g_type_implement_interface</function> function."
msgstr ""

#: tut_howto.xml:29(para)
msgid ""
"The first step before writing the code for your GObject is to write the "
"type's header which contains the needed type, function and macro "
"definitions. Each of these elements is nothing but a convention which is "
"followed not only by GTK+'s code but also by most users of GObject. If you "
"feel the need not to obey the rules stated below, think about it twice: "
"<placeholder-1/>"
msgstr ""

#: tut_howto.xml:297(title)
msgid "Object Construction"
msgstr ""

#: tut_howto.xml:299(para)
msgid ""
"People often get confused when trying to construct their GObjects because of "
"the sheer number of different ways to hook into the objects's construction "
"process: it is difficult to figure which is the <emphasis>correct</"
"emphasis>, recommended way."
msgstr ""

#: tut_howto.xml:305(para)
msgid ""
"<xref linkend=\"gobject-construction-table\"/> shows what user-provided "
"functions are invoked during object instantiation and in which order they "
"are invoked. A user looking for the equivalent of the simple C++ constructor "
"function should use the instance_init method. It will be invoked after all "
"the parent's instance_init functions have been invoked. It cannot take "
"arbitrary construction parameters (as in C++) but if your object needs "
"arbitrary parameters to complete initialization, you can use construction "
"properties."
msgstr ""

#: tut_howto.xml:315(para)
msgid ""
"Construction properties will be set only after all instance_init functions "
"have run. No object reference will be returned to the client of "
"<function><link linkend=\"g-object-new\">g_object_new</link></function> "
"until all the construction properties have been set."
msgstr ""

#: tut_howto.xml:321(para)
msgid ""
"As such, I would recommend writing the following code first: <placeholder-1/>"
msgstr ""

#: tut_howto.xml:323(programlisting)
#, no-wrap
msgid ""
"\n"
"static void\n"
"maman_bar_init (MamanBar *self)\n"
"{\n"
"  self-&gt;priv = MAMAN_BAR_GET_PRIVATE (self); \n"
"\n"
"  /* initialize all public and private members to reasonable default values. */\n"
"\n"
"  /* If you need specific construction properties to complete initialization,\n"
"   * delay initialization completion until the property is set. \n"
"   */\n"
"}\n"
msgstr ""

#: tut_howto.xml:338(para)
msgid ""
"Now, if you need special construction properties, install the properties in "
"the class_init function, override the set and get methods and implement the "
"get and set methods as described in <xref linkend=\"gobject-properties\"/>. "
"Make sure that these properties use a construct only <link linkend="
"\"GParamSpec\"><type>GParamSpec</type></link> by setting the param spec's "
"flag field to G_PARAM_CONSTRUCT_ONLY: this helps GType ensure that these "
"properties are not set again later by malicious user code. <placeholder-1/> "
"If you need this, make sure you can build and run code similar to the code "
"shown above. Make sure your construct properties can set correctly during "
"construction, make sure you cannot set them afterwards and make sure that if "
"your users do not call <function><link linkend=\"g-object-new"
"\">g_object_new</link></function> with the required construction properties, "
"these will be initialized with the default values."
msgstr ""

#: tut_howto.xml:344(programlisting)
#, no-wrap
msgid ""
"\n"
"static void\n"
"bar_class_init (MamanBarClass *klass)\n"
"{\n"
"  GObjectClass *gobject_class = G_OBJECT_CLASS (klass);\n"
"  GParamSpec *pspec;\n"
"\n"
"  gobject_class-&gt;set_property = bar_set_property;\n"
"  gobject_class-&gt;get_property = bar_get_property;\n"
"\n"
"  pspec = g_param_spec_string (\"maman\",\n"
"                                          \"Maman construct prop\",\n"
"                                          \"Set maman's name\",\n"
"                                          \"no-name-set\" /* default value */,\n"
"                                          G_PARAM_CONSTRUCT_ONLY | G_PARAM_READWRITE);\n"
"  g_object_class_install_property (gobject_class,\n"
"                                   PROP_MAMAN,\n"
"                                   pspec);\n"
"}\n"
msgstr ""

#: tut_howto.xml:37(para)
msgid ""
"If your users are a bit accustomed to GTK+ code or any GLib code, they will "
"be a bit surprised and getting used to the conventions you decided upon will "
"take time (money) and will make them grumpy (not a good thing)"
msgstr ""

#: tut_howto.xml:370(para)
msgid ""
"I consider good taste to halt program execution if a construction property "
"is set its default value. This allows you to catch client code which does "
"not give a reasonable value to the construction properties. Of course, you "
"are free to disagree but you should have a good reason to do so."
msgstr ""

#: tut_howto.xml:377(para)
msgid ""
"Some people sometimes need to construct their object but only after the "
"construction properties have been set. This is possible through the use of "
"the constructor class method as described in <xref linkend=\"gobject-"
"instantiation\"/> or, more simply, using the constructed class method "
"available since GLib 2.12."
msgstr ""

#: tut_howto.xml:387(title)
msgid "Object Destruction"
msgstr ""

#: tut_howto.xml:389(para)
msgid ""
"Again, it is often difficult to figure out which mechanism to use to hook "
"into the object's destruction process: when the last <function><link linkend="
"\"g-object-unref\">g_object_unref</link></function> function call is made, a "
"lot of things happen as described in <xref linkend=\"gobject-destruction-"
"table\"/>."
msgstr ""

#: tut_howto.xml:397(para)
msgid ""
"The destruction process of your object might be split in two different "
"phases: dispose and the finalize. <placeholder-1/>"
msgstr ""

#: tut_howto.xml:400(programlisting)
#, no-wrap
msgid ""
"\n"
"#define MAMAN_BAR_GET_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE ((obj), MAMAN_TYPE_BAR, MamanBarPrivate))\n"
"\n"
"struct _MamanBarPrivate\n"
"{\n"
"  GObject *an_object;\n"
"\n"
"  gchar *a_string;\n"
"};\n"
"\n"
"G_DEFINE_TYPE (MamanBar, maman_bar, G_TYPE_OBJECT);\n"
"\n"
"static void\n"
"maman_bar_dispose (GObject *gobject)\n"
"{\n"
"  MamanBar *self = MAMAN_BAR (gobject);\n"
"\n"
"  /* \n"
"   * In dispose, you are supposed to free all types referenced from this\n"
"   * object which might themselves hold a reference to self. Generally,\n"
"   * the most simple solution is to unref all members on which you own a \n"
"   * reference.\n"
"   */\n"
"\n"
"  /* dispose might be called multiple times, so we must guard against\n"
"   * calling g_object_unref() on an invalid GObject.\n"
"   */\n"
"  if (self-&gt;priv-&gt;an_object)\n"
"    {\n"
"      g_object_unref (self-&gt;priv-&gt;an_object);\n"
"\n"
"      self-&gt;priv-&gt;an_object = NULL;\n"
"    }\n"
"\n"
"  /* Chain up to the parent class */\n"
"  G_OBJECT_CLASS (maman_bar_parent_class)-&gt;dispose (gobject);\n"
"}\n"
"\n"
"static void\n"
"maman_bar_finalize (GObject *gobject)\n"
"{\n"
"  MamanBar *self = MAMAN_BAR (gobject);\n"
"\n"
"  g_free (self-&gt;priv-&gt;a_string);\n"
"\n"
"  /* Chain up to the parent class */\n"
"  G_OBJECT_CLASS (maman_bar_parent_class)-&gt;finalize (gobject);\n"
"}\n"
"\n"
"static void\n"
"maman_bar_class_init (MamanBarClass *klass)\n"
"{\n"
"  GObjectClass *gobject_class = G_OBJECT_CLASS (klass);\n"
"\n"
"  gobject_class-&gt;dispose = maman_bar_dispose;\n"
"  gobject_class-&gt;finalize = maman_bar_finalize;\n"
"\n"
"  g_type_class_add_private (klass, sizeof (MamanBarPrivate));\n"
"}\n"
"\n"
"static void\n"
"maman_bar_init (MamanBar *self);\n"
"{\n"
"  self-&gt;priv = MAMAN_BAR_GET_PRIVATE (self);\n"
"\n"
"  self-&gt;priv-&gt;an_object = g_object_new (MAMAN_TYPE_BAZ, NULL);\n"
"  self-&gt;priv-&gt;a_string = g_strdup (\"Maman\");\n"
"}\n"
msgstr ""

#: tut_howto.xml:41(para)
msgid ""
"You must assess the fact that these conventions might have been designed by "
"both smart and experienced people: maybe they were at least partly right. "
"Try to put your ego aside."
msgstr ""

#: tut_howto.xml:47(para)
msgid ""
"Pick a name convention for your headers and source code and stick to it: "
"<placeholder-1/> Some people like the first two solutions better: it makes "
"reading file names easier for those with poor eyesight."
msgstr ""

#: tut_howto.xml:471(para)
msgid ""
"Add similar code to your GObject, make sure the code still builds and runs: "
"dispose and finalize must be called during the last unref."
msgstr ""

#: tut_howto.xml:476(para)
msgid ""
"It is possible that object methods might be invoked after dispose is run and "
"before finalize runs. GObject does not consider this to be a program error: "
"you must gracefully detect this and neither crash nor warn the user."
msgstr ""

#: tut_howto.xml:485(title)
msgid "Object methods"
msgstr ""

#: tut_howto.xml:487(para)
msgid ""
"Just as with C++, there are many different ways to define object methods and "
"extend them: the following list and sections draw on C++ vocabulary. "
"(Readers are expected to know basic C++ buzzwords. Those who have not had to "
"write C++ code recently can refer to e.g. <ulink url=\"http://www.cplusplus."
"com/doc/tutorial/\"/> to refresh their memories.) <placeholder-1/>"
msgstr ""

#: tut_howto.xml:495(para)
msgid "non-virtual public methods,"
msgstr ""

#: tut_howto.xml:498(para)
msgid "virtual public methods and"
msgstr ""

#: tut_howto.xml:50(para)
msgid ""
"use a dash to separate the prefix from the typename: <filename>maman-bar.h</"
"filename> and <filename>maman-bar.c</filename> (this is the convention used "
"by Nautilus and most GNOME libraries)."
msgstr ""

#: tut_howto.xml:501(para)
msgid "virtual private methods"
msgstr ""

#: tut_howto.xml:508(title)
msgid "Non-virtual public methods"
msgstr ""

#: tut_howto.xml:510(para)
msgid ""
"These are the simplest: you want to provide a simple method which can act on "
"your object. All you need to do is to provide a function prototype in the "
"header and an implementation of that prototype in the source file. "
"<placeholder-1/>"
msgstr ""

#: tut_howto.xml:515(programlisting)
#, no-wrap
msgid ""
"\n"
"/* declaration in the header. */\n"
"void maman_bar_do_action (MamanBar *self, /* parameters */);\n"
"\n"
"/* implementation in the source file */\n"
"void\n"
"maman_bar_do_action (MamanBar *self, /* parameters */)\n"
"{\n"
"  g_return_if_fail (MAMAN_IS_BAR (self));\n"
"\n"
"  /* do stuff here. */\n"
"}\n"
msgstr ""

#: tut_howto.xml:53(para)
msgid ""
"use an underscore to separate the prefix from the typename: "
"<filename>maman_bar.h</filename> and <filename>maman_bar.c</filename>."
msgstr ""

#: tut_howto.xml:530(para)
msgid "There is really nothing scary about this."
msgstr ""

#: tut_howto.xml:534(title)
msgid "Virtual public methods"
msgstr ""

#: tut_howto.xml:536(para)
msgid ""
"This is the preferred way to create polymorphic GObjects. All you need to do "
"is to define the common method and its class function in the public header, "
"implement the common method in the source file and re-implement the class "
"function in each object which inherits from you. <placeholder-1/> The code "
"above simply redirects the do_action call to the relevant class function. "
"Some users, concerned about performance, do not provide the "
"<function>maman_bar_do_action</function> wrapper function and require users "
"to dereference the class pointer themselves. This is not such a great idea "
"in terms of encapsulation and makes it difficult to change the object's "
"implementation afterwards, should this be needed."
msgstr ""

#: tut_howto.xml:542(programlisting)
#, no-wrap
msgid ""
"\n"
"/* declaration in maman-bar.h. */\n"
"struct _MamanBarClass\n"
"{\n"
"  GObjectClass parent_class;\n"
"\n"
"  /* stuff */\n"
"  void (*do_action) (MamanBar *self, /* parameters */);\n"
"};\n"
"\n"
"void maman_bar_do_action (MamanBar *self, /* parameters */);\n"
"\n"
"/* implementation in maman-bar.c */\n"
"void\n"
"maman_bar_do_action (MamanBar *self, /* parameters */)\n"
"{\n"
"  g_return_if_fail (MAMAN_IS_BAR (self));\n"
"\n"
"  MAMAN_BAR_GET_CLASS (self)-&gt;do_action (self, /* parameters */);\n"
"}\n"
msgstr ""

#: tut_howto.xml:56(para)
msgid ""
"Do not separate the prefix from the typename: <filename>mamanbar.h</"
"filename> and <filename>mamanbar.c</filename>. (this is the convention used "
"by GTK+)"
msgstr ""

#: tut_howto.xml:572(para)
msgid ""
"Other users, also concerned by performance issues, declare the "
"<function>maman_bar_do_action</function> function inline in the header file. "
"This, however, makes it difficult to change the object's implementation "
"later (although easier than requiring users to directly dereference the "
"class function) and is often difficult to write in a portable way (the "
"<emphasis>inline</emphasis> keyword is part of the C99 standard but not "
"every compiler supports it)."
msgstr ""

#: tut_howto.xml:582(para)
msgid ""
"In doubt, unless a user shows you hard numbers about the performance cost of "
"the function call, just implement <function>maman_bar_do_action</function> "
"in the source file."
msgstr ""

#: tut_howto.xml:588(para)
msgid ""
"Please, note that it is possible for you to provide a default implementation "
"for this class method in the object's <function>class_init</function> "
"function: initialize the klass-&gt;do_action field to a pointer to the "
"actual implementation. You can also make this class method pure virtual by "
"initializing the klass-&gt;do_action field to NULL: <placeholder-1/>"
msgstr ""

#: tut_howto.xml:595(programlisting)
#, no-wrap
msgid ""
"\n"
"static void\n"
"maman_bar_real_do_action_two (MamanBar *self, /* parameters */)\n"
"{\n"
"  /* Default implementation for the virtual method. */\n"
"}\n"
"\n"
"static void\n"
"maman_bar_class_init (BarClass *klass)\n"
"{\n"
"  /* pure virtual method: mandates implementation in children. */\n"
"  klass-&gt;do_action_one = NULL;\n"
"\n"
"  /* merely virtual method. */\n"
"  klass-&gt;do_action_two = maman_bar_real_do_action_two;\n"
"}\n"
"\n"
"void\n"
"maman_bar_do_action_one (MamanBar *self, /* parameters */)\n"
"{\n"
"  g_return_if_fail (MAMAN_IS_BAR (self));\n"
"\n"
"  MAMAN_BAR_GET_CLASS (self)-&gt;do_action_one (self, /* parameters */);\n"
"}\n"
"\n"
"void\n"
"maman_bar_do_action_two (MamanBar *self, /* parameters */)\n"
"{\n"
"  g_return_if_fail (MAMAN_IS_BAR (self));\n"
"\n"
"  MAMAN_BAR_GET_CLASS (self)-&gt;do_action_two (self, /* parameters */);\n"
"}\n"
msgstr ""

#: tut_howto.xml:6(title)
msgid "Tutorial"
msgstr ""

#: tut_howto.xml:632(title)
msgid "Virtual private Methods"
msgstr ""

#: tut_howto.xml:634(para)
msgid ""
"These are very similar to Virtual Public methods. They just don't have a "
"public function to call the function directly. The header file contains only "
"a declaration of the class function: <placeholder-1/> These class functions "
"are often used to delegate part of the job to child classes: <placeholder-2/>"
msgstr ""

#: tut_howto.xml:638(programlisting)
#, no-wrap
msgid ""
"\n"
"/* declaration in maman-bar.h. */\n"
"struct _MamanBarClass\n"
"{\n"
"  GObjectClass parent;\n"
"\n"
"  /* stuff */\n"
"  void (* helper_do_specific_action) (MamanBar *self, /* parameters */);\n"
"};\n"
"\n"
"void maman_bar_do_any_action (MamanBar *self, /* parameters */);\n"
msgstr ""

#: tut_howto.xml:64(para)
msgid ""
"When you need some private (internal) declarations in several (sub)classes, "
"you can define them in a private header file which is often named by "
"appending the <emphasis>private</emphasis> keyword to the public header "
"name. For example, one could use <filename>maman-bar-private.h</filename>, "
"<filename>maman_bar_private.h</filename> or <filename>mamanbarprivate.h</"
"filename>. Typically, such private header files are not installed."
msgstr ""

#: tut_howto.xml:652(programlisting)
#, no-wrap
msgid ""
"\n"
"/* this accessor function is static: it is not exported outside of this file. */\n"
"static void \n"
"maman_bar_do_specific_action (MamanBar *self, /* parameters */)\n"
"{\n"
"  MAMAN_BAR_GET_CLASS (self)-&gt;do_specific_action (self, /* parameters */);\n"
"}\n"
"\n"
"void\n"
"maman_bar_do_any_action (MamanBar *self, /* parameters */)\n"
"{\n"
"  /* random code here */\n"
"\n"
"  /* \n"
"   * Try to execute the requested action. Maybe the requested action\n"
"   * cannot be implemented here. So, we delegate its implementation\n"
"   * to the child class:\n"
"   */\n"
"  maman_bar_do_specific_action (self, /* parameters */);\n"
"\n"
"  /* other random code here */\n"
"}\n"
msgstr ""

#: tut_howto.xml:677(para)
msgid ""
"Again, it is possible to provide a default implementation for this private "
"virtual class function: <placeholder-1/>"
msgstr ""

#: tut_howto.xml:680(programlisting)
#, no-wrap
msgid ""
"\n"
"static void\n"
"maman_bar_class_init (MamanBarClass *klass)\n"
"{\n"
"  /* pure virtual method: mandates implementation in children. */\n"
"  klass-&gt;do_specific_action_one = NULL;\n"
"\n"
"  /* merely virtual method. */\n"
"  klass-&gt;do_specific_action_two = maman_bar_real_do_specific_action_two;\n"
"}\n"
msgstr ""

#: tut_howto.xml:693(para)
msgid ""
"Children can then implement the subclass with code such as: <placeholder-1/>"
msgstr ""

#: tut_howto.xml:695(programlisting)
#, no-wrap
msgid ""
"\n"
"static void\n"
"maman_bar_subtype_class_init (MamanBarSubTypeClass *klass)\n"
"{\n"
"  MamanBarClass *bar_class = MAMAN_BAR_CLASS (klass);\n"
"\n"
"  /* implement pure virtual class function. */\n"
"  bar_class-&gt;do_specific_action_one = maman_bar_subtype_do_specific_action_one;\n"
"}\n"
msgstr ""

#: tut_howto.xml:710(title)
msgid "Chaining up"
msgstr ""

#: tut_howto.xml:712(para)
msgid ""
"Chaining up is often loosely defined by the following set of conditions: "
"<placeholder-1/> There are many uses to this idiom: <placeholder-2/> I am "
"personally not really convinced any of the last two uses are really a good "
"idea but since this programming idiom is often used, this section attempts "
"to explain how to implement it."
msgstr ""

#: tut_howto.xml:715(para)
msgid ""
"Parent class A defines a public virtual method named <function>foo</"
"function> and provides a default implementation."
msgstr ""

#: tut_howto.xml:717(para)
msgid "Child class B re-implements method <function>foo</function>."
msgstr ""

#: tut_howto.xml:718(para)
msgid ""
"In the method B::foo, the child class B calls its parent class method A::foo."
msgstr ""

#: tut_howto.xml:722(para)
msgid ""
"You need to change the behaviour of a class without modifying its code. You "
"create a subclass to inherit its implementation, re-implement a public "
"virtual method to modify the behaviour slightly and chain up to ensure that "
"the previous behaviour is not really modified, just extended."
msgstr ""

#: tut_howto.xml:726(para)
msgid ""
"You are lazy, you have access to the source code of the parent class but you "
"don't want to modify it to add method calls to new specialized method calls: "
"it is faster to hack the child class to chain up than to modify the parent "
"to call down."
msgstr ""

#: tut_howto.xml:729(para)
msgid ""
"You need to implement the Chain Of Responsibility pattern: each object of "
"the inheritance tree chains up to its parent (typically, at the beginning or "
"the end of the method) to ensure that they each handler is run in turn."
msgstr ""

#: tut_howto.xml:737(para)
msgid ""
"To explicitly chain up to the implementation of the virtual method in the "
"parent class, you first need a handle to the original parent class "
"structure. This pointer can then be used to access the original class "
"function pointer and invoke it directly. <placeholder-1/>"
msgstr ""

#: tut_howto.xml:742(para)
msgid ""
"The <emphasis>original</emphasis> adjective used in this sentence is not "
"innocuous. To fully understand its meaning, you need to recall how class "
"structures are initialized: for each object type, the class structure "
"associated to this object is created by first copying the class structure of "
"its parent type (a simple <function>memcpy</function>) and then by invoking "
"the class_init callback on the resulting class structure. Since the "
"class_init callback is responsible for overwriting the class structure with "
"the user re-implementations of the class methods, we cannot merely use the "
"modified copy of the parent class structure stored in our derived instance. "
"We want to get a copy of the class structure of an instance of the parent "
"class."
msgstr ""

#: tut_howto.xml:75(para)
msgid ""
"The basic conventions for any header which exposes a GType are described in "
"<xref linkend=\"gtype-conventions\"/>. Most GObject-based code also obeys "
"one of of the following conventions: pick one and stick to it. "
"<placeholder-1/>"
msgstr ""

#: tut_howto.xml:755(para)
msgid ""
"The function <function><link linkend=\"g-type-class-peek-parent"
"\">g_type_class_peek_parent</link></function> is used to access the original "
"parent class structure. Its input is a pointer to the class of the derived "
"object and it returns a pointer to the original parent class structure. The "
"code below shows how you could use it: <placeholder-1/>"
msgstr ""

#: tut_howto.xml:758(programlisting)
#, no-wrap
msgid ""
"\n"
"static void\n"
"b_method_to_call (B *obj, int a)\n"
"{\n"
"  BClass *klass;\n"
"  AClass *parent_class;\n"
"\n"
"  klass = B_GET_CLASS (obj);\n"
"  parent_class = g_type_class_peek_parent (klass);\n"
"\n"
"  /* do stuff before chain up */\n"
"\n"
"  parent_class-&gt;method_to_call (obj, a);\n"
"\n"
"  /* do stuff after chain up */\n"
"}\n"
msgstr ""

#: tut_howto.xml:783(title)
msgid "How to define and implement interfaces"
msgstr ""

#: tut_howto.xml:786(title)
msgid "How to define interfaces"
msgstr ""

#: tut_howto.xml:788(para)
msgid ""
"The bulk of interface definition has already been shown in <xref linkend="
"\"gtype-non-instantiable-classed\"/> but I feel it is needed to show exactly "
"how to create an interface."
msgstr ""

#: tut_howto.xml:793(para)
msgid ""
"As above, the first step is to get the header right: <placeholder-1/> This "
"code is the same as the code for a normal <link linkend=\"GType"
"\"><type>GType</type></link> which derives from a <link linkend=\"GObject"
"\"><type>GObject</type></link> except for a few details: <placeholder-2/>"
msgstr ""

#: tut_howto.xml:795(programlisting)
#, no-wrap
msgid ""
"\n"
"#ifndef __MAMAN_IBAZ_H__\n"
"#define __MAMAN_IBAZ_H__\n"
"\n"
"#include &lt;glib-object.h&gt;\n"
"\n"
"#define MAMAN_TYPE_IBAZ                 (maman_ibaz_get_type ())\n"
"#define MAMAN_IBAZ(obj)                 (G_TYPE_CHECK_INSTANCE_CAST ((obj), MAMAN_TYPE_IBAZ, MamanIbaz))\n"
"#define MAMAN_IS_IBAZ(obj)              (G_TYPE_CHECK_INSTANCE_TYPE ((obj), MAMAN_TYPE_IBAZ))\n"
"#define MAMAN_IBAZ_GET_INTERFACE(inst)  (G_TYPE_INSTANCE_GET_INTERFACE ((inst), MAMAN_TYPE_IBAZ, MamanIbazInterface))\n"
"\n"
"\n"
"typedef struct _MamanIbaz               MamanIbaz; /* dummy object */\n"
"typedef struct _MamanIbazInterface      MamanIbazInterface;\n"
"\n"
"struct _MamanIbazInterface\n"
"{\n"
"  GTypeInterface parent_iface;\n"
"\n"
"  void (*do_action) (MamanIbaz *self);\n"
"};\n"
"\n"
"GType maman_ibaz_get_type (void);\n"
"\n"
"void maman_ibaz_do_action (MamanIbaz *self);\n"
"\n"
"#endif /* __MAMAN_IBAZ_H__ */\n"
msgstr ""

#: tut_howto.xml:8(para)
msgid ""
"This chapter tries to answer the real-life questions of users and presents "
"the most common scenario use cases I could come up with. The use cases are "
"presented from most likely to less likely."
msgstr ""

#: tut_howto.xml:80(para)
msgid ""
"If you want to declare a type named bar with prefix maman, name the type "
"instance <function>MamanBar</function> and its class "
"<function>MamanBarClass</function> (name is case-sensitive). It is customary "
"to declare them with code similar to the following: <placeholder-1/>"
msgstr ""

#: tut_howto.xml:826(para)
msgid ""
"The <function>_GET_CLASS</function> macro is called "
"<function>_GET_INTERFACE</function> and not implemented with <function><link "
"linkend=\"G_TYPE_INSTANCE_GET_CLASS\">G_TYPE_INSTANCE_GET_CLASS</link></"
"function> but with <function><link linkend=\"G_TYPE_INSTANCE_GET_INTERFACE"
"\">G_TYPE_INSTANCE_GET_INTERFACE</link></function>."
msgstr ""

#: tut_howto.xml:831(para)
msgid ""
"The instance type, <type>MamanIbaz</type> is not fully defined: it is used "
"merely as an abstract type which represents an instance of whatever object "
"which implements the interface."
msgstr ""

#: tut_howto.xml:836(para)
msgid ""
"The parent of the <type>MamanIbazInterface</type> is not <type>GObjectClass</"
"type> but <type>GTypeInterface</type>."
msgstr ""

#: tut_howto.xml:843(para)
msgid ""
"The implementation of the <type>MamanIbaz</type> type itself is trivial: "
"<placeholder-1/><placeholder-2/>"
msgstr ""

#: tut_howto.xml:846(para)
msgid ""
"<function>maman_ibaz_get_type</function> registers the type in the type "
"system."
msgstr ""

#: tut_howto.xml:849(para)
msgid ""
"<function>maman_ibaz_base_init</function> is expected to register the "
"interface's signals if there are any (we will see a bit (later how to use "
"them). Make sure to use a static local boolean variable to make sure not to "
"run the initialization code twice (as described in <xref linkend=\"gtype-non-"
"instantiable-classed-init\"/>, <function>base_init</function> is run once "
"for each interface implementation instantiation)"
msgstr ""

#: tut_howto.xml:85(programlisting)
#, no-wrap
msgid ""
"\n"
"/*\n"
" * Copyright/Licensing information.\n"
" */\n"
"\n"
"/* inclusion guard */\n"
"#ifndef __MAMAN_BAR_H__\n"
"#define __MAMAN_BAR_H__\n"
"\n"
"#include &lt;glib-object.h&gt;\n"
"/*\n"
" * Potentially, include other headers on which this header depends.\n"
" */\n"
"\n"
"/*\n"
" * Type macros.\n"
" */\n"
"#define MAMAN_TYPE_BAR                  (maman_bar_get_type ())\n"
"#define MAMAN_BAR(obj)                  (G_TYPE_CHECK_INSTANCE_CAST ((obj), MAMAN_TYPE_BAR, MamanBar))\n"
"#define MAMAN_IS_BAR(obj)               (G_TYPE_CHECK_INSTANCE_TYPE ((obj), MAMAN_TYPE_BAR))\n"
"#define MAMAN_BAR_CLASS(klass)          (G_TYPE_CHECK_CLASS_CAST ((klass), MAMAN_TYPE_BAR, MamanBarClass))\n"
"#define MAMAN_IS_BAR_CLASS(klass)       (G_TYPE_CHECK_CLASS_TYPE ((klass), MAMAN_TYPE_BAR))\n"
"#define MAMAN_BAR_GET_CLASS(obj)        (G_TYPE_INSTANCE_GET_CLASS ((obj), MAMAN_TYPE_BAR, MamanBarClass))\n"
"\n"
"typedef struct _MamanBar        MamanBar;\n"
"typedef struct _MamanBarClass   MamanBarClass;\n"
"\n"
"struct _MamanBar\n"
"{\n"
"  GObject parent_instance;\n"
"\n"
"  /* instance members */\n"
"};\n"
"\n"
"struct _MamanBarClass\n"
"{\n"
"  GObjectClass parent_class;\n"
"\n"
"  /* class members */\n"
"};\n"
"\n"
"/* used by MAMAN_TYPE_BAR */\n"
"GType maman_bar_get_type (void);\n"
"\n"
"/*\n"
" * Method definitions.\n"
" */\n"
"\n"
"#endif /* __MAMAN_BAR_H__ */\n"
msgstr ""

#: tut_howto.xml:856(para)
msgid ""
"<function>maman_ibaz_do_action</function> dereferences the class structure "
"to access its associated class function and calls it."
msgstr ""

#: tut_howto.xml:860(programlisting)
#, no-wrap
msgid ""
"\n"
"static void\n"
"maman_ibaz_base_init (gpointer g_class)\n"
"{\n"
"  static gboolean is_initialized = FALSE;\n"
"\n"
"  if (!is_initialized)\n"
"    {\n"
"      /* add properties and signals to the interface here */\n"
"\n"
"      is_initialized = TRUE;\n"
"    }\n"
"}\n"
"\n"
"GType\n"
"maman_ibaz_get_type (void)\n"
"{\n"
"  static GType iface_type = 0;\n"
"  if (iface_type == 0)\n"
"    {\n"
"      static const GTypeInfo info = {\n"
"        sizeof (MamanIbazInterface),\n"
"        maman_ibaz_base_init,   /* base_init */\n"
"        NULL,   /* base_finalize */\n"
"      };\n"
"\n"
"      iface_type = g_type_register_static (G_TYPE_INTERFACE, \"MamanIbaz\",\n"
"                                           &amp;info, 0);\n"
"    }\n"
"\n"
"  return iface_type;\n"
"}\n"
"\n"
"void\n"
"maman_ibaz_do_action (MamanIbaz *self)\n"
"{\n"
"  g_return_if_fail (MAMAN_IS_IBAZ (self));\n"
"\n"
"  MAMAN_IBAZ_GET_INTERFACE (self)-&gt;do_action (self);\n"
"}\n"
msgstr ""

#: tut_howto.xml:905(title)
msgid "How To define implement an Interface?"
msgstr ""

#: tut_howto.xml:907(para)
msgid "Once the interface is defined, implementing it is rather trivial."
msgstr ""

#: tut_howto.xml:911(para)
msgid ""
"The first step is to define a normal GObject class, like: <placeholder-1/> "
"There is clearly nothing specifically weird or scary about this header: it "
"does not define any weird API or derives from a weird type."
msgstr ""

#: tut_howto.xml:913(programlisting)
#, no-wrap
msgid ""
"\n"
"#ifndef __MAMAN_BAZ_H__\n"
"#define __MAMAN_BAZ_H__\n"
"\n"
"#include &lt;glib-object.h&gt;\n"
"\n"
"#define MAMAN_TYPE_BAZ             (maman_baz_get_type ())\n"
"#define MAMAN_BAZ(obj)             (G_TYPE_CHECK_INSTANCE_CAST ((obj), MAMAN_TYPE_BAZ, Mamanbaz))\n"
"#define MAMAN_IS_BAZ(obj)          (G_TYPE_CHECK_INSTANCE_TYPE ((obj), MAMAN_TYPE_BAZ))\n"
"#define MAMAN_BAZ_CLASS(klass)     (G_TYPE_CHECK_CLASS_CAST ((klass), MAMAN_TYPE_BAZ, MamanbazClass))\n"
"#define MAMAN_IS_BAZ_CLASS(klass)  (G_TYPE_CHECK_CLASS_TYPE ((klass), MAMAN_TYPE_BAZ))\n"
"#define MAMAN_BAZ_GET_CLASS(obj)   (G_TYPE_INSTANCE_GET_CLASS ((obj), MAMAN_TYPE_BAZ, MamanbazClass))\n"
"\n"
"\n"
"typedef struct _MamanBaz        MamanBaz;\n"
"typedef struct _MamanBazClass   MamanBazClass;\n"
"\n"
"struct _MamanBaz\n"
"{\n"
"  GObject parent_instance;\n"
"\n"
"  int instance_member;\n"
"};\n"
"\n"
"struct _MamanBazClass\n"
"{\n"
"  GObjectClass parent_class;\n"
"};\n"
"\n"
"GType maman_baz_get_type (void);\n"
"\n"
"#endif /* __MAMAN_BAZ_H__ */\n"
msgstr ""

#: tut_howto.xml:950(para)
msgid ""
"The second step is to implement <type>MamanBaz</type> by defining its GType. "
"Instead of using <function>G_DEFINE_TYPE</function> we use "
"<function>G_DEFINE_TYPE_WITH_CODE</function> and the "
"<function>G_IMPLEMENT_INTERFACE</function> macros. <placeholder-1/> This "
"definition is very much like all the similar functions we looked at "
"previously. The only interface-specific code present here is the call to "
"<function>G_IMPLEMENT_INTERFACE</function>."
msgstr ""

#: tut_howto.xml:955(programlisting)
#, no-wrap
msgid ""
"\n"
"static void maman_ibaz_interface_init (MamanIbazInterface *iface);\n"
"\n"
"G_DEFINE_TYPE_WITH_CODE (MamanBar, maman_bar, G_TYPE_OBJECT,\n"
"                         G_IMPLEMENT_INTERFACE (MAMAN_TYPE_IBAZ,\n"
"                                                maman_ibaz_interface_init));\n"
msgstr ""

#: tut_howto.xml:967(para)
msgid ""
"Classes can implement multiple interfaces by using multiple calls to "
"<function>G_IMPLEMENT_INTERFACE</function> inside the call to "
"<function>G_DEFINE_TYPE_WITH_CODE</function>."
msgstr ""

#: tut_howto.xml:971(para)
msgid ""
"<function>maman_baz_interface_init</function>, the interface initialization "
"function: inside it every virtual method of the interface must be assigned "
"to its implementation: <placeholder-1/>"
msgstr ""

#: tut_howto.xml:975(programlisting)
#, no-wrap
msgid ""
"\n"
"static void\n"
"maman_baz_do_action (MamanBaz *self)\n"
"{\n"
"  g_print (\"Baz implementation of IBaz interface Action: 0x%x.\\n\",\n"
"           self-&gt;instance_member);\n"
"}\n"
"\n"
"static void\n"
"maman_ibaz_interface_init (MamanIbazInterface *iface)\n"
"{\n"
"  iface-&gt;do_action = baz_do_action;\n"
"}\n"
"\n"
"static void\n"
"maman_baz_init (MamanBaz *self)\n"
"{\n"
"  MamanBaz *self = MAMAN_BAZ (instance);\n"
"  self-&gt;instance_member = 0xdeadbeaf;\n"
"}\n"
msgstr ""
