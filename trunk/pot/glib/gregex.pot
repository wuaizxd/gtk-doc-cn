# SOME DESCRIPTIVE TITLE.
# Copyright (C) YEAR THE PACKAGE'S COPYRIGHT HOLDER
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2011-04-14 21:51-0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=INTEGER; plural=EXPRESSION;\n"

# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# used by: g_match_info_next:
# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# used by: g_match_info_matches:
# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# used by: g_match_info_get_match_count:
# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# used by: g_match_info_is_partial_match:
# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# used by: g_match_info_fetch_all:
#: gregex.c:1009:1 gregex.c:540:1 gregex.c:629:1 gregex.c:648:1 gregex.c:681:1
msgid "@match_info: a #GMatchInfo structure"
msgstr ""

# #used by: g_match_info_fetch_all:
#: gregex.c:1011:4
msgid ""
"Bundles up pointers to each of the matching substrings from a match and "
"stores them in an array of gchar pointers. The first element in the returned "
"array is the match number 0, i.e. the entire matched text."
msgstr ""

# #used by: g_match_info_fetch_all:
#: gregex.c:1016:2
msgid ""
"If a sub pattern didn't match anything (e.g. sub pattern 1, matching |$_1_$|"
"b|$_1_$| against |$_1_$|(a)?b|$_1_$|) then an empty string is inserted."
msgstr ""

# #used by: g_match_info_fetch_all:
#: gregex.c:1019:5
msgid ""
"If the last match was obtained using the DFA algorithm, that is using "
"g_regex_match_all() or g_regex_match_all_full(), the retrieved strings are "
"not that matched by sets of parentheses but that of the matched substring. "
"Substrings are matched in reverse order of length, so the first one is the "
"longest match."
msgstr ""

# #used by: g_match_info_fetch_all:
#: gregex.c:1025:2
msgid ""
"The strings are fetched from the string passed to the match function, so you "
"cannot call this function after freeing the string."
msgstr ""

# #used by: g_match_info_fetch_all:
#: gregex.c:1028:3
msgid ""
"Returns: (allow-none): a %NULL-terminated array of gchar * pointers. It must "
"be freed using g_strfreev(). If the previous match failed %NULL is returned"
msgstr ""

# #-#-#-#-#  gregex.pot~ (PACKAGE VERSION)  #-#-#-#-#
# #used by: GRegexError:
# #-#-#-#-#  gregex.pot~ (PACKAGE VERSION)  #-#-#-#-#
# #used by: G_REGEX_ERROR:
# #-#-#-#-#  gregex.pot~ (PACKAGE VERSION)  #-#-#-#-#
# #used by: GRegexCompileFlags:
# #-#-#-#-#  gregex.pot~ (PACKAGE VERSION)  #-#-#-#-#
# #used by: GRegexMatchFlags:
# #-#-#-#-#  gregex.pot~ (PACKAGE VERSION)  #-#-#-#-#
# #used by: GRegex:
# #-#-#-#-#  gregex.pot~ (PACKAGE VERSION)  #-#-#-#-#
# #used by: GRegexEvalCallback:
#: gregex.c:1032:1 gregex.c:1077:1 gregex.c:1094:1 gregex.c:1125:1
#: gregex.c:1277:1 gregex.c:1297:1 gregex.c:1318:1 gregex.c:1387:1
#: gregex.c:1455:1 gregex.c:1530:1 gregex.c:1586:1 gregex.c:1648:1
#: gregex.c:1726:1 gregex.c:1781:1 gregex.c:1826:1 gregex.c:1872:1
#: gregex.c:2526:1 gregex.c:2600:1 gregex.c:2681:1 gregex.c:2753:1
#: gregex.c:2795:1 gregex.c:490:1 gregex.c:509:1 gregex.c:524:1 gregex.c:552:1
#: gregex.c:636:1 gregex.c:661:1 gregex.c:718:1 gregex.c:754:1 gregex.c:817:1
#: gregex.c:870:1 gregex.c:948:1 gregex.c:987:1 gregex.h:115:1 gregex.h:172:1
#: gregex.h:239:1 gregex.h:302:1 gregex.h:325:1 gregex.h:347:1
msgid "Since: 2.14"
msgstr ""

# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# used by: g_regex_ref:
# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# used by: g_regex_unref:
# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# used by: g_regex_get_max_backref:
# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# used by: g_regex_get_capture_count:
# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# used by: g_regex_get_compile_flags:
# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# used by: g_regex_get_match_flags:
#: gregex.c:1071:1 gregex.c:1089:1 gregex.c:1289:1 gregex.c:1312:1
#: gregex.c:1333:1 gregex.c:1351:1
msgid "@regex: a #GRegex"
msgstr ""

# #used by: g_regex_ref:
#: gregex.c:1073:1
msgid "Increases reference count of @regex by 1."
msgstr ""

# #used by: g_regex_ref:
#: gregex.c:1075:1
msgid "Returns: @regex"
msgstr ""

# #used by: g_regex_unref:
#: gregex.c:1091:2
msgid ""
"Decreases reference count of @regex by 1. When reference count drops to "
"zero, it frees all the memory associated with the regex structure."
msgstr ""

# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# used by: g_regex_new:
# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# used by: g_regex_match_simple:
# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# used by: g_regex_split_simple:
#: gregex.c:1114:1 gregex.c:1369:1 gregex.c:1746:1
msgid "@pattern: the regular expression"
msgstr ""

# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# used by: g_regex_new:
# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# used by: g_regex_match_simple:
# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# used by: g_regex_split_simple:
#: gregex.c:1115:1 gregex.c:1371:1 gregex.c:1748:1
msgid "@compile_options: compile options for the regular expression, or 0"
msgstr ""

# used by: g_regex_new:
#: gregex.c:1116:1
msgid "@match_options: match options for the regular expression, or 0"
msgstr ""

# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# used by: g_regex_new:
# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# used by: g_regex_split_full:
#: gregex.c:1117:1 gregex.c:1846:1
msgid "@error: return location for a #GError"
msgstr ""

# #used by: g_regex_new:
#: gregex.c:1119:2
msgid ""
"Compiles the regular expression to an internal form, and does the initial "
"setup of the #GRegex structure."
msgstr ""

# #used by: g_regex_new:
#: gregex.c:1122:2
msgid ""
"Returns: a #GRegex structure. Call g_regex_unref() when you are done with it"
msgstr ""

# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# used by: g_regex_get_pattern:
# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# used by: g_regex_split:
# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# used by: g_regex_split_full:
# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# used by: g_regex_replace:
# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# used by: g_regex_replace_literal:
#: gregex.c:1270:1 gregex.c:1802:1 gregex.c:1839:1 gregex.c:2469:1
#: gregex.c:2581:1
msgid "@regex: a #GRegex structure"
msgstr ""

# #used by: g_regex_get_pattern:
#: gregex.c:1272:2
msgid ""
"Gets the pattern string associated with @regex, i.e. a copy of the string "
"passed to g_regex_new()."
msgstr ""

# #used by: g_regex_get_pattern:
#: gregex.c:1275:1
msgid "Returns: the pattern of @regex"
msgstr ""

# #used by: g_regex_get_max_backref:
#: gregex.c:1291:3
msgid ""
"Returns the number of the highest back reference in the pattern, or 0 if the "
"pattern does not contain back references."
msgstr ""

# #used by: g_regex_get_max_backref:
#: gregex.c:1295:1
msgid "Returns: the number of the highest back reference"
msgstr ""

# #used by: g_regex_get_capture_count:
#: gregex.c:1314:1
msgid "Returns the number of capturing subpatterns in the pattern."
msgstr ""

# #used by: g_regex_get_capture_count:
#: gregex.c:1316:1
msgid "Returns: the number of capturing subpatterns"
msgstr ""

# #used by: g_regex_get_compile_flags:
#: gregex.c:1335:1
msgid "Returns the compile options that @regex was created with."
msgstr ""

# #used by: g_regex_get_compile_flags:
#: gregex.c:1337:1
msgid "Returns: flags from #GRegexCompileFlags"
msgstr ""

# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# #used by: g_regex_get_compile_flags:
# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# #used by: g_regex_get_match_flags:
#: gregex.c:1339:1 gregex.c:1357:1
msgid "Since: 2.26"
msgstr ""

# #used by: g_regex_get_match_flags:
#: gregex.c:1353:1
msgid "Returns the match options that @regex was created with."
msgstr ""

# #used by: g_regex_get_match_flags:
#: gregex.c:1355:1
msgid "Returns: flags from #GRegexMatchFlags"
msgstr ""

# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# used by: g_regex_match_simple:
# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# used by: g_regex_match:
# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# used by: g_regex_match_all:
# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# used by: g_regex_split_simple:
#: gregex.c:1370:1 gregex.c:1409:1 gregex.c:1564:1 gregex.c:1747:1
msgid "@string: the string to scan for matches"
msgstr ""

# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# used by: g_regex_match_simple:
# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# used by: g_regex_split_simple:
#: gregex.c:1372:1 gregex.c:1749:1
msgid "@match_options: match options, or 0"
msgstr ""

# #used by: g_regex_match_simple:
#: gregex.c:1374:1
msgid "Scans for a match in @string for @pattern."
msgstr ""

# #used by: g_regex_match_simple:
#: gregex.c:1376:4
msgid ""
"This function is equivalent to g_regex_match() but it does not require to "
"compile the pattern with g_regex_new(), avoiding some lines of code when you "
"need just to do a match without extracting substrings, capture counts, and "
"so on."
msgstr ""

# #used by: g_regex_match_simple:
#: gregex.c:1381:3
msgid ""
"If this function is to be called on the same @pattern more than once, it's "
"more efficient to compile the pattern once with g_regex_new() and then use "
"g_regex_match()."
msgstr ""

# #used by: g_regex_match_simple:
#: gregex.c:1385:1
msgid "Returns: %TRUE if the string matched, %FALSE otherwise"
msgstr ""

# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# used by: g_regex_match:
# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# used by: g_regex_match_full:
# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# used by: g_regex_match_all:
# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# used by: g_regex_match_all_full:
# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# used by: g_regex_replace_eval:
#: gregex.c:1408:1 gregex.c:1469:1 gregex.c:1563:1 gregex.c:1600:1
#: gregex.c:2624:1
msgid "@regex: a #GRegex structure from g_regex_new()"
msgstr ""

# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# used by: g_regex_match:
# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# used by: g_regex_match_full:
# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# used by: g_regex_match_all:
# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# used by: g_regex_match_all_full:
#: gregex.c:1410:1 gregex.c:1473:1 gregex.c:1565:1 gregex.c:1604:1
msgid "@match_options: match options"
msgstr ""

# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# used by: g_regex_match:
# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# used by: g_regex_match_full:
# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# used by: g_regex_match_all:
# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# used by: g_regex_match_all_full:
#: gregex.c:1411:2 gregex.c:1474:2 gregex.c:1566:2 gregex.c:1605:2
msgid ""
"@match_info: (out) (allow-none): pointer to location where to store the "
"#GMatchInfo, or %NULL if you do not need it"
msgstr ""

# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# #used by: g_regex_match:
# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# #used by: g_regex_match_full:
#: gregex.c:1414:4 gregex.c:1478:4
msgid ""
"Scans for a match in string for the pattern in @regex. The @match_options "
"are combined with the match options specified when the @regex structure was "
"created, letting you have more flexibility in reusing #GRegex structures."
msgstr ""

# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# #used by: g_regex_match:
# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# #used by: g_regex_match_full:
# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# #used by: g_regex_match_all:
# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# #used by: g_regex_match_all_full:
#: gregex.c:1419:4 gregex.c:1487:5 gregex.c:1574:5 gregex.c:1636:5
msgid ""
"A #GMatchInfo structure, used to get information on the match, is stored in "
"@match_info if not %NULL. Note that if @match_info is not %NULL then it is "
"created even if the function returns %FALSE, i.e. you must free it "
"regardless if regular expression actually matched."
msgstr ""

# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# #used by: g_regex_match:
# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# #used by: g_regex_match_full:
#: gregex.c:1424:2 gregex.c:1497:2
msgid ""
"To retrieve all the non-overlapping matches of the pattern in string you can "
"use g_match_info_next()."
msgstr ""

# #used by: g_regex_match:
#: gregex.c:1427:21
msgid ""
"|[ static void print_uppercase_words (const gchar *string) { /&ast; Print "
"all uppercase-only words. &ast;/ GRegex *regex; GMatchInfo *match_info; "
"&nbsp; regex = g_regex_new (|$_1_$|[A-Z]+|$_1_$|, 0, 0, NULL); g_regex_match "
"(regex, string, 0, &amp;match_info); while (g_match_info_matches "
"(match_info)) { gchar *word = g_match_info_fetch (match_info, 0); g_print (|"
"$_1_$|Found: %s|$_2_$|n|$_1_$|, word); g_free (word); g_match_info_next "
"(match_info, NULL); } g_match_info_free (match_info); g_regex_unref "
"(regex); } ]|"
msgstr ""

# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# #used by: g_regex_match:
# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# #used by: g_regex_match_full:
# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# #used by: g_regex_match_all:
# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# #used by: g_regex_match_all_full:
#: gregex.c:1449:3 gregex.c:1493:3 gregex.c:1580:3 gregex.c:1642:3
msgid ""
"@string is not copied and is used in #GMatchInfo internally. If you use any "
"#GMatchInfo method (except g_match_info_free()) after freeing or modifying "
"@string then the behaviour is undefined."
msgstr ""

# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# #used by: g_match_info_next:
# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# #used by: g_regex_match:
# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# #used by: g_regex_match_full:
# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# #used by: g_regex_match_all:
# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# #used by: g_regex_match_all_full:
#: gregex.c:1453:1 gregex.c:1528:1 gregex.c:1584:1 gregex.c:1646:1
#: gregex.c:550:1
msgid "Returns: %TRUE is the string matched, %FALSE otherwise"
msgstr ""

# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# used by: g_regex_match_full:
# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# used by: g_regex_match_all_full:
#: gregex.c:1470:1 gregex.c:1601:1
msgid "@string: (array length=string_len): the string to scan for matches"
msgstr ""

# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# used by: g_regex_match_full:
# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# used by: g_regex_match_all_full:
# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# used by: g_regex_split_full:
# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# used by: g_regex_replace:
# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# used by: g_regex_replace_literal:
# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# used by: g_regex_replace_eval:
#: gregex.c:1471:1 gregex.c:1602:1 gregex.c:1841:1 gregex.c:2471:1
#: gregex.c:2583:1 gregex.c:2626:1
msgid "@string_len: the length of @string, or -1 if @string is nul-terminated"
msgstr ""

# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# used by: g_regex_match_full:
# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# used by: g_regex_match_all_full:
# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# used by: g_regex_split_full:
# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# used by: g_regex_replace:
# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# used by: g_regex_replace_literal:
# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# used by: g_regex_replace_eval:
#: gregex.c:1472:1 gregex.c:1603:1 gregex.c:1842:1 gregex.c:2472:1
#: gregex.c:2584:1 gregex.c:2627:1
msgid "@start_position: starting index of the string to match"
msgstr ""

# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# used by: g_match_info_next:
# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# used by: g_match_info_expand_references:
# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# used by: g_regex_match_full:
# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# used by: g_regex_match_all_full:
# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# used by: g_regex_replace:
# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# used by: g_regex_replace_literal:
# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# used by: g_regex_replace_eval:
#: gregex.c:1476:1 gregex.c:1607:1 gregex.c:2475:1 gregex.c:2587:1
#: gregex.c:2631:1 gregex.c:541:1 gregex.c:732:1
msgid "@error: location to store the error occuring, or %NULL to ignore errors"
msgstr ""

# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# #used by: g_regex_match_full:
# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# #used by: g_regex_match_all_full:
# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# #used by: g_regex_split_full:
# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# #used by: g_regex_replace:
# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# #used by: g_regex_replace_literal:
# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# #used by: g_regex_replace_eval:
#: gregex.c:1483:3 gregex.c:1632:3 gregex.c:1866:3 gregex.c:2520:3
#: gregex.c:2593:4 gregex.c:2636:3
msgid ""
"Setting @start_position differs from just passing over a shortened string "
"and setting #G_REGEX_MATCH_NOTBOL in the case of a pattern that begins with "
"any kind of lookbehind assertion, such as |$_1_$||$_2_$|b|$_1_$|."
msgstr ""

# #used by: g_regex_match_full:
#: gregex.c:1500:27
msgid ""
"|[ static void print_uppercase_words (const gchar *string) { /&ast; Print "
"all uppercase-only words. &ast;/ GRegex *regex; GMatchInfo *match_info; "
"GError *error = NULL; &nbsp; regex = g_regex_new (|$_1_$|[A-Z]+|$_1_$|, 0, "
"0, NULL); g_regex_match_full (regex, string, -1, 0, 0, &amp;match_info, &amp;"
"error); while (g_match_info_matches (match_info)) { gchar *word = "
"g_match_info_fetch (match_info, 0); g_print (|$_1_$|Found: %s|$_2_$|n|$_1_"
"$|, word); g_free (word); g_match_info_next (match_info, &amp;error); } "
"g_match_info_free (match_info); g_regex_unref (regex); if (error != NULL) "
"{ g_printerr (|$_1_$|Error while matching: %s|$_2_$|n|$_1_$|, error-"
">message); g_error_free (error); } } ]|"
msgstr ""

# #used by: g_regex_match_all:
#: gregex.c:1569:4
msgid ""
"Using the standard algorithm for regular expression matching only the "
"longest match in the string is retrieved. This function uses a different "
"algorithm so it can retrieve all the possible matches. For more "
"documentation see g_regex_match_all_full()."
msgstr ""

# #used by: g_regex_match_all_full:
#: gregex.c:1609:5
msgid ""
"Using the standard algorithm for regular expression matching only the "
"longest match in the string is retrieved, it is not possibile to obtain all "
"the available matches. For instance matching |$_1_$|&lt;a&gt; &lt;b&gt; &lt;"
"c&gt;|$_1_$| against the pattern |$_1_$|&lt;.*&gt;|$_1_$| you get |$_1_$|&lt;"
"a&gt; &lt;b&gt; &lt;c&gt;|$_1_$|."
msgstr ""

# #used by: g_regex_match_all_full:
#: gregex.c:1615:6
msgid ""
"This function uses a different algorithm (called DFA, i.e. deterministic "
"finite automaton), so it can retrieve all the possible matches, all starting "
"at the same point in the string. For instance matching |$_1_$|&lt;a&gt; &lt;"
"b&gt; &lt;c&gt;|$_1_$| against the pattern |$_1_$|&lt;.*&gt;|$_1_$| you "
"would obtain three matches: |$_1_$|&lt;a&gt; &lt;b&gt; &lt;c&gt;|$_1_$|, |"
"$_1_$|&lt;a&gt; &lt;b&gt;|$_1_$| and |$_1_$|&lt;a&gt;|$_1_$|."
msgstr ""

# #used by: g_regex_match_all_full:
#: gregex.c:1622:6
msgid ""
"The number of matched strings is retrieved using g_match_info_get_match_count"
"(). To obtain the matched strings and their position you can use, "
"respectively, g_match_info_fetch() and g_match_info_fetch_pos(). Note that "
"the strings are returned in reverse order of length; that is, the longest "
"matching string is given first."
msgstr ""

# #used by: g_regex_match_all_full:
#: gregex.c:1629:2
msgid ""
"Note that the DFA algorithm is slower than the standard one and it is not "
"able to capture substrings, so backreferences do not work."
msgstr ""

# used by: g_regex_get_string_number:
#: gregex.c:1718:1
msgid "@regex: #GRegex structure"
msgstr ""

# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# used by: g_match_info_fetch_named:
# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# used by: g_match_info_fetch_named_pos:
# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# used by: g_regex_get_string_number:
#: gregex.c:1719:1 gregex.c:934:1 gregex.c:971:1
msgid "@name: name of the subexpression"
msgstr ""

# #used by: g_regex_get_string_number:
#: gregex.c:1721:1
msgid "Retrieves the number of the subexpression named @name."
msgstr ""

# #used by: g_regex_get_string_number:
#: gregex.c:1723:2
msgid "Returns: The number of the subexpression or -1 if @name does not exists"
msgstr ""

# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# #used by: g_regex_split_simple:
# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# #used by: g_regex_split:
# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# #used by: g_regex_split_full:
#: gregex.c:1751:5 gregex.c:1806:5 gregex.c:1848:5
msgid ""
"Breaks the string on the pattern, and returns an array of the tokens. If the "
"pattern contains capturing parentheses, then the text for each of the "
"substrings will also be returned. If the pattern does not match anywhere in "
"the string, then the whole string is returned as the first token."
msgstr ""

# #used by: g_regex_split_simple:
#: gregex.c:1757:4
msgid ""
"This function is equivalent to g_regex_split() but it does not require to "
"compile the pattern with g_regex_new(), avoiding some lines of code when you "
"need just to do a split without extracting substrings, capture counts, and "
"so on."
msgstr ""

# #used by: g_regex_split_simple:
#: gregex.c:1762:3
msgid ""
"If this function is to be called on the same @pattern more than once, it's "
"more efficient to compile the pattern once with g_regex_new() and then use "
"g_regex_split()."
msgstr ""

# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# #used by: g_regex_split_simple:
# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# #used by: g_regex_split:
# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# #used by: g_regex_split_full:
#: gregex.c:1766:7 gregex.c:1812:6 gregex.c:1854:6
msgid ""
"As a special case, the result of splitting the empty string |$_1_$||$_1_$| "
"is an empty vector, not a vector containing a single string. The reason for "
"this special case is that being able to represent a empty vector is "
"typically more useful than consistent handling of empty elements. If you do "
"need to represent empty elements, you'll need to check for the empty string "
"before calling this function."
msgstr ""

# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# #used by: g_regex_split_simple:
# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# #used by: g_regex_split:
# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# #used by: g_regex_split_full:
#: gregex.c:1774:4 gregex.c:1819:4 gregex.c:1861:4
msgid ""
"A pattern that can match empty strings splits @string into separate "
"characters wherever it matches the empty string between characters. For "
"example splitting |$_1_$|ab c|$_1_$| using as a separator |$_1_$||$_2_$|s*|"
"$_1_$|, you will get |$_1_$|a|$_1_$|, |$_1_$|b|$_1_$| and |$_1_$|c|$_1_$|."
msgstr ""

# #used by: g_regex_split_simple:
#: gregex.c:1779:1
msgid ""
"Returns: a %NULL-terminated array of strings. Free it using g_strfreev()"
msgstr ""

# used by: g_regex_split:
#: gregex.c:1803:1
msgid "@string: the string to split with the pattern"
msgstr ""

# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# used by: g_regex_split:
# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# used by: g_regex_split_full:
#: gregex.c:1804:1 gregex.c:1843:1
msgid "@match_options: match time option flags"
msgstr ""

# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# #used by: g_regex_split:
# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# #used by: g_regex_split_full:
#: gregex.c:1824:1 gregex.c:1870:1
msgid "Returns: a %NULL-terminated gchar ** array. Free it using g_strfreev()"
msgstr ""

# used by: g_regex_split_full:
#: gregex.c:1840:1
msgid ""
"@string: (array length=string_len): the string to split with the pattern"
msgstr ""

# used by: g_regex_split_full:
#: gregex.c:1844:2
msgid ""
"@max_tokens: the maximum number of tokens to split @string into. If this is "
"less than 1, the string is split completely"
msgstr ""

# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# used by: g_regex_replace:
# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# used by: g_regex_replace_literal:
#: gregex.c:2470:1 gregex.c:2582:1
msgid ""
"@string: (array length=string_len): the string to perform matches against"
msgstr ""

# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# used by: g_regex_replace:
# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# used by: g_regex_replace_literal:
#: gregex.c:2473:1 gregex.c:2585:1
msgid "@replacement: text to replace each match with"
msgstr ""

# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# used by: g_regex_replace:
# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# used by: g_regex_replace_literal:
# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# used by: g_regex_replace_eval:
#: gregex.c:2474:1 gregex.c:2586:1 gregex.c:2628:1
msgid "@match_options: options for the match"
msgstr ""

# #used by: g_regex_replace:
#: gregex.c:2477:8
msgid ""
"Replaces all occurrences of the pattern in @regex with the replacement text. "
"Backreferences of the form '|$_2_$|number' or '|$_2_$|g&lt;number&gt;' in "
"the replacement text are interpolated by the number-th captured "
"subexpression of the match, '|$_2_$|g&lt;name&gt;' refers to the captured "
"subexpression with the given name. '|$_2_$|0' refers to the complete match, "
"but '|$_2_$|0' followed by a number is the octal representation of a "
"character. To include a literal '|$_2_$|' in the replacement, write '|$_2_$||"
"$_2_$|'. There are also escapes that changes the case of the following text:"
msgstr ""

# #used by: g_regex_replace:
#: gregex.c:2486:27
msgid ""
"<variablelist> <varlistentry><term>|$_2_$|l</term> <listitem> <para>Convert "
"to lower case the next character</para> </listitem> </varlistentry> "
"<varlistentry><term>|$_2_$|u</term> <listitem> <para>Convert to upper case "
"the next character</para> </listitem> </varlistentry> <varlistentry><term>|"
"$_2_$|L</term> <listitem> <para>Convert to lower case till |$_2_$|E</para> </"
"listitem> </varlistentry> <varlistentry><term>|$_2_$|U</term> <listitem> "
"<para>Convert to upper case till |$_2_$|E</para> </listitem> </varlistentry> "
"<varlistentry><term>|$_2_$|E</term> <listitem> <para>End case modification</"
"para> </listitem> </varlistentry> </variablelist>"
msgstr ""

# #used by: g_regex_replace:
#: gregex.c:2514:1
msgid "If you do not need to use backreferences use g_regex_replace_literal()."
msgstr ""

# #used by: g_regex_replace:
#: gregex.c:2516:3
msgid ""
"The @replacement string must be UTF-8 encoded even if #G_REGEX_RAW was "
"passed to g_regex_new(). If you want to use not UTF-8 encoded stings you can "
"use g_regex_replace_literal()."
msgstr ""

# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# #used by: g_regex_replace:
# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# #used by: g_regex_replace_literal:
# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# #used by: g_regex_replace_eval:
#: gregex.c:2524:1 gregex.c:2598:1 gregex.c:2679:1
msgid "Returns: a newly allocated string containing the replacements"
msgstr ""

# #used by: g_regex_replace_literal:
#: gregex.c:2589:3
msgid ""
"Replaces all occurrences of the pattern in @regex with the replacement text. "
"@replacement is replaced literally, to include backreferences use "
"g_regex_replace()."
msgstr ""

# used by: g_regex_replace_eval:
#: gregex.c:2625:1
msgid "@string: (array length=string_len): string to perform matches against"
msgstr ""

# used by: g_regex_replace_eval:
#: gregex.c:2629:1
msgid "@eval: a function to call for each match"
msgstr ""

# used by: g_regex_replace_eval:
#: gregex.c:2630:1
msgid "@user_data: user data to pass to the function"
msgstr ""

# #used by: g_regex_replace_eval:
#: gregex.c:2633:2
msgid ""
"Replaces occurrences of the pattern in regex with the output of @eval for "
"that occurrence."
msgstr ""

# #used by: g_regex_replace_eval:
#: gregex.c:2640:10
msgid ""
"The following example uses g_regex_replace_eval() to replace multiple "
"strings at once: |[ static gboolean eval_cb (const GMatchInfo *info, "
"GString          *res, gpointer          data) { gchar *match; gchar *r;"
msgstr ""

# #used by: g_regex_replace_eval:
#: gregex.c:2651:4
msgid ""
"match = g_match_info_fetch (info, 0); r = g_hash_table_lookup ((GHashTable *)"
"data, match); g_string_append (res, r); g_free (match);"
msgstr ""

# #used by: g_regex_replace_eval:
#: gregex.c:2656:2
msgid "return FALSE; }"
msgstr ""

# #used by: g_regex_replace_eval:
#: gregex.c:2659:1
msgid "/&ast; ... &ast;/"
msgstr ""

# #used by: g_regex_replace_eval:
#: gregex.c:2661:3
msgid "GRegex *reg; GHashTable *h; gchar *res;"
msgstr ""

# #used by: g_regex_replace_eval:
#: gregex.c:2665:1
msgid "h = g_hash_table_new (g_str_hash, g_str_equal);"
msgstr ""

# #used by: g_regex_replace_eval:
#: gregex.c:2667:4
msgid ""
"g_hash_table_insert (h, |$_1_$|1|$_1_$|, |$_1_$|ONE|$_1_$|); "
"g_hash_table_insert (h, |$_1_$|2|$_1_$|, |$_1_$|TWO|$_1_$|); "
"g_hash_table_insert (h, |$_1_$|3|$_1_$|, |$_1_$|THREE|$_1_$|); "
"g_hash_table_insert (h, |$_1_$|4|$_1_$|, |$_1_$|FOUR|$_1_$|);"
msgstr ""

# #used by: g_regex_replace_eval:
#: gregex.c:2672:3
msgid ""
"reg = g_regex_new (|$_1_$|1|2|3|4|$_1_$|, 0, 0, NULL); res = "
"g_regex_replace_eval (reg, text, -1, 0, 0, eval_cb, h, NULL); "
"g_hash_table_destroy (h);"
msgstr ""

# #used by: g_regex_replace_eval:
#: gregex.c:2676:2
msgid "/&ast; ... &ast;/ ]|"
msgstr ""

# used by: g_regex_check_replacement:
#: gregex.c:2736:1
msgid "@replacement: the replacement string"
msgstr ""

# used by: g_regex_check_replacement:
#: gregex.c:2737:2
msgid ""
"@has_references: (out) (allow-none): location to store information about "
"references in @replacement or %NULL"
msgstr ""

# used by: g_regex_check_replacement:
#: gregex.c:2739:1
msgid "@error: location to store error"
msgstr ""

# #used by: g_regex_check_replacement:
#: gregex.c:2741:3
msgid ""
"Checks whether @replacement is a valid replacement string (see "
"g_regex_replace()), i.e. that all escape sequences in it are valid."
msgstr ""

# #used by: g_regex_check_replacement:
#: gregex.c:2745:5
msgid ""
"If @has_references is not %NULL then @replacement is checked for pattern "
"references. For instance, replacement text 'foo|$_2_$|n' does not contain "
"references and may be evaluated without information about actual match, but "
"'|$_2_$|0|$_2_$|1' (whole match followed by first subpattern) requires valid "
"#GMatchInfo object."
msgstr ""

# #used by: g_regex_check_replacement:
#: gregex.c:2751:1
msgid "Returns: whether @replacement is a valid replacement string"
msgstr ""

# used by: g_regex_escape_string:
#: gregex.c:2782:1
msgid "@string: (array length=length): the string to escape"
msgstr ""

# used by: g_regex_escape_string:
#: gregex.c:2783:1
msgid "@length: the length of @string, or -1 if @string is nul-terminated"
msgstr ""

# #used by: g_regex_escape_string:
#: gregex.c:2785:3
msgid ""
"Escapes the special characters used for regular expressions in @string, for "
"instance |$_1_$|a.b*c|$_1_$| becomes |$_1_$|a|$_2_$|.b|$_2_$|*c|$_1_$|. This "
"function is useful to dynamically generate regular expressions."
msgstr ""

# #used by: g_regex_escape_string:
#: gregex.c:2789:3
msgid ""
"@string can contain nul characters that are replaced with |$_1_$||$_2_$|0|"
"$_1_$|, in this case remember to specify the correct length of @string in "
"@length."
msgstr ""

# #used by: g_regex_escape_string:
#: gregex.c:2793:1
msgid "Returns: a newly-allocated escaped string"
msgstr ""

# used by: SECTION:gregex
#: gregex.c:42:1
msgid "@title: Perl-compatible regular expressions"
msgstr ""

# used by: SECTION:gregex
#: gregex.c:43:1
msgid "@short_description: matches strings against regular expressions"
msgstr ""

# used by: SECTION:gregex
#: gregex.c:44:1
msgid "@see_also: <xref linkend=|$_1_$|glib-regex-syntax|$_1_$|/>"
msgstr ""

# #used by: SECTION:gregex
#: gregex.c:46:3
msgid ""
"The <function>g_regex_*()</function> functions implement regular expression "
"pattern matching using syntax and semantics similar to Perl regular "
"expression."
msgstr ""

# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# used by: g_match_info_get_regex:
# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# used by: g_match_info_get_string:
# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# used by: g_match_info_free:
#: gregex.c:482:1 gregex.c:501:1 gregex.c:520:1
msgid "@match_info: a #GMatchInfo"
msgstr ""

# #used by: g_match_info_get_regex:
#: gregex.c:484:3
msgid ""
"Returns #GRegex object used in @match_info. It belongs to Glib and must not "
"be freed. Use g_regex_ref() if you need to keep it after you free "
"@match_info object."
msgstr ""

# #used by: g_match_info_get_regex:
#: gregex.c:488:1
msgid "Returns: #GRegex object used in @match_info"
msgstr ""

# #used by: SECTION:gregex
#: gregex.c:50:12
msgid ""
"Some functions accept a @start_position argument, setting it differs from "
"just passing over a shortened string and setting #G_REGEX_MATCH_NOTBOL in "
"the case of a pattern that begins with any kind of lookbehind assertion. For "
"example, consider the pattern |$_1_$||$_2_$|Biss|$_2_$|B|$_1_$| which finds "
"occurrences of |$_1_$|iss|$_1_$| in the middle of words. (|$_1_$||$_2_$|B|"
"$_1_$| matches only if the current position in the subject is not a word "
"boundary.) When applied to the string |$_1_$|Mississipi|$_1_$| from the "
"fourth byte, namely |$_1_$|issipi|$_1_$|, it does not match, because |$_1_$||"
"$_2_$|B|$_1_$| is always false at the start of the subject, which is deemed "
"to be a word boundary. However, if the entire string is passed , but with "
"@start_position set to 4, it finds the second occurrence of |$_1_$|iss|$_1_"
"$| because it is able to look behind the starting point to discover that it "
"is preceded by a letter."
msgstr ""

# #used by: g_match_info_get_string:
#: gregex.c:503:3
msgid ""
"Returns the string searched with @match_info. This is the string passed to "
"g_regex_match() or g_regex_replace() so you may not free it before calling "
"this function."
msgstr ""

# #used by: g_match_info_get_string:
#: gregex.c:507:1
msgid "Returns: the string searched with @match_info"
msgstr ""

# #used by: g_match_info_free:
#: gregex.c:522:1
msgid "Frees all the memory associated with the #GMatchInfo structure."
msgstr ""

# #used by: g_match_info_next:
#: gregex.c:543:3
msgid ""
"Scans for the next match using the same parameters of the previous call to "
"g_regex_match_full() or g_regex_match() that returned @match_info."
msgstr ""

# #used by: g_match_info_next:
#: gregex.c:547:2
msgid ""
"The match is done on the string passed to the match function, so you cannot "
"free it before calling this function."
msgstr ""

# #used by: SECTION:gregex
#: gregex.c:63:7
msgid ""
"Note that, unless you set the #G_REGEX_RAW flag, all the strings passed to "
"these functions must be encoded in UTF-8. The lengths and the positions "
"inside the strings are in bytes and not in characters, so, for instance, |"
"$_1_$||$_2_$|xc3|$_2_$|xa0|$_1_$| (i.e. |$_1_$|&agrave;|$_1_$|) is two bytes "
"long but it is treated as a single character. If you set #G_REGEX_RAW the "
"strings can be non-valid UTF-8 strings and a byte is treated as a character, "
"so |$_1_$||$_2_$|xc3|$_2_$|xa0|$_1_$| is two bytes and two characters long."
msgstr ""

# #used by: g_match_info_matches:
#: gregex.c:631:1
msgid "Returns whether the previous match operation succeeded."
msgstr ""

# #used by: g_match_info_matches:
#: gregex.c:633:2
msgid ""
"Returns: %TRUE if the previous match operation succeeded, %FALSE otherwise"
msgstr ""

# #used by: g_match_info_get_match_count:
#: gregex.c:650:3
msgid ""
"Retrieves the number of matched substrings (including substring 0, that is "
"the whole matched text), so 1 is returned if the pattern has no substrings "
"in it and 0 is returned if the match failed."
msgstr ""

# #used by: g_match_info_get_match_count:
#: gregex.c:654:4
msgid ""
"If the last match was obtained using the DFA algorithm, that is using "
"g_regex_match_all() or g_regex_match_all_full(), the retrieved count is not "
"that of the number of capturing parentheses but that of the number of "
"matched substrings."
msgstr ""

# #used by: g_match_info_get_match_count:
#: gregex.c:659:1
msgid "Returns: Number of matched substrings, or -1 if an error occurred"
msgstr ""

# #used by: g_match_info_is_partial_match:
#: gregex.c:683:4
msgid ""
"Usually if the string passed to g_regex_match*() matches as far as it goes, "
"but is too short to match the entire pattern, %FALSE is returned. There are "
"circumstances where it might be helpful to distinguish this case from other "
"cases in which there is no match."
msgstr ""

# #used by: g_match_info_is_partial_match:
#: gregex.c:688:7
msgid ""
"Consider, for example, an application where a human is required to type in "
"data for a field with specific formatting requirements. An example might be "
"a date in the form ddmmmyy, defined by the pattern |$_1_$|^|$_2_$|d?|$_2_$|d"
"(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)|$_2_$|d|$_2_$|d$|$_1_$|. "
"If the application sees the user\342\200\231s keystrokes one by one, and can "
"check that what has been typed so far is potentially valid, it is able to "
"raise an error as soon as a mistake is made."
msgstr ""

# #used by: g_match_info_is_partial_match:
#: gregex.c:696:6
msgid ""
"GRegex supports the concept of partial matching by means of the "
"#G_REGEX_MATCH_PARTIAL flag. When this is set the return code for "
"g_regex_match() or g_regex_match_full() is, as usual, %TRUE for a complete "
"match, %FALSE otherwise. But, when these functions return %FALSE, you can "
"check if the match was partial calling g_match_info_is_partial_match()."
msgstr ""

# #used by: g_match_info_is_partial_match:
#: gregex.c:703:1
msgid "When using partial matching you cannot use g_match_info_fetch*()."
msgstr ""

# #used by: g_match_info_is_partial_match:
#: gregex.c:705:10
msgid ""
"Because of the way certain internal optimizations are implemented the "
"partial matching algorithm cannot be used with all patterns. So repeated "
"single characters such as |$_1_$|a{2,4}|$_1_$| and repeated single meta-"
"sequences such as |$_1_$||$_2_$|d+|$_1_$| are not permitted if the maximum "
"number of occurrences is greater than one. Optional items such as |$_1_$||"
"$_2_$|d?|$_1_$| (where the maximum is one) are permitted. Quantifiers with "
"any values are permitted after parentheses, so the invalid examples above "
"can be coded thus |$_1_$|(a){2,4}|$_1_$| and |$_1_$|(|$_2_$|d)+|$_1_$|. If "
"#G_REGEX_MATCH_PARTIAL is set for a pattern that does not conform to the "
"restrictions, matching functions return an error."
msgstr ""

# #used by: SECTION:gregex
#: gregex.c:71:7
msgid ""
"When matching a pattern, |$_1_$||$_2_$|n|$_1_$| matches only against a |$_1_"
"$||$_2_$|n|$_1_$| character in the string, and |$_1_$||$_2_$|r|$_1_$| "
"matches only a |$_1_$||$_2_$|r|$_1_$| character. To match any newline "
"sequence use |$_1_$||$_2_$|R|$_1_$|. This particular group matches either "
"the two-character sequence CR + LF (|$_1_$||$_2_$|r|$_2_$|n|$_1_$|), or one "
"of the single characters LF (linefeed, U+000A, |$_1_$||$_2_$|n|$_1_$|), VT "
"vertical tab, U+000B, |$_1_$||$_2_$|v|$_1_$|), FF (formfeed, U+000C, |$_1_$||"
"$_2_$|f|$_1_$|), CR (carriage return, U+000D, |$_1_$||$_2_$|r|$_1_$|), NEL "
"(next line, U+0085), LS (line separator, U+2028), or PS (paragraph "
"separator, U+2029)."
msgstr ""

# #used by: g_match_info_is_partial_match:
#: gregex.c:716:1
msgid "Returns: %TRUE if the match was partial, %FALSE otherwise"
msgstr ""

# used by: g_match_info_expand_references:
#: gregex.c:730:1
msgid "@match_info: a #GMatchInfo or %NULL"
msgstr ""

# used by: g_match_info_expand_references:
#: gregex.c:731:1
msgid "@string_to_expand: the string to expand"
msgstr ""

# #used by: g_match_info_expand_references:
#: gregex.c:734:4
msgid ""
"Returns a new string containing the text in @string_to_expand with "
"references and escape sequences expanded. References refer to the last match "
"done with @string against @regex and have the same syntax used by "
"g_regex_replace()."
msgstr ""

# #used by: g_match_info_expand_references:
#: gregex.c:739:2
msgid ""
"The @string_to_expand must be UTF-8 encoded even if #G_REGEX_RAW was passed "
"to g_regex_new()."
msgstr ""

# #used by: g_match_info_expand_references:
#: gregex.c:742:2
msgid ""
"The backreferences are extracted from the string passed to the match "
"function, so you cannot call this function after freeing the string."
msgstr ""

# #used by: g_match_info_expand_references:
#: gregex.c:745:6
msgid ""
"@match_info may be %NULL in which case @string_to_expand must not contain "
"references. For instance |$_1_$|foo|$_2_$|n|$_1_$| does not refer to an "
"actual pattern and '|$_2_$|n' merely will be replaced with |$_2_$|n "
"character, while to expand |$_1_$||$_2_$|0|$_1_$| (whole match) one needs "
"the result of a match. Use g_regex_check_replacement() to find out whether "
"@string_to_expand contains references."
msgstr ""

# #used by: g_match_info_expand_references:
#: gregex.c:752:1
msgid ""
"Returns: (allow-none): the expanded string, or %NULL if an error occurred"
msgstr ""

# #used by: SECTION:gregex
#: gregex.c:79:10
msgid ""
"The behaviour of the dot, circumflex, and dollar metacharacters are affected "
"by newline characters, the default is to recognize any newline character "
"(the same characters recognized by |$_1_$||$_2_$|R|$_1_$|). This can be "
"changed with #G_REGEX_NEWLINE_CR, #G_REGEX_NEWLINE_LF and "
"#G_REGEX_NEWLINE_CRLF compile options, and with #G_REGEX_MATCH_NEWLINE_ANY, "
"#G_REGEX_MATCH_NEWLINE_CR, #G_REGEX_MATCH_NEWLINE_LF and "
"#G_REGEX_MATCH_NEWLINE_CRLF match options. These settings are also relevant "
"when compiling a pattern if #G_REGEX_EXTENDED is set, and an unescaped |$_1_"
"$|#|$_1_$| outside a character class is encountered. This indicates a "
"comment that lasts until after the next newline."
msgstr ""

# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# used by: g_match_info_fetch:
# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# used by: g_match_info_fetch_pos:
# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# used by: g_match_info_fetch_named:
# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# used by: g_match_info_fetch_named_pos:
#: gregex.c:794:1 gregex.c:845:1 gregex.c:933:1 gregex.c:970:1
msgid "@match_info: #GMatchInfo structure"
msgstr ""

# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# used by: g_match_info_fetch:
# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# used by: g_match_info_fetch_pos:
#: gregex.c:795:1 gregex.c:846:1
msgid "@match_num: number of the sub expression"
msgstr ""

# #used by: g_match_info_fetch:
#: gregex.c:797:3
msgid ""
"Retrieves the text matching the @match_num<!-- -->'th capturing parentheses. "
"0 is the full text of the match, 1 is the first paren set, 2 the second, and "
"so on."
msgstr ""

# #used by: g_match_info_fetch:
#: gregex.c:801:3
msgid ""
"If @match_num is a valid sub pattern but it didn't match anything (e.g. sub "
"pattern 1, matching |$_1_$|b|$_1_$| against |$_1_$|(a)?b|$_1_$|) then an "
"empty string is returned."
msgstr ""

# #used by: g_match_info_fetch:
#: gregex.c:805:5
msgid ""
"If the match was obtained using the DFA algorithm, that is using "
"g_regex_match_all() or g_regex_match_all_full(), the retrieved string is not "
"that of a set of parentheses but that of a matched substring. Substrings are "
"matched in reverse order of length, so 0 is the longest match."
msgstr ""

# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# #used by: g_match_info_fetch:
# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# #used by: g_match_info_fetch_named:
#: gregex.c:811:2 gregex.c:942:2
msgid ""
"The string is fetched from the string passed to the match function, so you "
"cannot call this function after freeing the string."
msgstr ""

# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# #used by: g_match_info_fetch:
# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# #used by: g_match_info_fetch_named:
#: gregex.c:814:2 gregex.c:945:2
msgid ""
"Returns: (allow-none): The matched substring, or %NULL if an error occurred. "
"You have to free the string yourself"
msgstr ""

# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# used by: g_match_info_fetch_pos:
# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# used by: g_match_info_fetch_named_pos:
#: gregex.c:847:2 gregex.c:972:2
msgid ""
"@start_pos: (out) (allow-none): pointer to location where to store the start "
"position, or %NULL"
msgstr ""

# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# used by: g_match_info_fetch_pos:
# #-#-#-#-#  gregex.pot (PACKAGE VERSION)  #-#-#-#-#
# used by: g_match_info_fetch_named_pos:
#: gregex.c:849:2 gregex.c:974:2
msgid ""
"@end_pos: (out) (allow-none): pointer to location where to store the end "
"position, or %NULL"
msgstr ""

# #used by: g_match_info_fetch_pos:
#: gregex.c:852:3
msgid ""
"Retrieves the position in bytes of the @match_num<!-- -->'th capturing "
"parentheses. 0 is the full text of the match, 1 is the first paren set, 2 "
"the second, and so on."
msgstr ""

# #used by: g_match_info_fetch_pos:
#: gregex.c:856:3
msgid ""
"If @match_num is a valid sub pattern but it didn't match anything (e.g. sub "
"pattern 1, matching |$_1_$|b|$_1_$| against |$_1_$|(a)?b|$_1_$|) then "
"@start_pos and @end_pos are set to -1 and %TRUE is returned."
msgstr ""

# #used by: g_match_info_fetch_pos:
#: gregex.c:860:5
msgid ""
"If the match was obtained using the DFA algorithm, that is using "
"g_regex_match_all() or g_regex_match_all_full(), the retrieved position is "
"not that of a set of parentheses but that of a matched substring. Substrings "
"are matched in reverse order of length, so 0 is the longest match."
msgstr ""

# #used by: g_match_info_fetch_pos:
#: gregex.c:866:3
msgid ""
"Returns: %TRUE if the position was fetched, %FALSE otherwise. If the "
"position cannot be fetched, @start_pos and @end_pos are left unchanged"
msgstr ""

# #used by: SECTION:gregex
#: gregex.c:90:4
msgid ""
"Creating and manipulating the same #GRegex structure from different threads "
"is not a problem as #GRegex does not modify its internal state between "
"creation and destruction, on the other hand #GMatchInfo is not threadsafe."
msgstr ""

# #used by: g_match_info_fetch_named:
#: gregex.c:936:1
msgid "Retrieves the text matching the capturing parentheses named @name."
msgstr ""

# #used by: g_match_info_fetch_named:
#: gregex.c:938:3
msgid ""
"If @name is a valid sub pattern name but it didn't match anything (e.g. sub "
"pattern |$_1_$|X|$_1_$|, matching |$_1_$|b|$_1_$| against |$_1_$|(?P&lt;X&gt;"
"a)?b|$_1_$|) then an empty string is returned."
msgstr ""

# #used by: SECTION:gregex
#: gregex.c:95:3
msgid ""
"The regular expressions low-level functionalities are obtained through the "
"excellent <ulink url=|$_1_$|http://www.pcre.org/|$_1_$|>PCRE</ulink> library "
"written by Philip Hazel."
msgstr ""

# #used by: g_match_info_fetch_named_pos:
#: gregex.c:977:1
msgid ""
"Retrieves the position in bytes of the capturing parentheses named @name."
msgstr ""

# #used by: g_match_info_fetch_named_pos:
#: gregex.c:979:3
msgid ""
"If @name is a valid sub pattern name but it didn't match anything (e.g. sub "
"pattern |$_1_$|X|$_1_$|, matching |$_1_$|b|$_1_$| against |$_1_$|(?P&lt;X&gt;"
"a)?b|$_1_$|) then @start_pos and @end_pos are set to -1 and %TRUE is "
"returned."
msgstr ""

# #used by: g_match_info_fetch_named_pos:
#: gregex.c:983:3
msgid ""
"Returns: %TRUE if the position was fetched, %FALSE otherwise. If the "
"position cannot be fetched, @start_pos and @end_pos are left unchanged."
msgstr ""

# used by: GRegexError:
#: gregex.h:100:2
msgid ""
"@G_REGEX_ERROR_TOO_MANY_SUBPATTERNS: Too many named subpatterns (maximum "
"10,000). Since 2.16"
msgstr ""

# used by: GRegexError:
#: gregex.h:102:2
msgid ""
"@G_REGEX_ERROR_INVALID_OCTAL_VALUE: Octal value is greater than |$_1_$||$_2_"
"$||$_2_$|377|$_1_$|. Since 2.16"
msgstr ""

# used by: GRegexError:
#: gregex.h:104:2
msgid ""
"@G_REGEX_ERROR_TOO_MANY_BRANCHES_IN_DEFINE: |$_1_$|DEFINE|$_1_$| group "
"contains more than one branch. Since 2.16"
msgstr ""

# used by: GRegexError:
#: gregex.h:106:2
msgid ""
"@G_REGEX_ERROR_DEFINE_REPETION: Repeating a |$_1_$|DEFINE|$_1_$| group is "
"not allowed. Since 2.16"
msgstr ""

# used by: GRegexError:
#: gregex.h:108:2
msgid ""
"@G_REGEX_ERROR_INCONSISTENT_NEWLINE_OPTIONS: Inconsistent newline options. "
"Since 2.16"
msgstr ""

# used by: GRegexError:
#: gregex.h:110:2
msgid ""
"@G_REGEX_ERROR_MISSING_BACK_REFERENCE: |$_1_$||$_2_$||$_2_$|g|$_1_$| is not "
"followed by a braced name or an optionally braced non-zero number. Since 2.16"
msgstr ""

# #used by: GRegexError:
#: gregex.h:113:1
msgid "Error codes returned by regular expressions functions."
msgstr ""

# #used by: G_REGEX_ERROR:
#: gregex.h:168:3
msgid ""
"Error domain for regular expressions. Errors in this domain will be from the "
"#GRegexError enumeration. See #GError for information on error domains."
msgstr ""

# used by: GRegexCompileFlags:
#: gregex.h:180:3
msgid ""
"@G_REGEX_CASELESS: Letters in the pattern match both upper- and lowercase "
"letters. This option can be changed within a pattern by a |$_1_$|(?i)|$_1_$| "
"option setting."
msgstr ""

# used by: GRegexCompileFlags:
#: gregex.h:183:11
msgid ""
"@G_REGEX_MULTILINE: By default, GRegex treats the strings as consisting of a "
"single line of characters (even if it actually contains newlines). The |$_1_"
"$|start of line|$_1_$| metacharacter (|$_1_$|^|$_1_$|) matches only at the "
"start of the string, while the |$_1_$|end of line|$_1_$| metacharacter (|$_1_"
"$|$|$_1_$|) matches only at the end of the string, or before a terminating "
"newline (unless #G_REGEX_DOLLAR_ENDONLY is set). When #G_REGEX_MULTILINE is "
"set, the |$_1_$|start of line|$_1_$| and |$_1_$|end of line|$_1_$| "
"constructs match immediately following or immediately before any newline in "
"the string, respectively, as well as at the very start and end. This can be "
"changed within a pattern by a |$_1_$|(?m)|$_1_$| option setting."
msgstr ""

# used by: GRegexCompileFlags:
#: gregex.h:194:3
msgid ""
"@G_REGEX_DOTALL: A dot metacharater (|$_1_$|.|$_1_$|) in the pattern matches "
"all characters, including newlines. Without it, newlines are excluded. This "
"option can be changed within a pattern by a (|$_1_$|?s|$_1_$|) option "
"setting."
msgstr ""

# used by: GRegexCompileFlags:
#: gregex.h:197:6
msgid ""
"@G_REGEX_EXTENDED: Whitespace data characters in the pattern are totally "
"ignored except when escaped or inside a character class. Whitespace does not "
"include the VT character (code 11). In addition, characters between an "
"unescaped |$_1_$|#|$_1_$| outside a character class and the next newline "
"character, inclusive, are also ignored. This can be changed within a pattern "
"by a |$_1_$|(?x)|$_1_$| option setting."
msgstr ""

# used by: GRegexCompileFlags:
#: gregex.h:203:5
msgid ""
"@G_REGEX_ANCHORED: The pattern is forced to be |$_1_$|anchored|$_1_$|, that "
"is, it is constrained to match only at the first matching point in the "
"string that is being searched. This effect can also be achieved by "
"appropriate constructs in the pattern itself such as the |$_1_$|^|$_1_$| "
"metacharater."
msgstr ""

# used by: GRegexCompileFlags:
#: gregex.h:208:5
msgid ""
"@G_REGEX_DOLLAR_ENDONLY: A dollar metacharacter (|$_1_$|$|$_1_$|) in the "
"pattern matches only at the end of the string. Without this option, a dollar "
"also matches immediately before the final character if it is a newline (but "
"not before any other newlines). This option is ignored if #G_REGEX_MULTILINE "
"is set."
msgstr ""

# used by: GRegexCompileFlags:
#: gregex.h:213:3
msgid ""
"@G_REGEX_UNGREEDY: Inverts the |$_1_$|greediness|$_1_$| of the quantifiers "
"so that they are not greedy by default, but become greedy if followed by |"
"$_1_$|?|$_1_$|. It can also be set by a |$_1_$|(?U)|$_1_$| option setting "
"within the pattern."
msgstr ""

# used by: GRegexCompileFlags:
#: gregex.h:216:7
msgid ""
"@G_REGEX_RAW: Usually strings must be valid UTF-8 strings, using this flag "
"they are considered as a raw sequence of bytes. @G_REGEX_NO_AUTO_CAPTURE: "
"Disables the use of numbered capturing parentheses in the pattern. Any "
"opening parenthesis that is not followed by |$_1_$|?|$_1_$| behaves as if it "
"were followed by |$_1_$|?:|$_1_$| but named parentheses can still be used "
"for capturing (and they acquire numbers in the usual way)."
msgstr ""

# used by: GRegexCompileFlags:
#: gregex.h:223:3
msgid ""
"@G_REGEX_OPTIMIZE: Optimize the regular expression. If the pattern will be "
"used many times, then it may be worth the effort to optimize it to improve "
"the speed of matches."
msgstr ""

# used by: GRegexCompileFlags:
#: gregex.h:226:4
msgid ""
"@G_REGEX_DUPNAMES: Names used to identify capturing subpatterns need not be "
"unique. This can be helpful for certain types of pattern when it is known "
"that only one instance of the named subpattern can ever be matched."
msgstr ""

# used by: GRegexCompileFlags:
#: gregex.h:230:2
msgid ""
"@G_REGEX_NEWLINE_CR: Usually any newline character is recognized, if this "
"option is set, the only recognized newline character is '|$_2_$|r'."
msgstr ""

# used by: GRegexCompileFlags:
#: gregex.h:232:2
msgid ""
"@G_REGEX_NEWLINE_LF: Usually any newline character is recognized, if this "
"option is set, the only recognized newline character is '|$_2_$|n'."
msgstr ""

# used by: GRegexCompileFlags:
#: gregex.h:234:2
msgid ""
"@G_REGEX_NEWLINE_CRLF: Usually any newline character is recognized, if this "
"option is set, the only recognized newline character sequence is '|$_2_$|r|"
"$_2_$|n'."
msgstr ""

# #used by: GRegexCompileFlags:
#: gregex.h:237:1
msgid "Flags specifying compile-time options."
msgstr ""

# used by: GRegexMatchFlags:
#: gregex.h:263:5
msgid ""
"@G_REGEX_MATCH_ANCHORED: The pattern is forced to be |$_1_$|anchored|$_1_$|, "
"that is, it is constrained to match only at the first matching point in the "
"string that is being searched. This effect can also be achieved by "
"appropriate constructs in the pattern itself such as the |$_1_$|^|$_1_$| "
"metacharater."
msgstr ""

# used by: GRegexMatchFlags:
#: gregex.h:268:6
msgid ""
"@G_REGEX_MATCH_NOTBOL: Specifies that first character of the string is not "
"the beginning of a line, so the circumflex metacharacter should not match "
"before it. Setting this without #G_REGEX_MULTILINE (at compile time) causes "
"circumflex never to match. This option affects only the behaviour of the "
"circumflex metacharacter, it does not affect |$_1_$||$_2_$|A|$_1_$|."
msgstr ""

# used by: GRegexMatchFlags:
#: gregex.h:274:6
msgid ""
"@G_REGEX_MATCH_NOTEOL: Specifies that the end of the subject string is not "
"the end of a line, so the dollar metacharacter should not match it nor "
"(except in multiline mode) a newline immediately before it. Setting this "
"without #G_REGEX_MULTILINE (at compile time) causes dollar never to match. "
"This option affects only the behaviour of the dollar metacharacter, it does "
"not affect |$_1_$||$_2_$|Z|$_1_$| or |$_1_$||$_2_$|z|$_1_$|."
msgstr ""

# used by: GRegexMatchFlags:
#: gregex.h:280:8
msgid ""
"@G_REGEX_MATCH_NOTEMPTY: An empty string is not considered to be a valid "
"match if this option is set. If there are alternatives in the pattern, they "
"are tried. If all the alternatives match the empty string, the entire match "
"fails. For example, if the pattern |$_1_$|a?b?|$_1_$| is applied to a string "
"not beginning with |$_1_$|a|$_1_$| or |$_1_$|b|$_1_$|, it matches the empty "
"string at the start of the string. With this flag set, this match is not "
"valid, so GRegex searches further into the string for occurrences of |$_1_$|"
"a|$_1_$| or |$_1_$|b|$_1_$|."
msgstr ""

# used by: GRegexMatchFlags:
#: gregex.h:288:2
msgid ""
"@G_REGEX_MATCH_PARTIAL: Turns on the partial matching feature, for more "
"documentation on partial matching see g_match_info_is_partial_match()."
msgstr ""

# used by: GRegexMatchFlags:
#: gregex.h:290:2
msgid ""
"@G_REGEX_MATCH_NEWLINE_CR: Overrides the newline definition set when "
"creating a new #GRegex, setting the '|$_2_$|r' character as line terminator."
msgstr ""

# used by: GRegexMatchFlags:
#: gregex.h:292:2
msgid ""
"@G_REGEX_MATCH_NEWLINE_LF: Overrides the newline definition set when "
"creating a new #GRegex, setting the '|$_2_$|n' character as line terminator."
msgstr ""

# used by: GRegexMatchFlags:
#: gregex.h:294:2
msgid ""
"@G_REGEX_MATCH_NEWLINE_CRLF: Overrides the newline definition set when "
"creating a new #GRegex, setting the '|$_2_$|r|$_2_$|n' characters as line "
"terminator."
msgstr ""

# used by: GRegexMatchFlags:
#: gregex.h:296:3
msgid ""
"@G_REGEX_MATCH_NEWLINE_ANY: Overrides the newline definition set when "
"creating a new #GRegex, any newline character or character sequence is "
"recognized."
msgstr ""

# #used by: GRegexMatchFlags:
#: gregex.h:300:1
msgid "Flags specifying match-time options."
msgstr ""

# #used by: GRegex:
#: gregex.h:322:2
msgid ""
"A GRegex is the |$_1_$|compiled|$_1_$| form of a regular expression pattern. "
"This structure is opaque and its fields cannot be accessed directly."
msgstr ""

# used by: GRegexEvalCallback:
#: gregex.h:334:3
msgid ""
"@match_info: the #GMatchInfo generated by the match. Use "
"g_match_info_get_regex() and g_match_info_get_string() if you need the "
"#GRegex or the matched string."
msgstr ""

# used by: GRegexEvalCallback:
#: gregex.h:337:1
msgid "@result: a #GString containing the new string"
msgstr ""

# used by: GRegexEvalCallback:
#: gregex.h:338:1
msgid "@user_data: user data passed to g_regex_replace_eval()"
msgstr ""

# #used by: GRegexEvalCallback:
#: gregex.h:340:4
msgid ""
"Specifies the type of the function passed to g_regex_replace_eval(). It is "
"called for each occurance of the pattern in the string passed to "
"g_regex_replace_eval(), and it should append the replacement to @result."
msgstr ""

# #used by: GRegexEvalCallback:
#: gregex.h:345:1
msgid "Returns: %FALSE to continue the replacement process, %TRUE to stop it"
msgstr ""

# used by: GRegexError:
#: gregex.h:36:1
msgid "@G_REGEX_ERROR_COMPILE: Compilation of the regular expression failed."
msgstr ""

# used by: GRegexError:
#: gregex.h:37:1
msgid "@G_REGEX_ERROR_OPTIMIZE: Optimization of the regular expression failed."
msgstr ""

# used by: GRegexError:
#: gregex.h:38:2
msgid ""
"@G_REGEX_ERROR_REPLACE: Replacement failed due to an ill-formed replacement "
"string."
msgstr ""

# used by: GRegexError:
#: gregex.h:40:1
msgid "@G_REGEX_ERROR_MATCH: The match process failed."
msgstr ""

# used by: GRegexError:
#: gregex.h:41:2
msgid ""
"@G_REGEX_ERROR_INTERNAL: Internal error of the regular expression engine. "
"Since 2.16"
msgstr ""

# used by: GRegexError:
#: gregex.h:43:1
msgid ""
"@G_REGEX_ERROR_STRAY_BACKSLASH: |$_1_$||$_2_$||$_2_$||$_1_$| at end of "
"pattern. Since 2.16"
msgstr ""

# used by: GRegexError:
#: gregex.h:44:1
msgid ""
"@G_REGEX_ERROR_MISSING_CONTROL_CHAR: |$_1_$||$_2_$||$_2_$|c|$_1_$| at end of "
"pattern. Since 2.16"
msgstr ""

# used by: GRegexError:
#: gregex.h:45:2
msgid ""
"@G_REGEX_ERROR_UNRECOGNIZED_ESCAPE: Unrecognized character follows |$_1_$||"
"$_2_$||$_2_$||$_1_$|. Since 2.16"
msgstr ""

# used by: GRegexError:
#: gregex.h:47:2
msgid ""
"@G_REGEX_ERROR_QUANTIFIERS_OUT_OF_ORDER: Numbers out of order in |$_1_$|{}|"
"$_1_$| quantifier. Since 2.16"
msgstr ""

# used by: GRegexError:
#: gregex.h:49:2
msgid ""
"@G_REGEX_ERROR_QUANTIFIER_TOO_BIG: Number too big in |$_1_$|{}|$_1_$| "
"quantifier. Since 2.16"
msgstr ""

# used by: GRegexError:
#: gregex.h:51:2
msgid ""
"@G_REGEX_ERROR_UNTERMINATED_CHARACTER_CLASS: Missing terminating |$_1_$|]|"
"$_1_$| for character class. Since 2.16"
msgstr ""

# used by: GRegexError:
#: gregex.h:53:2
msgid ""
"@G_REGEX_ERROR_INVALID_ESCAPE_IN_CHARACTER_CLASS: Invalid escape sequence in "
"character class. Since 2.16"
msgstr ""

# used by: GRegexError:
#: gregex.h:55:2
msgid ""
"@G_REGEX_ERROR_RANGE_OUT_OF_ORDER: Range out of order in character class. "
"Since 2.16"
msgstr ""

# used by: GRegexError:
#: gregex.h:57:1
msgid "@G_REGEX_ERROR_NOTHING_TO_REPEAT: Nothing to repeat. Since 2.16"
msgstr ""

# used by: GRegexError:
#: gregex.h:58:2
msgid ""
"@G_REGEX_ERROR_UNRECOGNIZED_CHARACTER: Unrecognized character after |$_1_$|"
"(?|$_1_$|, |$_1_$|(?&lt;|$_1_$| or |$_1_$|(?P|$_1_$|. Since 2.16"
msgstr ""

# used by: GRegexError:
#: gregex.h:60:2
msgid ""
"@G_REGEX_ERROR_POSIX_NAMED_CLASS_OUTSIDE_CLASS: POSIX named classes are "
"supported only within a class. Since 2.16"
msgstr ""

# used by: GRegexError:
#: gregex.h:62:2
msgid ""
"@G_REGEX_ERROR_UNMATCHED_PARENTHESIS: Missing terminating |$_1_$|)|$_1_$| or "
"|$_1_$|)|$_1_$| without opening |$_1_$|(|$_1_$|. Since 2.16"
msgstr ""

# used by: GRegexError:
#: gregex.h:64:2
msgid ""
"@G_REGEX_ERROR_INEXISTENT_SUBPATTERN_REFERENCE: Reference to non-existent "
"subpattern. Since 2.16"
msgstr ""

# used by: GRegexError:
#: gregex.h:66:2
msgid ""
"@G_REGEX_ERROR_UNTERMINATED_COMMENT: Missing terminating |$_1_$|)|$_1_$| "
"after comment. Since 2.16"
msgstr ""

# used by: GRegexError:
#: gregex.h:68:2
msgid ""
"@G_REGEX_ERROR_EXPRESSION_TOO_LARGE: Regular expression too large. Since 2.16"
msgstr ""

# used by: GRegexError:
#: gregex.h:70:1
msgid "@G_REGEX_ERROR_MEMORY_ERROR: Failed to get memory. Since 2.16"
msgstr ""

# used by: GRegexError:
#: gregex.h:71:2
msgid ""
"@G_REGEX_ERROR_VARIABLE_LENGTH_LOOKBEHIND: Lookbehind assertion is not fixed "
"length. Since 2.16"
msgstr ""

# used by: GRegexError:
#: gregex.h:73:2
msgid ""
"@G_REGEX_ERROR_MALFORMED_CONDITION: Malformed number or name after |$_1_$|(?"
"(|$_1_$|. Since 2.16"
msgstr ""

# used by: GRegexError:
#: gregex.h:75:2
msgid ""
"@G_REGEX_ERROR_TOO_MANY_CONDITIONAL_BRANCHES: Conditional group contains "
"more than two branches. Since 2.16"
msgstr ""

# used by: GRegexError:
#: gregex.h:77:2
msgid ""
"@G_REGEX_ERROR_ASSERTION_EXPECTED: Assertion expected after |$_1_$|(?(|$_1_"
"$|. Since 2.16"
msgstr ""

# used by: GRegexError:
#: gregex.h:79:2
msgid ""
"@G_REGEX_ERROR_UNKNOWN_POSIX_CLASS_NAME: Unknown POSIX class name. Since 2.16"
msgstr ""

# used by: GRegexError:
#: gregex.h:81:2
msgid ""
"@G_REGEX_ERROR_POSIX_COLLATING_ELEMENTS_NOT_SUPPORTED: POSIX collating "
"elements are not supported. Since 2.16"
msgstr ""

# used by: GRegexError:
#: gregex.h:83:2
msgid ""
"@G_REGEX_ERROR_HEX_CODE_TOO_LARGE: Character value in |$_1_$||$_2_$||$_2_$|x"
"{...}|$_1_$| sequence is too large. Since 2.16"
msgstr ""

# used by: GRegexError:
#: gregex.h:85:1
msgid ""
"@G_REGEX_ERROR_INVALID_CONDITION: Invalid condition |$_1_$|(?(0)|$_1_$|. "
"Since 2.16"
msgstr ""

# used by: GRegexError:
#: gregex.h:86:2
msgid ""
"@G_REGEX_ERROR_SINGLE_BYTE_MATCH_IN_LOOKBEHIND: |$_2_$||$_2_$|C not allowed "
"in lookbehind assertion. Since 2.16"
msgstr ""

# used by: GRegexError:
#: gregex.h:88:2
msgid ""
"@G_REGEX_ERROR_INFINITE_LOOP: Recursive call could loop indefinitely. Since "
"2.16"
msgstr ""

# used by: GRegexError:
#: gregex.h:90:2
msgid ""
"@G_REGEX_ERROR_MISSING_SUBPATTERN_NAME_TERMINATOR: Missing terminator in "
"subpattern name. Since 2.16"
msgstr ""

# used by: GRegexError:
#: gregex.h:92:2
msgid ""
"@G_REGEX_ERROR_DUPLICATE_SUBPATTERN_NAME: Two named subpatterns have the "
"same name. Since 2.16"
msgstr ""

# used by: GRegexError:
#: gregex.h:94:2
msgid ""
"@G_REGEX_ERROR_MALFORMED_PROPERTY: Malformed |$_1_$||$_2_$||$_2_$|P|$_1_$| "
"or |$_1_$||$_2_$||$_2_$|p|$_1_$| sequence. Since 2.16"
msgstr ""

# used by: GRegexError:
#: gregex.h:96:2
msgid ""
"@G_REGEX_ERROR_UNKNOWN_PROPERTY: Unknown property name after |$_1_$||$_2_$||"
"$_2_$|P|$_1_$| or |$_1_$||$_2_$||$_2_$|p|$_1_$|. Since 2.16"
msgstr ""

# used by: GRegexError:
#: gregex.h:98:2
msgid ""
"@G_REGEX_ERROR_SUBPATTERN_NAME_TOO_LONG: Subpattern name is too long "
"(maximum 32 characters). Since 2.16"
msgstr ""
