<!-- ##### SECTION Title ##### -->
特殊宏

<!-- ##### SECTION Short_Description ##### -->
不常使用的专用宏

<!-- ##### SECTION Long_Description ##### -->
<para>
这些宏提供了额外特殊的功能，它们通常不被应用程序员使用
</para>

<!-- ##### SECTION See_Also ##### -->
<para>

</para>

<!-- ##### SECTION Stability_Level ##### -->


<!-- ##### MACRO G_INLINE_FUNC ##### -->
<para>
这个宏用于导出函数原型，这样当非内联模式时，它们就能被链接
到一个非内联的扩展版本。执行函数的这个文件要在定义%G_IMPLEMENTS_INLINTS
之前包含有%G_INLINE_FUNC声明的头文件。由于内联是非常依赖
编译器的，所以正确的使用这些宏非常难。强烈建议不要使用这
些宏。
</para>
<para>
此宏经常被误认为是inline关键字的替换；内联已经以一种可移
植的方式在glib头文件里声明，并且它能够被正常的使用。
</para>



<!-- ##### MACRO G_STMT_START ##### -->
<para>
在多语句宏内使用，以便它们能使用在编译器期望只有一条语句
的地方。
</para>



<!-- ##### MACRO G_STMT_END ##### -->
<para>
在多语句宏内使用，以便它们能使用在编译器期望只有一条语句
的地方。
</para>



<!-- ##### MACRO G_BEGIN_DECLS ##### -->
<para>
用于把头文件放在括号{}里（和#G_END_DECLS一起使用）。如果
使用的编译器是一个C++编译器，就在头文件外添加<literal>
extern "C"</literal>。
</para>



<!-- ##### MACRO G_END_DECLS ##### -->
<para>
用于把头文件放在括号{}里（和#G_END_DECLS一起使用）。如果
使用的编译器是一个C++编译器，就在头文件外添加<literal>
extern "C"</literal>。
</para>



<!-- ##### MACRO G_N_ELEMENTS ##### -->
<para>
确定数组中元素的个数。这个数组必须被声明以便编译器在编译
时知道它的大小；这个宏不能工作在堆上分配的数组上，只能应
用在静态数组或者在栈上的数组。
</para>

@arr: 数组名


<!-- ##### MACRO G_VA_COPY ##### -->
<para>
以可移植的方式复制 <type>va_list</type> 变量。 
</para>
<para>
为了使用这个功能，你必须包含<filename>string.h</filename> 
，因为这个宏可能使用 <function>memmove()</function>，而
GLib并没有包含<function>string.h</function> 。
</para>

@ap1: 这个 <type>va_list</type> 变量用于存放ap2的一个副本。
@ap2: 一个 <type>va_list</type> 变量。


<!-- ##### MACRO G_STRINGIFY ##### -->
<para>
接受一个宏或一个字符串转换成一个字符串后，并预处理参数扩展。
</para>

@macro_or_string: 一个宏或者一个字符串。


<!-- ##### MACRO G_PASTE ##### -->
<para>
生成一个新的预处理粘贴标识符'identifier1identifier2'
从它的形参 'identifier1' 和 'identifier2'。
</para>

@identifier1: 一个标识符
@identifier2: 一个标识符
@Since: 2.20


<!-- ##### MACRO G_PASTE_ARGS ##### -->
<para>

</para>

@identifier1: 
@identifier2: 


<!-- ##### MACRO G_STATIC_ASSERT ##### -->
<para>
G_STATIC_ASSERT 宏让程序员可以在代码编译时进行条件检查，该
条件必须在程序编译时是可计算的。
这个宏可以使用在任何使用 <literal>typedef</literal>的地方。
这个宏只能在每个源代码行使用一次。
</para>

@expr: 一个常量表达式。
@Since: 2.20


<!-- ##### MACRO G_GNUC_EXTENSION ##### -->
<para>
当使用 <command>gcc</command> 作为编译器时展开为
<literal>__extension__</literal>。 
这简单的告诉 <command>gcc</command> 当使用 <option>-pedantic</option>
参数进行编译时，对于以下的非标准代码不用做出警告。
</para>



<!-- ##### MACRO G_GNUC_CONST ##### -->
<para>
如果使用的是 <command>gcc</command> 编译器，就展开为
GNU C <literal>const</literal> 函数属性。将一个函数声明为const，
可以更好地对函数调用进行优化。 一个const函数不检查其参数
外的任何值，并且只影响到它的返回值。详见GNU C 文档。
</para>
<note><para>
一个函数的指针参数和此指针所指向的数据<emphasis>不能</emphasis>
被声明为const。同样的，一个调用非const函数的函数通常不能为const。
为一个const函数返回void是没意义的。
</para></note>



<!-- ##### MACRO G_GNUC_PURE ##### -->
<para>
如果使用的是 <command>gcc</command> 编译器，就展开为
GNU C <literal>pure</literal> 函数属性。将一个函数声明为pure，
可以更好地对函数调用进行优化。一个pure函数只影响它的返回值，
并且这个返回值只依赖于参数和/或全局变量。
详见GNU C 文档。
</para>



<!-- ##### MACRO G_GNUC_MALLOC ##### -->
<para>
如果使用的是 <command>gcc</command> 编译器，就展开为
GNU C <literal>malloc</literal> 函数属性。将一个函数声明为malloc，
可以更好地对函数调用进行优化。一个函数可以拥有malloc属性，
如果能确保在函数返回时，它返回的指针不是其他任意指针的别名的话
（实际上，这意味著分配新的内存）。
详见GNU C 文档。
</para>

@Since: 2.6


<!-- ##### MACRO G_GNUC_ALLOC_SIZE ##### -->
<para>
如果使用的是比较新版的 <command>gcc</command> 编译器，就展开为
GNU C <literal>alloc_size</literal> 函数属性。这个属性告诉编译器
此函数返回一个指针，该指针指向由函数参数@x<!-- -->th指定大小的
内存空间。
详见GNU C 文档。
</para>

@x: 分配指定大小内存的参数指数。
@Since: 2.18


<!-- ##### MACRO G_GNUC_ALLOC_SIZE2 ##### -->
<para>
如果使用的是比较新版的 <command>gcc</command> 编译器，就展开为
GNU C <literal>alloc_size</literal> 函数属性。 这个属性告诉编译器
此函数返回一个指针，该指针指向由该函数的两个参数的乘积指定大小的
内存空间。
详见GNU C 文档。
</para>

@x: 分配指定大小内存的第一个参数指数。
@y: 分配指定大小内存的第二个参数指数。
@Since: 2.18


<!-- ##### MACRO G_GNUC_DEPRECATED ##### -->
<para>
如果使用的是 <command>gcc</command> 编译器，就展开为
GNU C <literal>deprecated</literal> 属性。
它可以用来标记某些类型定义，变量和函数是不鼓励使用的。
如果你使用了这些不鼓励使用的程序接口，当编译器使用
<option>-Wdeprecated-declarations</option>选项编译时将
产生警告信息。
详见GNU C 文档。
</para>

@Since: 2.2


<!-- ##### MACRO G_GNUC_NORETURN ##### -->
<para>
如果使用的是 <command>gcc</command> 编译器，就展开为
GNU C <literal>noreturn</literal> 函数属性。它用来声明
该函数没有返回值。它能够使函数得到优化，同时避免了可能
出现的编译警告。
详见GNU C 文档。
</para>



<!-- ##### MACRO G_GNUC_UNUSED ##### -->
<para>
如果使用的是 <command>gcc</command> 编译器，就展开为
GNU C <literal>unused</literal> 函数属性。它用来声明
该函数可能不会被使用。它避免了可能出现的编译警告。
详见GNU C 文档。
</para>



<!-- ##### MACRO G_GNUC_PRINTF ##### -->
<para>
如果使用的是 <command>gcc</command> 编译器，就展开为
GNU C <literal>format</literal> 函数属性。它用来声明
使用了可变数目参数的函数，就像<function>printf()</function>
的语法一样。它允许编译器对传递给函数的参数进行类型检查。
详见GNU C 文档。
</para>
<informalexample><programlisting>
gint g_snprintf (gchar  *string,
                 gulong       n,
                 gchar const *format,
                 ...) G_GNUC_PRINTF (3, 4);
</programlisting></informalexample>

@format_idx: 对应格式字符串参数的索引。
（这个参数的取值从1开始）。
@arg_idx: 第一个格式化参数的索引。


<!-- ##### MACRO G_GNUC_SCANF ##### -->
<para>
如果使用的是 <command>gcc</command> 编译器，就展开为
GNU C <literal>format</literal> 函数属性。它用来声明
使用了可变数目参数的函数，就像<function>scanf()</function>
的语法一样。它允许编译器对传递给函数的参数进行类型检查。
详见GNU C 文档。
</para>

@format_idx: 对应格式字符串参数的索引。
（这个参数的取值从1开始）。
@arg_idx: 第一个格式化参数的索引。


<!-- ##### MACRO G_GNUC_FORMAT ##### -->
<para>
如果使用的是 <command>gcc</command> 编译器，就展开为
GNU C <literal>format_arg</literal> 函数属性。
这个函数属性为<function>printf()</function>， 
<function>scanf()</function>，<function>strftime()</function>
或者 <function>strfmon()</function> 等类型的函数指定了
函数的格式化字符串，并且修改它，以便结果能传递给
<function>printf()</function>， <function>scanf()</function>， 
<function>strftime()</function> 或者 <function>strfmon()</function>
等类型的函数（其他的参数则和它们未修改时一样，保持不变）。
详见GNU C 文档。
</para>
<informalexample><programlisting>
gchar *g_dgettext (gchar *domain_name, gchar *msgid) G_GNUC_FORMAT (2);
</programlisting></informalexample>

@arg_idx: 参数索引。


<!-- ##### MACRO G_GNUC_NULL_TERMINATED ##### -->
<para>
如果使用的是 <command>gcc</command> 编译器，就展开为
GNU C <literal>sentinel</literal> 函数属性，或者 ""
如果不是如此的话。这个函数属性仅适用于可变参函数并且
指示编译器检查以一个明确的%NULL结束的参数列表。
详见GNU C 文档。
</para>

Since: 2.8



<!-- ##### MACRO G_GNUC_WARN_UNUSED_RESULT ##### -->
<para>
如果使用的是 <command>gcc</command> 编译器，就展开为
GNU C <literal>warn_unused_result</literal> 函数属性，
或者 "" 如果不是如此的话。如果一个函数的调用结果被忽
略的话，这个函数属性将使编译器发出一个警告。
详见GNU C 文档。
</para>

@Since: 2.10


<!-- ##### MACRO G_GNUC_FUNCTION ##### -->
<para>
在所有的现代编译器上展开为 "" ，并且在<command>gcc</command> 2.x 版本上
展开为<literal>__FUNCTION__</literal> 。
不要使用它。
</para>

@Deprecated: 2.16


<!-- ##### MACRO G_GNUC_PRETTY_FUNCTION ##### -->
<para>
在所有的现代编译器上展开为 "" ，并且在<command>gcc</command> 2.x 版本上
展开为<literal>__PRETTY_FUNCTION__</literal> 。
不要使用它。
</para>

@Deprecated: 2.16


<!-- ##### MACRO G_GNUC_NO_INSTRUMENT ##### -->
<para>
如果使用的是 <command>gcc</command> 编译器，就展开为
GNU C <literal>no_instrument_function</literal> 函数属性。
当编译器使用<option>-finstrument-functions</option>选项
时，拥有这个属性的函数将不会被instrumented for profiling
（译者：instrumented for profiling 为性能跟踪的工具、方法、
程序等）。
详见GNU C 文档。
</para>



<!-- ##### MACRO G_HAVE_GNUC_VISIBILITY ##### -->
<para>

</para>



<!-- ##### MACRO G_GNUC_INTERNAL ##### -->
<para>
这个属性能用来标记仅用于内部的库函数，它可以让编译器更加
高效的调用句柄函数。
请注意，静态函数不能使用这种方式来标记为内部函数。
详见GNU C 文档。
</para>
<para>
当使用的编译器支持GNU C 隐藏可见性属性时，这个宏被展开为
<literal>__attribute__((visibility("hidden")))</literal>。
当使用 Sun Studio 编译器时，该宏被展开为<literal>__hidden</literal>。
</para>
<para>
请注意，为了具备可移植性，这个属性应该放在函数声明的前面。
虽然 GCC 允许这个宏放在函数声明的后面，但是Sun Studio 不允许。
</para>
<informalexample><programlisting>
G_GNUC_INTERNAL
void _g_log_fallback_handler (const gchar    *log_domain,
                              GLogLevelFlags  log_level,
                              const gchar    *message,
                              gpointer        unused_data);
</programlisting></informalexample>

Since: 2.6



<!-- ##### MACRO G_GNUC_MAY_ALIAS ##### -->
<para>
如果使用的是 <command>gcc</command> 编译器，就展开为
GNU C <literal>may_alias</literal> 函数属性。
拥有这个属性的数据类型将不会被进行基于类型别名的分析，
但将被假设为其他任意类型的别名，就像 char 类型。
详见GNU C 文档。
</para>

Since: 2.14



<!-- ##### FUNCTION G_LIKELY ##### -->
<para>
这个宏指示编译器，表达式可能为一个真值。编译器可能针对
这个信息进行编译优化。
</para>
<informalexample><programlisting>
if (G_LIKELY (random () != 1))
  g_print ("not one");
</programlisting></informalexample>

@Returns: @expr 的值 
@Since: 2.2
<!-- # Unused Parameters # -->
@expr: 表达式


<!-- ##### MACRO G_UNLIKELY ##### -->
<para>
这个宏指示编译器，表达式可能不是一个真值。编译器可能针对
这个信息进行编译优化。
</para>
<informalexample><programlisting>
if (G_UNLIKELY (random () == 1))
  g_print ("a random one");
</programlisting></informalexample>

@expr: 表达式
@Returns: @expr 的值
@Since: 2.2


<!-- ##### MACRO G_STRLOC ##### -->
<para>
展开为一个用于确定当前代码位置的字符串。
</para>



<!-- ##### MACRO G_STRFUNC ##### -->
<para>
展开为一个用于确定当前函数位置的字符串。 
</para>

@Since: 2.4


<!-- ##### MACRO G_GINT16_MODIFIER ##### -->
<para>
平台依赖长度修改量的转换符，用于读入和打印 #gint16 或者
#guint16 类型的值。这是一个串字面值，但不包括百分比符号，
这样的话你就可以在百分比符号和转换符之间添加精度和长度修改量，
并且追加一个转换符。
</para>

<para>
下例打印为 "0x7b";
<informalexample>
<programlisting>
gint16 value = 123;
g_print ("%#" G_GINT16_MODIFIER "x", value);
</programlisting>
</informalexample>
</para>

@Since: 2.4


<!-- ##### MACRO G_GINT16_FORMAT ##### -->
<para>
这是一个平台依赖转换符，用于读入和打印 #gint16 类型的值。
这是一个串字面值，但不包括百分比符号，这样的话你就可以在
百分比符号和转换符之间添加精度和长度修改量。
</para>

<para>
<informalexample>
<programlisting>
gint16 in;
gint32 out;
sscanf ("42", "%" G_GINT16_FORMAT, &amp;in)
out = in * 1000;
g_print ("%" G_GINT32_FORMAT, out);
</programlisting>
</informalexample>
</para>



<!-- ##### MACRO G_GUINT16_FORMAT ##### -->
<para>
这是一个平台依赖转换符，用于读入和打印 #guint16 类型的值。
见 #G_GINT16_FORMAT 。
</para>



<!-- ##### MACRO G_GINT32_MODIFIER ##### -->
<para>
平台依赖长度修改量的转换符，用于读入和打印 #gint32 或者
#guint32 类型的值。 
这是一个串字面值，见 #G_GINT16_MODIFIER。
</para>

@Since: 2.4


<!-- ##### MACRO G_GINT32_FORMAT ##### -->
<para>
这是一个平台依赖转换符，用于读入和打印 #gint32 类型的值。
见 #G_GINT16_FORMAT 。
</para>



<!-- ##### MACRO G_GUINT32_FORMAT ##### -->
<para>
这是一个平台依赖转换符，用于读入和打印 #guint32 类型的值。
见 #G_GINT16_FORMAT 。
</para>



<!-- ##### MACRO G_GINT64_MODIFIER ##### -->
<para>
平台依赖长度修改量的转换符，用于读入和打印 #gint64 或者
#guint64 类型的值。这是一个串字面。
</para>

<note>
<para>
一些平台不支持打印64位整数，尽管支持这个数据类型。
在这样的平台 #G_GINT64_MODIFIER 是未定义的。
</para>
</note>

@Since: 2.4


<!-- ##### MACRO G_GINT64_FORMAT ##### -->
<para>
这是一个平台依赖转换符，用于读入和打印 #gint64 类型的值。
见 #G_GINT16_FORMAT 。
</para>

<note>
<para>
一些平台不支持读入和打印64位整数，尽管支持这个数据类型。
在这样的平台 #G_GINT64_FORMAT 是未定义的。 
请注意，scanf() 可能不支持64位整数，尽管定义了 #G_GINT64_FORMAT。
因为它薄弱的错误处理，无论如何 scanf() 是不推荐解析的；
请考虑使用 g_strtoull() 代替它。
</para>
</note>



<!-- ##### MACRO G_GUINT64_FORMAT ##### -->
<para>
这是一个平台依赖转换符，用于读入和打印 #guint64 类型的值。
见 #G_GINT16_FORMAT 。
</para>

<note>
<para>
一些平台不支持读入和打印64位整数，尽管支持这个数据类型。
在这样的平台 #G_GUINT64_FORMAT 是未定义的。 
请注意，scanf() 可能不支持64位整数，尽管定义了 #G_GINT64_FORMAT。
因为它薄弱的错误处理，无论如何 scanf() 是不推荐解析的；
请考虑使用 g_strtoull() 代替它。
</para>
</note>



<!-- ##### MACRO G_GSIZE_MODIFIER ##### -->
<para>
平台依赖长度修改量的转换符，用于读入和打印 #gsize 或者
#gssize 类型的值。这是一个串字面。
</para>

@Since: 2.6


<!-- ##### MACRO G_GSIZE_FORMAT ##### -->
<para>
这是一个平台依赖转换符，用于读入和打印 #gsize 类型的值。
见 #G_GINT16_FORMAT 。
</para>

@Since: 2.6


<!-- ##### MACRO G_GSSIZE_FORMAT ##### -->
<para>
这是一个平台依赖转换符，用于读入和打印 #gssize 类型的值。
见 #G_GINT16_FORMAT 。
</para>

@Since: 2.6


<!-- ##### MACRO G_GOFFSET_MODIFIER ##### -->
<para>
平台依赖长度修改量的转换符，用于读入和打印 #goffset 类型的值。
这是一个串字面。 见 #G_GINT64_MODIFIER 。
</para>

@Since: 2.20


<!-- ##### MACRO G_GOFFSET_FORMAT ##### -->
<para>
这是一个平台依赖转换符，用于读入和打印 #goffset 类型的值。
见 #G_GINT64_FORMAT 。
</para>

Since: 2.20



