<!-- ##### SECTION Title ##### -->
线程池

<!-- ##### SECTION Short_Description ##### -->
线程的集合，可并行的执行任务

<!-- ##### SECTION Long_Description ##### -->
<para>
有时候，你希望以异步的方式创建一个新的线程来执行任务，
与此同时你自己的线程也在继续工作。如果这样的事情很频繁，
那么每一次创建和销毁线程所占的开销可能会非常的大。在这种
情况下重复使用已经创建的线程似乎是一个好主意；但是，完成
这样的工作可能会令人感到乏味并且容易出错。
</para>

<para>
因此，为了您的方便 GLib 提供了线程池供你使用。并且，另一
个优点就是，当使用 GLib 的时候，这些线程能在你程序的不同
的子系统中共享。
</para>

<para>
创建一个新的线程池，使用 g_thread_pool_new() ；而销毁它
则使用 g_thread_pool_free() 。
</para>

<para>
如果你想在一个执行线程池里执行某项任务，你就调用
g_thread_pool_push() 。
</para>

<para>
要获取你正在使用线程的数目，你可以调用g_thread_pool_get_num_threads() 。
获取仍未处理任务的数目，你可以调用g_thread_pool_unprocessed() 。
想控制一个线程池里线程的最大数目，你可以使用g_thread_pool_get_max_threads() 
和 g_thread_pool_set_max_threads() 。
</para>

<para>
最后你还可以控制未使用线程的数目，通过 GLib 让它们保持
活跃状态供以后使用。要获取当前未使用线程的数目，可以使用
g_thread_pool_get_num_unused_threads() 。想控制未使用线程
的最大值，可以使用 g_thread_pool_get_max_unused_threads() 
和 g_thread_pool_set_max_unused_threads() 。当然，想终止
所有当前未使用线程的话，你可以调用 calling g_thread_pool_stop_unused_threads() 。
</para>

<!-- ##### SECTION See_Also ##### -->
<para>
<variablelist>

<varlistentry>
<term>#GThread</term>
<listitem><para>GLib 线程系统。</para></listitem>
</varlistentry>

</variablelist>
</para>

<!-- ##### SECTION Stability_Level ##### -->


<!-- ##### STRUCT GThreadPool ##### -->
<para>
#GThreadPool 结构体描述为一个线程池。它有三个公共的只读成员，
但结构体内私有的结构是很大的，所以你不能复制此结构体。
</para>

@func: 在线程池的线程里执行的函数
@user_data: 线程池中线程的用户数据指针
@exclusive: 为TRUE表示为不共享方式

<!-- ##### FUNCTION g_thread_pool_new ##### -->
<para>

</para>

@func: 
@user_data: 
@max_threads: 
@exclusive: 
@error: 
@Returns: 


<!-- ##### FUNCTION g_thread_pool_push ##### -->
<para>

</para>

@pool: 
@data: 
@error: 


<!-- ##### FUNCTION g_thread_pool_set_max_threads ##### -->
<para>

</para>

@pool: 
@max_threads: 
@error: 


<!-- ##### FUNCTION g_thread_pool_get_max_threads ##### -->
<para>

</para>

@pool: 
@Returns: 


<!-- ##### FUNCTION g_thread_pool_get_num_threads ##### -->
<para>

</para>

@pool: 
@Returns: 


<!-- ##### FUNCTION g_thread_pool_unprocessed ##### -->
<para>

</para>

@pool: 
@Returns: 


<!-- ##### FUNCTION g_thread_pool_free ##### -->
<para>

</para>

@pool: 
@immediate: 
@wait_: 


<!-- ##### FUNCTION g_thread_pool_set_max_unused_threads ##### -->
<para>

</para>

@max_threads: 


<!-- ##### FUNCTION g_thread_pool_get_max_unused_threads ##### -->
<para>

</para>

@Returns: 


<!-- ##### FUNCTION g_thread_pool_get_num_unused_threads ##### -->
<para>

</para>

@Returns: 


<!-- ##### FUNCTION g_thread_pool_stop_unused_threads ##### -->
<para>

</para>



<!-- ##### FUNCTION g_thread_pool_set_sort_function ##### -->
<para>

</para>

@pool: 
@func: 
@user_data: 


<!-- ##### FUNCTION g_thread_pool_set_max_idle_time ##### -->
<para>

</para>

@interval: 


<!-- ##### FUNCTION g_thread_pool_get_max_idle_time ##### -->
<para>

</para>

@Returns: 


