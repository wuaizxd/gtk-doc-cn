msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2011-04-18 23:24+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. Put one translator per line, in the form of NAME <EMAIL>, YEAR1, YEAR2
#: tut_gtype.xml:0(None)
msgid "translator-credits"
msgstr ""

#: tut_gtype.xml:102(para)
msgid ""
"type characteristic flags: <link linkend=\"GTypeFlags\"><type>GTypeFlags</"
"type></link>."
msgstr ""

#: tut_gtype.xml:114(title)
msgid "Copy functions"
msgstr ""

#: tut_gtype.xml:116(para)
msgid ""
"The major common point between <emphasis>all</emphasis> GLib types "
"(fundamental and non-fundamental, classed and non-classed, instantiable and "
"non-instantiable) is that they can all be manipulated through a single API "
"to copy/assign them."
msgstr ""

#: tut_gtype.xml:12(programlisting)
#, no-wrap
msgid ""
"\n"
"typedef struct _GTypeInfo               GTypeInfo;\n"
"struct _GTypeInfo\n"
"{\n"
"  /* interface types, classed types, instantiated types */\n"
"  guint16                class_size;\n"
"  \n"
"  GBaseInitFunc          base_init;\n"
"  GBaseFinalizeFunc      base_finalize;\n"
"  \n"
"  /* classed types, instantiated types */\n"
"  GClassInitFunc         class_init;\n"
"  GClassFinalizeFunc     class_finalize;\n"
"  gconstpointer          class_data;\n"
"  \n"
"  /* instantiated types */\n"
"  guint16                instance_size;\n"
"  guint16                n_preallocs;\n"
"  GInstanceInitFunc      instance_init;\n"
"  \n"
"  /* value handling */\n"
"  const GTypeValueTable *value_table;\n"
"};\n"
"GType g_type_register_static (GType             parent_type,\n"
"                              const gchar      *type_name,\n"
"                              const GTypeInfo  *info,\n"
"                              GTypeFlags        flags);\n"
"GType g_type_register_fundamental (GType                       type_id,\n"
"                                   const gchar                *type_name,\n"
"                                   const GTypeInfo            *info,\n"
"                                   const GTypeFundamentalInfo *finfo,\n"
"                                   GTypeFlags                  flags);\n"
"        "
msgstr ""

#: tut_gtype.xml:122(para)
msgid ""
"The <link linkend=\"GValue\"><type>GValue</type></link> structure is used as "
"an abstract container for all of these types. Its simplistic API (defined in "
"<filename>gobject/gvalue.h</filename>) can be used to invoke the value_table "
"functions registered during type registration: for example <function><link "
"linkend=\"g-value-copy\">g_value_copy</link></function> copies the content "
"of a <link linkend=\"GValue\"><type>GValue</type></link> to another <link "
"linkend=\"GValue\"><type>GValue</type></link>. This is similar to a C++ "
"assignment which invokes the C++ copy operator to modify the default bit-by-"
"bit copy semantics of C++/C structures/classes."
msgstr ""

#: tut_gtype.xml:132(para)
msgid ""
"The following code shows how you can copy around a 64 bit integer, as well "
"as a <link linkend=\"GObject\"><type>GObject</type></link> instance pointer "
"(sample code for this is located in the source tarball for this document in "
"<filename>sample/gtype/test.c</filename>): <placeholder-1/> The important "
"point about the above code is that the exact semantics of the copy calls is "
"undefined since they depend on the implementation of the copy function. "
"Certain copy functions might decide to allocate a new chunk of memory and "
"then to copy the data from the source to the destination. Others might want "
"to simply increment the reference count of the instance and copy the "
"reference to the new GValue."
msgstr ""

#: tut_gtype.xml:136(programlisting)
#, no-wrap
msgid ""
"\n"
"static void test_int (void)\n"
"{\n"
"  GValue a_value = {0, }; \n"
"  GValue b_value = {0, };\n"
"  guint64 a, b;\n"
"\n"
"  a = 0xdeadbeaf;\n"
"\n"
"  g_value_init (&amp;a_value, G_TYPE_UINT64);\n"
"  g_value_set_uint64 (&amp;a_value, a);\n"
"\n"
"  g_value_init (&amp;b_value, G_TYPE_UINT64);\n"
"  g_value_copy (&amp;a_value, &amp;b_value);\n"
"\n"
"  b = g_value_get_uint64 (&amp;b_value);\n"
"\n"
"  if (a == b) {\n"
"    g_print (\"Yay !! 10 lines of code to copy around a uint64.\\n\");\n"
"  } else {\n"
"    g_print (\"Are you sure this is not a Z80 ?\\n\");\n"
"  }\n"
"}\n"
"\n"
"static void test_object (void)\n"
"{\n"
"  GObject *obj;\n"
"  GValue obj_vala = {0, };\n"
"  GValue obj_valb = {0, };\n"
"  obj = g_object_new (MAMAN_TYPE_BAR, NULL);\n"
"\n"
"  g_value_init (&amp;obj_vala, MAMAN_TYPE_BAR);\n"
"  g_value_set_object (&amp;obj_vala, obj);\n"
"\n"
"  g_value_init (&amp;obj_valb, G_TYPE_OBJECT);\n"
"\n"
"  /* g_value_copy's semantics for G_TYPE_OBJECT types is to copy the reference.\n"
"     This function thus calls g_object_ref.\n"
"     It is interesting to note that the assignment works here because\n"
"     MAMAN_TYPE_BAR is a G_TYPE_OBJECT.\n"
"   */\n"
"  g_value_copy (&amp;obj_vala, &amp;obj_valb);\n"
"\n"
"  g_object_unref (G_OBJECT (obj));\n"
"  g_object_unref (G_OBJECT (obj));\n"
"}\n"
msgstr ""

#: tut_gtype.xml:190(para)
msgid ""
"The value_table used to specify these assignment functions is defined in "
"<filename>gtype.h</filename> and is thoroughly described in the API "
"documentation provided with GObject (for once ;-) which is why we will not "
"detail its exact semantics. <placeholder-1/> Interestingly, it is also very "
"unlikely you will ever need to specify a value_table during type "
"registration because these value_tables are inherited from the parent types "
"for non-fundamental types which means that unless you want to write a "
"fundamental type (not a great idea!), you will not need to provide a new "
"value_table since you will inherit the value_table structure from your "
"parent type."
msgstr ""

#: tut_gtype.xml:195(programlisting)
#, no-wrap
msgid ""
"\n"
"typedef struct _GTypeValueTable         GTypeValueTable;\n"
"struct _GTypeValueTable\n"
"{\n"
"  void     (*value_init)         (GValue       *value);\n"
"  void     (*value_free)         (GValue       *value);\n"
"  void     (*value_copy)         (const GValue *src_value,\n"
"                                  GValue       *dest_value);\n"
"  /* varargs functionality (optional) */\n"
"  gpointer (*value_peek_pointer) (const GValue *value);\n"
"  gchar            *collect_format;\n"
"  gchar*   (*collect_value)      (GValue       *value,\n"
"                                  guint         n_collect_values,\n"
"                                  GTypeCValue  *collect_values,\n"
"                                  guint                collect_flags);\n"
"  gchar            *lcopy_format;\n"
"  gchar*   (*lcopy_value)        (const GValue *value,\n"
"                                  guint         n_collect_values,\n"
"                                  GTypeCValue  *collect_values,\n"
"                                  guint                collect_flags);\n"
"};\n"
"          "
msgstr ""

#: tut_gtype.xml:228(title)
msgid "Conventions"
msgstr ""

#: tut_gtype.xml:231(para)
msgid ""
"There are a number of conventions users are expected to follow when creating "
"new types which are to be exported in a header file: <placeholder-1/> The "
"implementation of these macros is pretty straightforward: a number of simple-"
"to-use macros are provided in <filename>gtype.h</filename>. For the example "
"we used above, we would write the following trivial code to declare the "
"macros: <placeholder-2/><placeholder-3/>"
msgstr ""

#: tut_gtype.xml:235(para)
msgid ""
"Use the <function>object_method</function> pattern for function names: to "
"invoke the method named foo on an instance of object type bar, call "
"<function>bar_foo</function>."
msgstr ""

#: tut_gtype.xml:240(para)
msgid ""
"Use prefixing to avoid namespace conflicts with other projects. If your "
"library (or application) is named <emphasis>Maman</emphasis>, <placeholder-1/"
"> prefix all your function names with <emphasis>maman_</emphasis>. For "
"example: <function>maman_object_method</function>."
msgstr ""

#: tut_gtype.xml:243(para)
msgid ""
"<emphasis>Maman</emphasis> is the French word for <emphasis>mum</emphasis> "
"or <emphasis>mother</emphasis> - nothing more and nothing less."
msgstr ""

#: tut_gtype.xml:252(para)
msgid ""
"Create a macro named <function>PREFIX_TYPE_OBJECT</function> which always "
"returns the GType for the associated object type. For an object of type "
"<emphasis>Bar</emphasis> in a library prefixed by <emphasis>maman</"
"emphasis>, use: <function>MAMAN_TYPE_BAR</function>. It is common although "
"not a convention to implement this macro using either a global static "
"variable or a function named <function>prefix_object_get_type</function>. We "
"will follow the function pattern wherever possible in this document."
msgstr ""

#: tut_gtype.xml:260(para)
msgid ""
"Create a macro named <function>PREFIX_OBJECT (obj)</function> which returns "
"a pointer of type <type>PrefixObject</type>. This macro is used to enforce "
"static type safety by doing explicit casts wherever needed. It also enforces "
"dynamic type safety by doing runtime checks. It is possible to disable the "
"dynamic type checks in production builds (see <link linkend=\"glib-building"
"\">building glib</link>). For example, we would create <function>MAMAN_BAR "
"(obj)</function> to keep the previous example."
msgstr ""

#: tut_gtype.xml:268(para)
msgid ""
"If the type is classed, create a macro named <function>PREFIX_OBJECT_CLASS "
"(klass)</function>. This macro is strictly equivalent to the previous "
"casting macro: it does static casting with dynamic type checking of class "
"structures. It is expected to return a pointer to a class structure of type "
"<type>PrefixObjectClass</type>. Again, an example is: "
"<function>MAMAN_BAR_CLASS</function>."
msgstr ""

#: tut_gtype.xml:275(para)
msgid ""
"Create a macro named <function>PREFIX_IS_BAR (obj)</function>: this macro is "
"expected to return a <type>gboolean</type> which indicates whether or not "
"the input object instance pointer of type BAR."
msgstr ""

#: tut_gtype.xml:279(para)
msgid ""
"If the type is classed, create a macro named "
"<function>PREFIX_IS_OBJECT_CLASS (klass)</function> which, as above, returns "
"a boolean if the input class pointer is a pointer to a class of type OBJECT."
msgstr ""

#: tut_gtype.xml:283(para)
msgid ""
"If the type is classed, create a macro named "
"<function>PREFIX_OBJECT_GET_CLASS (obj)</function> which returns the class "
"pointer associated to an instance of a given type. This macro is used for "
"static and dynamic type safety purposes (just like the previous casting "
"macros)."
msgstr ""

#: tut_gtype.xml:293(programlisting)
#, no-wrap
msgid ""
"\n"
"#define MAMAN_TYPE_BAR                  (maman_bar_get_type ())\n"
"#define MAMAN_BAR(obj)                  (G_TYPE_CHECK_INSTANCE_CAST ((obj), MAMAN_TYPE_BAR, MamanBar))\n"
"#define MAMAN_BAR_CLASS(klass)          (G_TYPE_CHECK_CLASS_CAST ((klass), MAMAN_TYPE_BAR, MamanBarClass))\n"
"#define MAMAN_IS_BAR(obj)          (G_TYPE_CHECK_INSTANCE_TYPE ((obj), MAMAN_TYPE_BAR))\n"
"#define MAMAN_IS_BAR_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), MAMAN_TYPE_BAR))\n"
"#define MAMAN_BAR_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), MAMAN_TYPE_BAR, MamanBarClass))\n"
msgstr ""

#: tut_gtype.xml:301(simpara)
msgid ""
"Stick to the naming <varname>klass</varname> as <varname>class</varname> is "
"a registered c++ keyword."
msgstr ""

#: tut_gtype.xml:304(para)
msgid ""
"The following code shows how to implement the <function>maman_bar_get_type</"
"function> function: <placeholder-1/>"
msgstr ""

#: tut_gtype.xml:307(programlisting)
#, no-wrap
msgid ""
"\n"
"GType maman_bar_get_type (void)\n"
"{\n"
"  static GType type = 0;\n"
"  if (type == 0) {\n"
"    static const GTypeInfo info = {\n"
"      /* You fill this structure. */\n"
"    };\n"
"    type = g_type_register_static (G_TYPE_OBJECT,\n"
"                                   \"MamanBarType\",\n"
"                                   &amp;info, 0);\n"
"  }\n"
"  return type;\n"
"}\n"
msgstr ""

#: tut_gtype.xml:324(para)
msgid ""
"When having no special requirements you also can use the "
"<function>G_DEFINE_TYPE</function> macro: <placeholder-1/>"
msgstr ""

#: tut_gtype.xml:327(programlisting)
#, no-wrap
msgid ""
"\n"
"G_DEFINE_TYPE (MamanBar, maman_bar, G_TYPE_OBJECT)\n"
msgstr ""

#: tut_gtype.xml:335(title)
msgid "Non-instantiable non-classed fundamental types"
msgstr ""

#: tut_gtype.xml:337(para)
msgid ""
"A lot of types are not instantiable by the type system and do not have a "
"class. Most of these types are fundamental trivial types such as "
"<emphasis>gchar</emphasis>, registered in <function>g_value_types_init</"
"function> (in <filename>gvaluetypes.c</filename>)."
msgstr ""

#: tut_gtype.xml:343(para)
msgid ""
"To register such a type in the type system, you just need to fill the <link "
"linkend=\"GTypeInfo\"><type>GTypeInfo</type></link> structure with zeros "
"since these types are also most of the time fundamental: <placeholder-1/>"
msgstr ""

#: tut_gtype.xml:347(programlisting)
#, no-wrap
msgid ""
"\n"
"  GTypeInfo info = {\n"
"    0,                                /* class_size */\n"
"    NULL,                        /* base_init */\n"
"    NULL,                        /* base_destroy */\n"
"    NULL,                        /* class_init */\n"
"    NULL,                        /* class_destroy */\n"
"    NULL,                        /* class_data */\n"
"    0,                                /* instance_size */\n"
"    0,                                /* n_preallocs */\n"
"    NULL,                        /* instance_init */\n"
"    NULL,                        /* value_table */\n"
"  };\n"
"  static const GTypeValueTable value_table = {\n"
"    value_init_long0,                /* value_init */\n"
"    NULL,                        /* value_free */\n"
"    value_copy_long0,                /* value_copy */\n"
"    NULL,                        /* value_peek_pointer */\n"
"    \"i\",                        /* collect_format */\n"
"    value_collect_int,        /* collect_value */\n"
"    \"p\",                        /* lcopy_format */\n"
"    value_lcopy_char,                /* lcopy_value */\n"
"  };\n"
"  info.value_table = &amp;value_table;\n"
"  type = g_type_register_fundamental (G_TYPE_CHAR, \"gchar\", &amp;info, &amp;finfo, 0);\n"
"          "
msgstr ""

#: tut_gtype.xml:376(para)
msgid ""
"Having non-instantiable types might seem a bit useless: what good is a type "
"if you cannot instantiate an instance of that type ? Most of these types are "
"used in conjunction with <link linkend=\"GValue\"><type>GValue</type></"
"link>s: a GValue is initialized with an integer or a string and it is passed "
"around by using the registered type's value_table. <link linkend=\"GValue"
"\"><type>GValue</type></link>s (and by extension these trivial fundamental "
"types) are most useful when used in conjunction with object properties and "
"signals."
msgstr ""

#: tut_gtype.xml:388(title)
msgid "Instantiable classed types: objects"
msgstr ""

#: tut_gtype.xml:390(para)
msgid ""
"Types which are registered with a class and are declared instantiable are "
"what most closely resembles an <emphasis>object</emphasis>. Although <link "
"linkend=\"GObject\"><type>GObject</type></link>s (detailed in <xref linkend="
"\"chapter-gobject\"/>) are the most well known type of instantiable classed "
"types, other kinds of similar objects used as the base of an inheritance "
"hierarchy have been externally developed and they are all built on the "
"fundamental features described below."
msgstr ""

#: tut_gtype.xml:400(para)
msgid ""
"For example, the code below shows how you could register such a fundamental "
"object type in the type system: <placeholder-1/> Upon the first call to "
"<function>maman_bar_get_type</function>, the type named <emphasis>BarType</"
"emphasis> will be registered in the type system as inheriting from the type "
"<emphasis>G_TYPE_OBJECT</emphasis>."
msgstr ""

#: tut_gtype.xml:403(programlisting)
#, no-wrap
msgid ""
"\n"
"typedef struct {\n"
"  GObject parent;\n"
"  /* instance members */\n"
"  int field_a;\n"
"} MamanBar;\n"
"\n"
"typedef struct {\n"
"  GObjectClass parent;\n"
"  /* class members */\n"
"  void (*do_action_public_virtual) (MamanBar *self, guint8 i);\n"
"\n"
"  void (*do_action_public_pure_virtual) (MamanBar *self, guint8 i);\n"
"} MamanBarClass;\n"
"\n"
"#define MAMAN_TYPE_BAR (maman_bar_get_type ())\n"
"\n"
"GType \n"
"maman_bar_get_type (void)\n"
"{\n"
"  static GType type = 0;\n"
"  if (type == 0) {\n"
"    static const GTypeInfo info = {\n"
"      sizeof (MamanBarClass),\n"
"      NULL,           /* base_init */\n"
"      NULL,           /* base_finalize */\n"
"      (GClassInitFunc) foo_class_init,\n"
"      NULL,           /* class_finalize */\n"
"      NULL,           /* class_data */\n"
"      sizeof (MamanBar),\n"
"      0,              /* n_preallocs */\n"
"      (GInstanceInitFunc) NULL /* instance_init */\n"
"    };\n"
"    type = g_type_register_static (G_TYPE_OBJECT,\n"
"                                   \"BarType\",\n"
"                                   &amp;info, 0);\n"
"  }\n"
"  return type;\n"
"}\n"
msgstr ""

#: tut_gtype.xml:448(para)
msgid ""
"Every object must define two structures: its class structure and its "
"instance structure. All class structures must contain as first member a "
"<link linkend=\"GTypeClass\"><type>GTypeClass</type></link> structure. All "
"instance structures must contain as first member a <link linkend="
"\"GTypeInstance\"><type>GTypeInstance</type></link> structure. The "
"declaration of these C types, coming from <filename>gtype.h</filename> is "
"shown below: <placeholder-1/> These constraints allow the type system to "
"make sure that every object instance (identified by a pointer to the "
"object's instance structure) contains in its first bytes a pointer to the "
"object's class structure."
msgstr ""

#: tut_gtype.xml:454(programlisting)
#, no-wrap
msgid ""
"\n"
"struct _GTypeClass\n"
"{\n"
"  GType g_type;\n"
"};\n"
"struct _GTypeInstance\n"
"{\n"
"  GTypeClass *g_class;\n"
"};\n"
msgstr ""

#: tut_gtype.xml:468(para)
msgid ""
"This relationship is best explained by an example: let's take object B which "
"inherits from object A: <placeholder-1/> The C standard mandates that the "
"first field of a C structure is stored starting in the first byte of the "
"buffer used to hold the structure's fields in memory. This means that the "
"first field of an instance of an object B is A's first field which in turn "
"is GTypeInstance's first field which in turn is g_class, a pointer to B's "
"class structure."
msgstr ""

#: tut_gtype.xml:47(para)
msgid ""
"<function><link linkend=\"g-type-register-static\">g_type_register_static</"
"link></function> and <function><link linkend=\"g-type-register-fundamental"
"\">g_type_register_fundamental</link></function> are the C functions, "
"defined in <filename>gtype.h</filename> and implemented in <filename>gtype."
"c</filename> which you should use to register a new <link linkend=\"GType"
"\"><type>GType</type></link> in the program's type system. It is not likely "
"you will ever need to use <function><link linkend=\"g-type-register-"
"fundamental\">g_type_register_fundamental</link></function> (you have to be "
"Tim Janik to do that) but in case you want to, the last chapter explains how "
"to create new fundamental types. <placeholder-1/>"
msgstr ""

#: tut_gtype.xml:471(programlisting)
#, no-wrap
msgid ""
"\n"
"/* A definitions */\n"
"typedef struct {\n"
"  GTypeInstance parent;\n"
"  int field_a;\n"
"  int field_b;\n"
"} A;\n"
"typedef struct {\n"
"  GTypeClass parent_class;\n"
"  void (*method_a) (void);\n"
"  void (*method_b) (void);\n"
"} AClass;\n"
"\n"
"/* B definitions. */\n"
"typedef struct {\n"
"  A parent;\n"
"  int field_c;\n"
"  int field_d;\n"
"} B;\n"
"typedef struct {\n"
"  AClass parent_class;\n"
"  void (*method_c) (void);\n"
"  void (*method_d) (void);\n"
"} BClass;\n"
msgstr ""

#: tut_gtype.xml:503(para)
msgid ""
"Thanks to these simple conditions, it is possible to detect the type of "
"every object instance by doing: <placeholder-1/> or, more quickly: "
"<placeholder-2/>"
msgstr ""

#: tut_gtype.xml:506(programlisting)
#, no-wrap
msgid ""
"\n"
"B *b;\n"
"b-&gt;parent.parent.g_class-&gt;g_type\n"
msgstr ""

#: tut_gtype.xml:511(programlisting)
#, no-wrap
msgid ""
"\n"
"B *b;\n"
"((GTypeInstance*)b)-&gt;g_class-&gt;g_type\n"
msgstr ""

#: tut_gtype.xml:518(title)
msgid "Initialization and Destruction"
msgstr ""

#: tut_gtype.xml:520(para)
msgid ""
"instantiation of these types can be done with <function><link linkend=\"g-"
"type-create-instance\">g_type_create_instance</link></function>: "
"<placeholder-1/><function><link linkend=\"g-type-create-instance"
"\">g_type_create_instance</link></function> will look up the type "
"information structure associated to the type requested. Then, the instance "
"size and instantiation policy (if the n_preallocs field is set to a non-zero "
"value, the type system allocates the object's instance structures in chunks "
"rather than mallocing for every instance) declared by the user are used to "
"get a buffer to hold the object's instance structure."
msgstr ""

#: tut_gtype.xml:523(programlisting)
#, no-wrap
msgid ""
"\n"
"GTypeInstance* g_type_create_instance (GType          type);\n"
"void           g_type_free_instance   (GTypeInstance *instance);\n"
msgstr ""

#: tut_gtype.xml:535(para)
msgid ""
"If this is the first instance of the object ever created, the type system "
"must create a class structure: it allocates a buffer to hold the object's "
"class structure and initializes it. It first copies the parent's class "
"structure over this structure (if there is no parent, it initializes it to "
"zero). It then invokes the base_class_initialization functions (<link "
"linkend=\"GBaseInitFunc\"><type>GBaseInitFunc</type></link>) from topmost "
"fundamental object to bottom-most most derived object. The object's "
"class_init (<link linkend=\"GClassInitFunc\"><type>GClassInitFunc</type></"
"link>) function is invoked afterwards to complete initialization of the "
"class structure. Finally, the object's interfaces are initialized (we will "
"discuss interface initialization in more detail later)."
msgstr ""

#: tut_gtype.xml:548(para)
msgid ""
"Once the type system has a pointer to an initialized class structure, it "
"sets the object's instance class pointer to the object's class structure and "
"invokes the object's instance_init (<link linkend=\"GInstanceInitFunc"
"\"><type>GInstanceInitFunc</type></link>)functions, from top-most "
"fundamental type to bottom-most most derived type."
msgstr ""

#: tut_gtype.xml:555(para)
msgid ""
"Object instance destruction through <function><link linkend=\"g-type-free-"
"instance\">g_type_free_instance</link></function> is very simple: the "
"instance structure is returned to the instance pool if there is one and if "
"this was the last living instance of the object, the class is destroyed."
msgstr ""

#: tut_gtype.xml:562(para)
msgid ""
"Class destruction (the concept of destruction is sometimes partly referred "
"to as finalization in GType) is the symmetric process of the initialization: "
"interfaces are destroyed first. Then, the most derived class_finalize (<link "
"linkend=\"ClassFinalizeFunc\"><type>ClassFinalizeFunc</type></link>) "
"function is invoked. The base_class_finalize (<link linkend="
"\"GBaseFinalizeFunc\"><type>GBaseFinalizeFunc</type></link>) functions are "
"Finally invoked from bottom-most most-derived type to top-most fundamental "
"type and the class structure is freed."
msgstr ""

#: tut_gtype.xml:573(para)
msgid ""
"As many readers have now understood it, the base initialization/finalization "
"process is very similar to the C++ constructor/destructor paradigm. The "
"practical details are different though and it is important not to get "
"confused by superficial similarities. GTypes have no instance destruction "
"mechanism. It is the user's responsibility to implement correct destruction "
"semantics on top of the existing GType code. (this is what GObject does. See "
"<xref linkend=\"chapter-gobject\"/>) Furthermore, C++ code equivalent to the "
"base_init and class_init callbacks of GType is usually not needed because C+"
"+ cannot really create object types at runtime."
msgstr ""

#: tut_gtype.xml:58(para)
msgid ""
"Please note that there exists another registration function: the "
"<function><link linkend=\"g-type-register-dynamic\">g_type_register_dynamic</"
"link></function>. We will not discuss this function here since its use is "
"very similar to the <function>_static</function> version."
msgstr ""

#: tut_gtype.xml:586(para)
msgid ""
"The instantiation/finalization process can be summarized as follows: <table "
"id=\"gtype-init-fini-table\"><placeholder-1/><tgroup cols=\"3\"><colspec "
"colwidth=\"*\" colnum=\"1\" align=\"left\"/><colspec colwidth=\"*\" colnum="
"\"2\" align=\"left\"/><colspec colwidth=\"8*\" colnum=\"3\" align=\"left\"/"
"><thead><row><entry>Invocation time</entry><entry>Function Invoked</"
"entry><entry>Function's parameters</entry></row></thead><tbody><row><entry "
"morerows=\"2\">First call to <function><link linkend=\"g-type-create-instance"
"\">g_type_create_instance</link></function> for target type</"
"entry><entry>type's base_init function</entry><entry>On the inheritance tree "
"of classes from fundamental type to target type. base_init is invoked once "
"for each class structure.</entry></row><row><entry>target type's class_init "
"function</entry><entry>On target type's class structure</entry></"
"row><row><entry>interface initialization, see <xref linkend=\"gtype-non-"
"instantiable-classed-init\"/></entry><entry/></row><row><entry>Each call to "
"<function><link linkend=\"g-type-create-instance\">g_type_create_instance</"
"link></function> for target type</entry><entry>target type's instance_init "
"function</entry><entry>On object's instance</entry></row><row><entry "
"morerows=\"2\">Last call to <function><link linkend=\"g-type-free-instance"
"\">g_type_free_instance</link></function> for target type</"
"entry><entry>interface destruction, see <xref linkend=\"gtype-non-"
"instantiable-classed-dest\"/></entry><entry/></row><row><entry>target type's "
"class_finalize function</entry><entry>On target type's class structure</"
"entry></row><row><entry>type's base_finalize function</entry><entry>On the "
"inheritance tree of classes from fundamental type to target type. "
"base_finalize is invoked once for each class structure.</entry></row></"
"tbody></tgroup></table>"
msgstr ""

#: tut_gtype.xml:589(title)
msgid "GType Instantiation/Finalization"
msgstr ""

#: tut_gtype.xml:6(title)
msgid "The GLib Dynamic Type System"
msgstr ""

#: tut_gtype.xml:652(title)
msgid "Non-instantiable classed types: interfaces"
msgstr ""

#: tut_gtype.xml:654(para)
msgid ""
"GType's interfaces are very similar to Java's interfaces. They allow to "
"describe a common API that several classes will adhere to. Imagine the play, "
"pause and stop buttons on hi-fi equipment - those can be seen as a playback "
"interface. Once you know what they do, you can control your CD player, MP3 "
"player or anything that uses these symbols. To declare an interface you have "
"to register a non-instantiable classed type which derives from <link linkend="
"\"GTypeInterface\"><type>GTypeInterface</type></link>. The following piece "
"of code declares such an interface. <placeholder-1/> The interface function, "
"<function>maman_ibaz_do_action</function> is implemented in a pretty simple "
"way: <placeholder-2/><function>maman_ibaz_get_type</function> registers a "
"type named <emphasis>MamanIBaz</emphasis> which inherits from "
"G_TYPE_INTERFACE. All interfaces must be children of G_TYPE_INTERFACE in the "
"inheritance tree."
msgstr ""

#: tut_gtype.xml:663(programlisting)
#, no-wrap
msgid ""
"\n"
"#define MAMAN_TYPE_IBAZ                (maman_ibaz_get_type ())\n"
"#define MAMAN_IBAZ(obj)                (G_TYPE_CHECK_INSTANCE_CAST ((obj), MAMAN_TYPE_IBAZ, MamanIbaz))\n"
"#define MAMAN_IS_IBAZ(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), MAMAN_TYPE_IBAZ))\n"
"#define MAMAN_IBAZ_GET_INTERFACE(inst) (G_TYPE_INSTANCE_GET_INTERFACE ((inst), MAMAN_TYPE_IBAZ, MamanIbazInterface))\n"
"\n"
"typedef struct _MamanIbaz MamanIbaz; /* dummy object */\n"
"typedef struct _MamanIbazInterface MamanIbazInterface;\n"
"\n"
"struct _MamanIbazInterface {\n"
"  GTypeInterface parent;\n"
"\n"
"  void (*do_action) (MamanIbaz *self);\n"
"};\n"
"\n"
"GType maman_ibaz_get_type (void);\n"
"\n"
"void maman_ibaz_do_action (MamanIbaz *self);\n"
msgstr ""

#: tut_gtype.xml:67(para)
msgid ""
"Fundamental types are top-level types which do not derive from any other "
"type while other non-fundamental types derive from other types. Upon "
"initialization by <function><link linkend=\"g-type-init\">g_type_init</"
"link></function>, the type system not only initializes its internal data "
"structures but it also registers a number of core types: some of these are "
"fundamental types. Others are types derived from these fundamental types."
msgstr ""

#: tut_gtype.xml:684(programlisting)
#, no-wrap
msgid ""
"\n"
"void maman_ibaz_do_action (MamanIbaz *self)\n"
"{\n"
"  MAMAN_IBAZ_GET_INTERFACE (self)-&gt;do_action (self);\n"
"}\n"
msgstr ""

#: tut_gtype.xml:695(para)
msgid ""
"An interface is defined by only one structure which must contain as first "
"member a <link linkend=\"GTypeInterface\"><type>GTypeInterface</type></link> "
"structure. The interface structure is expected to contain the function "
"pointers of the interface methods. It is good style to define helper "
"functions for each of the interface methods which simply call the interface' "
"method directly: <function>maman_ibaz_do_action</function> is one of these."
msgstr ""

#: tut_gtype.xml:704(para)
msgid ""
"Once an interface type is registered, you must register implementations for "
"these interfaces. The function named <function>maman_baz_get_type</function> "
"registers a new GType named MamanBaz which inherits from <link linkend="
"\"GObject\"><type>GObject</type></link> and which implements the interface "
"<type>MamanIBaz</type>. <placeholder-1/>"
msgstr ""

#: tut_gtype.xml:709(programlisting)
#, no-wrap
msgid ""
"\n"
"static void maman_baz_do_action (MamanIbaz *self)\n"
"{\n"
"  g_print (\"Baz implementation of IBaz interface Action.\\n\");\n"
"}\n"
"\n"
"\n"
"static void\n"
"baz_interface_init (gpointer         g_iface,\n"
"                    gpointer         iface_data)\n"
"{\n"
"  MamanIbazInterface *iface = (MamanIbazInterface *)g_iface;\n"
"  iface-&gt;do_action = maman_baz_do_action;\n"
"}\n"
"\n"
"GType \n"
"maman_baz_get_type (void)\n"
"{\n"
"  static GType type = 0;\n"
"  if (type == 0) {\n"
"    static const GTypeInfo info = {\n"
"      sizeof (MamanBazInterface),\n"
"      NULL,   /* base_init */\n"
"      NULL,   /* base_finalize */\n"
"      NULL,   /* class_init */\n"
"      NULL,   /* class_finalize */\n"
"      NULL,   /* class_data */\n"
"      sizeof (MamanBaz),\n"
"      0,      /* n_preallocs */\n"
"      NULL    /* instance_init */\n"
"    };\n"
"    static const GInterfaceInfo ibaz_info = {\n"
"      (GInterfaceInitFunc) baz_interface_init,    /* interface_init */\n"
"      NULL,               /* interface_finalize */\n"
"      NULL          /* interface_data */\n"
"    };\n"
"    type = g_type_register_static (G_TYPE_OBJECT,\n"
"                                   \"MamanBazType\",\n"
"                                   &amp;info, 0);\n"
"    g_type_add_interface_static (type,\n"
"                                 MAMAN_TYPE_IBAZ,\n"
"                                 &amp;ibaz_info);\n"
"  }\n"
"  return type;\n"
"}\n"
msgstr ""

#: tut_gtype.xml:757(para)
msgid ""
"<function><link linkend=\"g-type-add-interface-static"
"\">g_type_add_interface_static</link></function> records in the type system "
"that a given type implements also <type>FooInterface</type> "
"(<function>foo_interface_get_type</function> returns the type of "
"<type>FooInterface</type>). The <link linkend=\"GInterfaceInfo"
"\"><type>GInterfaceInfo</type></link> structure holds information about the "
"implementation of the interface: <placeholder-1/>"
msgstr ""

#: tut_gtype.xml:76(para)
msgid ""
"Fundamental and non-fundamental types are defined by: <placeholder-1/> "
"Fundamental types are also defined by a set of <link linkend="
"\"GTypeFundamentalFlags\"><type>GTypeFundamentalFlags</type></link> which "
"are stored in a <link linkend=\"GTypeFundamentalInfo"
"\"><type>GTypeFundamentalInfo</type></link>. Non-fundamental types are "
"furthermore defined by the type of their parent which is passed as the "
"parent_type parameter to <function><link linkend=\"g-type-register-static"
"\">g_type_register_static</link></function> and <function><link linkend=\"g-"
"type-register-dynamic\">g_type_register_dynamic</link></function>."
msgstr ""

#: tut_gtype.xml:764(programlisting)
#, no-wrap
msgid ""
"\n"
"struct _GInterfaceInfo\n"
"{\n"
"  GInterfaceInitFunc     interface_init;\n"
"  GInterfaceFinalizeFunc interface_finalize;\n"
"  gpointer               interface_data;\n"
"};\n"
msgstr ""

#: tut_gtype.xml:773(para)
msgid ""
"When having no special requirements you also can use the "
"<function>G_DEFINE_INTERFACE</function> macro: <placeholder-1/>"
msgstr ""

#: tut_gtype.xml:775(programlisting)
#, no-wrap
msgid ""
"\n"
"G_DEFINE_INTERFACE (MamanBaz, maman_baz, G_TYPE_OBJECT)\n"
msgstr ""

#: tut_gtype.xml:782(title) tut_gtype.xml:839(title)
msgid "Interface Initialization"
msgstr ""

#: tut_gtype.xml:784(para)
msgid ""
"When an instantiable classed type which registered an interface "
"implementation is created for the first time, its class structure is "
"initialized following the process described in <xref linkend=\"gtype-"
"instantiable-classed\"/>. After that, the interface implementations "
"associated with the type are initialized."
msgstr ""

#: tut_gtype.xml:79(para)
msgid ""
"class size: the class_size field in <link linkend=\"GTypeInfo"
"\"><type>GTypeInfo</type></link>."
msgstr ""

#: tut_gtype.xml:793(para)
msgid ""
"First a memory buffer is allocated to hold the interface structure. The "
"parent's interface structure is then copied over to the new interface "
"structure (the parent interface is already initialized at that point). If "
"there is no parent interface, the interface structure is initialized with "
"zeros. The g_type and the g_instance_type fields are then initialized: "
"g_type is set to the type of the most-derived interface and g_instance_type "
"is set to the type of the most derived type which implements this interface."
msgstr ""

#: tut_gtype.xml:8(para)
msgid ""
"A type, as manipulated by the GLib type system, is much more generic than "
"what is usually understood as an Object type. It is best explained by "
"looking at the structure and the functions used to register new types in the "
"type system. <placeholder-1/>"
msgstr ""

#: tut_gtype.xml:803(para)
msgid ""
"Finally, the interface' most-derived <function>base_init</function> function "
"and then the implementation's <function>interface_init</function> function "
"are invoked. It is important to understand that if there are multiple "
"implementations of an interface the <function>base_init</function> and "
"<function>interface_init</function> functions will be invoked once for each "
"implementation initialized."
msgstr ""

#: tut_gtype.xml:812(para)
msgid ""
"It is thus common for base_init functions to hold a local static boolean "
"variable which makes sure that the interface type is initialized only once "
"even if there are multiple implementations of the interface: <placeholder-1/>"
msgstr ""

#: tut_gtype.xml:816(programlisting)
#, no-wrap
msgid ""
"\n"
"static void\n"
"maman_ibaz_base_init (gpointer g_iface)\n"
"{\n"
"  static gboolean initialized = FALSE;\n"
"\n"
"  if (!initialized) {\n"
"    /* create interface signals here. */\n"
"    initialized = TRUE;\n"
"  }\n"
"}\n"
msgstr ""

#: tut_gtype.xml:82(para)
msgid ""
"class initialization functions (C++ constructor): the base_init and "
"class_init fields in <link linkend=\"GTypeInfo\"><type>GTypeInfo</type></"
"link>."
msgstr ""

#: tut_gtype.xml:830(para)
msgid ""
"If you have found the stuff about interface hairy, you are right: it is "
"hairy but there is not much I can do about it. What I can do is summarize "
"what you need to know about interfaces:"
msgstr ""

#: tut_gtype.xml:836(para)
msgid ""
"The above process can be summarized as follows: <table id=\"ginterface-init-"
"table\"><placeholder-1/><tgroup cols=\"3\"><colspec colwidth=\"*\" colnum="
"\"1\" align=\"left\"/><colspec colwidth=\"*\" colnum=\"2\" align=\"left\"/"
"><colspec colwidth=\"8*\" colnum=\"3\" align=\"left\"/"
"><thead><row><entry>Invocation time</entry><entry>Function Invoked</"
"entry><entry>Function's parameters</entry><entry>Remark</entry></row></"
"thead><tbody><row><entry morerows=\"1\">First call to <function><link "
"linkend=\"g-type-create-instance\">g_type_create_instance</link></function> "
"for type implementing interface </entry><entry>interface' base_init "
"function</entry><entry>On interface' vtable</entry><entry>Register "
"interface' signals here (use a local static boolean variable as described "
"above to make sure not to register them twice.).</entry></"
"row><row><entry>interface' interface_init function</entry><entry>On "
"interface' vtable</entry><entry> Initialize interface' implementation. That "
"is, initialize the interface method pointers in the interface structure to "
"the function's implementation. </entry></row></tbody></tgroup></table> It is "
"highly unlikely (i.e. I do not know of <emphasis>anyone</emphasis> who "
"actually used it) you will ever need other more fancy things such as the "
"ones described in the following section (<xref linkend=\"gtype-non-"
"instantiable-classed-dest\"/>)."
msgstr ""

#: tut_gtype.xml:86(para)
msgid ""
"class destruction functions (C++ destructor): the base_finalize and "
"class_finalize fields in <link linkend=\"GTypeInfo\"><type>GTypeInfo</type></"
"link>."
msgstr ""

#: tut_gtype.xml:886(title)
msgid "Interface Destruction"
msgstr ""

#: tut_gtype.xml:888(para)
msgid ""
"When the last instance of an instantiable type which registered an interface "
"implementation is destroyed, the interface's implementations associated to "
"the type are destroyed."
msgstr ""

#: tut_gtype.xml:894(para)
msgid ""
"To destroy an interface implementation, GType first calls the "
"implementation's <function>interface_finalize</function> function and then "
"the interface's most-derived <function>base_finalize</function> function."
msgstr ""

#: tut_gtype.xml:90(para)
msgid ""
"instance size (C++ parameter to new): the instance_size field in <link "
"linkend=\"GTypeInfo\"><type>GTypeInfo</type></link>."
msgstr ""

#: tut_gtype.xml:901(para)
msgid ""
"Again, it is important to understand, as in <xref linkend=\"gtype-non-"
"instantiable-classed-init\"/>, that both <function>interface_finalize</"
"function> and <function>base_finalize</function> are invoked exactly once "
"for the destruction of each implementation of an interface. Thus, if you "
"were to use one of these functions, you would need to use a static integer "
"variable which would hold the number of instances of implementations of an "
"interface such that the interface's class is destroyed only once (when the "
"integer variable reaches zero)."
msgstr ""

#: tut_gtype.xml:911(para)
msgid ""
"The above process can be summarized as follows: <table id=\"ginterface-fini-"
"table\"><placeholder-1/><tgroup cols=\"3\"><colspec colwidth=\"*\" colnum="
"\"1\" align=\"left\"/><colspec colwidth=\"*\" colnum=\"2\" align=\"left\"/"
"><colspec colwidth=\"8*\" colnum=\"3\" align=\"left\"/"
"><thead><row><entry>Invocation time</entry><entry>Function Invoked</"
"entry><entry>Function's parameters</entry></row></thead><tbody><row><entry "
"morerows=\"1\">Last call to <function><link linkend=\"g-type-free-instance"
"\">g_type_free_instance</link></function> for type implementing interface </"
"entry><entry>interface' interface_finalize function</entry><entry>On "
"interface' vtable</entry></row><row><entry>interface' base_finalize "
"function</entry><entry>On interface' vtable</entry></row></tbody></tgroup></"
"table>"
msgstr ""

#: tut_gtype.xml:914(title)
msgid "Interface Finalization"
msgstr ""

#: tut_gtype.xml:94(para)
msgid ""
"instantiation policy (C++ type of new operator): the n_preallocs field in "
"<link linkend=\"GTypeInfo\"><type>GTypeInfo</type></link>."
msgstr ""

#: tut_gtype.xml:98(para)
msgid ""
"copy functions (C++ copy operators): the value_table field in <link linkend="
"\"GTypeInfo\"><type>GTypeInfo</type></link>."
msgstr ""
