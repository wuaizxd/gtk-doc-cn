<refentry id="glib-cross-compiling" revision="8 Apr 2003">
<refmeta>
<refentrytitle>交叉编译GLib软件包</refentrytitle>
<manvolnum>3</manvolnum>
<refmiscinfo>GLib库</refmiscinfo>
</refmeta>

<refnamediv>
<refname>交叉编译GLib软件包</refname>
<refpurpose>
如何交叉编译GLib
</refpurpose>
</refnamediv>

    <refsect1 id="cross">
      <title>在不同的体系结构中编译</title>
      <para>
        编译出来的程序或库将在不同的平台或操作系统上运行时，
	这种编译过程就叫做交叉编译。
	GLib和一些常见软件包的交叉编译稍微有些不同，
	因为GLib需要隐藏不同系统之间的一些差异。
      </para>
      <para>
        下面说明一些GLib交叉编译时的特殊之处，
	一般的交叉编译信息请查看
	<application>autoconf</application> 信息页。
      </para>
      <para>
        GLib在编译和链接时会努力去尝试检测尽可能多的有关
	目标系统的信息。但是，GLib需要的一些信息不是通过
	这种方式的。这些信息通过一个"cache"文件提供给配置
	(configure)脚本或者通过设置环境变量的方式实现。
      </para>
      <para>
        作为一份示例的cache文件，用于在Linux系统上采用"MingW32"交叉
	编译可运行于Win32环境中的GLib。
	创建一个名为"win32.cache"的文件，包含以下内容：
      </para>
      <programlisting> 
glib_cv_long_long_format=I64
glib_cv_stack_grows=no
      </programlisting>
      <para>
        接着执行以下命令：
      </para>
      <programlisting>
PATH=/path/to/mingw32-compiler/bin:$PATH
chmod a-w win32.cache   # prevent configure from changing it
./configure --cache-file=win32.cache --host=mingw32
      </programlisting>
      <para>
      下面列出了cache文件的全部变量。其中一些变量通常并不需要设置。
      </para>
    </refsect1>
    <refsect1 id="cache-file-variables">
      <title>缓存文件变量</title>
      <formalpara>
        <title>glib_cv_long_long_format=[ll/q/I64]</title>
        
        <para>
	为64位整形数而使用于<function>printf()</function>和<function>scanf()</function>函数的格式化部分。
	"ll"是C99的标准，
	被'trio'库使用来编译GLib,
	如果你的<function>printf()</function>函数不能胜任的话。
	如果你正在编译使用trio的话是不需要设置的。
        </para>
      </formalpara>
      <formalpara>
        <title>glib_cv_stack_grows=[yes/no]</title>

        <para>
	堆栈是否向上或向下增长。大多数地方都需要设置为"no"，
	有几个体系结构，如PA-RISC等需要设置为"yes"。
        </para>
      </formalpara>
      <formalpara>
        <title>glib_cv_working_bcopy=[yes/no]</title>

        <para>
	<function>bcopy()</function>函数是否可以处理重叠的复制。
	如果你没有<function>memmove()</function>, 就需要设置。（可能性非常小）
	</para>
      </formalpara>
      <formalpara>
         <title>glib_cv_sane_realloc=[yes/np]</title>

         <para>  
	 是否<function>realloc()</function>函数符合ANSI C标准并能够处理第一个参数为<literal>NULL</literal>的情况。
	 默认为"yes", 你可能并不需要设定它。
	</para>
      </formalpara>
      <formalpara>
         <title>glib_cv_have_strlcpy=[yes/no]</title>

         <para>
	 是否有匹配OpenBSD的<function>strlcpy()</function>函数。
	 默认值为"no"，这是安全的，因为在这种情况下GLib使用内置的版本。
	</para>
      </formalpara>
      <formalpara>
         <title>glib_cv_va_val_copy=[yes/no]</title>
   
         <para>
	 <type>va_list</type>是否可以作为指针复制。
	 如果设置为"no"，那么<function>memcopy()</function>将被使用。
	 如果你没有<function>va_copy()</function>或<function>__va_copy()</function>会有问题。（所以，GCC不存在问题。）
	 默认为"yes"，这种情况比"no"要多一些。
	</para>
      </formalpara>
      <formalpara>
         <title>glib_cv_rtldglobal_broken=[yes/no]</title>
 
         <para>
	 是否在OSF/1 v5.0中发现存在有bug。默认为"no"。
         </para>
      </formalpara>
      <formalpara>
         <title>glib_cv_uscore=[yes/no]</title>

         <para>
	 通过<function>dlsym()</function>函数时，
	 是否需要考虑一个下划线为前缀的符号时，
	 他们希望通过dlsym了（）。
	 只需要设置如果你的系统使用<function>dlopen()</function>/<function>dlsym()</function>。
	 </para>
      </formalpara>
      <formalpara>
         <title>ac_cv_func_posix_getpwuid_r=[yes/no]</title>

         <para>
	 是否你的getpwuid_r函数(在你的C库，而不是线程库)遵守POSIX规范。
	 接受'struct passwd **'作为最终的参数。
         </para>
      </formalpara>
      <formalpara>
         <title>ac_cv_func_nonposix_getpwuid_r=[yes/no]</title>
 
         <para>
是否你有一些<function>getpwuid_r()</function>函数的变量不能遵守POSIX规范，
但是GLib有能力去使用它(或者发生段错误)。
只有在<literal>ac_cv_func_posix_getpwuid_r</literal>
没被设置的情况下才需要设置此变量。
此变量可以安全地被设置为"no".
         </para>
      </formalpara>
      <formalpara>
         <title>ac_cv_func_posix_getgrgid_r=[yes/no]</title>
 
         <para>
	 是否你有一个getgrgid_r函数去遵守POSIX规范。
         </para>
      </formalpara>
      <formalpara>
         <title>glib_cv_use_pid_surrogate=[yes/no]</title>

         <para>
	 是否使用<function>setpriority()</function>函数在线程的PID上，
	 作为设置线程优先级的方式。
	 只有在使用POSIX线程的时候需要设置。
         </para>
      </formalpara>
      <formalpara>
         <title>ac_cv_func_printf_unix98=[yes/no]</title>

         <para>
	是否你的<function>printf()</function>函数支持Unix98样式的<literal>%N$</literal> 位置参数。
	默认为"no"。
         </para>
      </formalpara>
      <formalpara>
         <title>ac_cv_func_vsnprintf_c99=[yes/no]</title>

         <para>
	 是否你有一个<function>vsnprintf()</function>函数符合C99的。
	 (C99语义的意思是返回字符数，被写到输入缓存有足够的空间)。
	 默认为"no"。
         </para>
      </formalpara>

    </refsect1>    

</refentry>
